# Natural Experiments {#NE}

Natural Experiments are situations due to the natural course of events that approximate the conditions of a randomized controlled trial.
In the economists' toolkit, we generally make a distinction between:

  1. Instrumental variables (IV), that rely on finding a plausibly exogeneous source of variation in treatment intake.
  2. Regression Discontinuity Designs (RDD), that exploit a discontinuity in the eligibility to the treatment.
  3. Difference In Differences (DID), that make use of the differential exposure of some groups to the treatment of interest over time.
  
```{remark}
The term *Natural Experiments* seems to be mostly used by economists.
It dates back to Haavelmo (1944)'s paper on the Probability Approach to Econometrics, where he makes a distinction between the experiments we'd like to make as social scientists and the experiments that Nature provides us with, that are in general a subset of the experiments we'd like to make.
This raises the question of our ability to **identify** the relationships of interest from the variation that is present in the data, a traditional problem in classical econometrics that has echoes in treatment effect estimation, where we also try to *identify* treatment effect parameters.
At the time of Haavelmo, and until the beginning of the 1990s, there was no real discussion of the plausibility of the *identifying assumptions* (or restrictions) required for identification of certain relations, outside of a discussion of their theoretical plausiblility.
With the credibility revolution brought about by Angrist (1990)'s paper and summarized in Angrist and Krueger (2001)'s review paper, the notion of natural experiment made a come back, with the idea that we might be able to look for specific set of events produced by Nature that more credibly identify a relationship of interest, *i.e.* that closely approximate true experimental conditions.
```

```{remark}
Outside of economics, Natural Experiments have also flourished, but without the term, and were compiled in the early textbook on research methods by Campbell (1966).
Both Difference In Differences and Regression Discontinuity Designs have been actually developed outside of economics, mostly in education research.
Instrumental Variables have had a separate history in economics and in genetics, were it is called the method of path coefficients. 
```

## Instrumental Variables

Instrumental Variables rely on finding a plausibly exogeneous source of variation in treatment intake.
In the simple case of a binary instrument, the identification and estimation parts are actually identical to Encouragements designs in RCTs, that we have already studied in Section \@ref(sec:design4).
As a consequence, unless we make very strong assumptions, an IV design is going to recover a Local Average Treatment Effect.
Our classical assumptions are going to show up again: Independence, Exclusion Restriction, Monotonicity.

```{remark}
Examples of Instrumental Variables are:
```

  - Distance to college or to school for studying the impact of college or school enrollement on education, earnings and other outcomes.
  - Random draft lottery number for investigating the impact of military experience on earnings and other outcomes.
  - Randomized encouragement to participate in order to study the impact of a program.

```{remark}
The crucial part of an IV design is to justify the credibility of the exclusion restriction and independence assumptions.
It is in general very difficult to justify these assumptions, especially the exclusion restriction assumption. 
In the examples above, one could argue that schools or colleges might be built where they are necessary, i.e. close to destitute populations, or, on the contrary, that they are built far from difficult neighbourhoods. 
As soon as distance to school becomes correlated with other determinants of schooling, such as parental income and education, the independence assumption is violated.

Even if school placement is truly independent of potential education and earnings outcomes at first, parents, by choosing where to live, will sort themselves such as the parents that pay more attention to education end up located closer to school.
As a consequence, the independence assumption might be violated again.

Even when the instrument is truly random, such as a draft lottery number, and thus the independence assumption seems fine, the instrument may directly affect the outcomes by other ways than the treatment of interest. 
For example, receiving a low draft lottery number makes one more likely to be drafted. 
In response, one might decide to increase their length of stay in college in order to use the waiver for the draft reserved for students.
If receiving a low draft lottery number increases the number of years of education, and in turn subsequent earnings, then the exclusion restriction assumption is violated.
```

In this section, I'm going to denote $Z_i$ a binary instrument that can either take value $0$ or $1$.
In general, we try to reserve the value $1$ for the instrument value that increases participation in the treatment of interest.
In our examples, that would be when for example, the distance to college is low, the draft lottery number is low, or someone receives an encouragement to enter a program.

### An example where Monotonicity does not hold

Since Monotonicity is going to play such a particular role, and since we have already explored this assumption a little in Chapter \@ref(RCT), I am going to use as an example a model where the Monotonicity assumption actually does not hold. 
It will, I hope, help us understand better the way Monotonicity works and how it interacts with the other assumptions.
The key component of the model that makes Monotonicity necessary is the fact that treatment effects are heterogeneous and correlated with participation in the treatment.
We'll see later that Monotonicity is unnecessary when treatment effects are orthogonal to take up.

```{example}
Let's see how we can generate a model without Monotonicity:
```

\begin{align*}
y_i^1 & = y_i^0+\bar{\alpha}+\theta\mu_i+\eta_i \\
y_i^0 & = \mu_i+\delta+U_i^0 \\
U_i^0 & = \rho U_i^B+\epsilon_i \\
y_i^B & =\mu_i+U_i^B \\
U_i^B & \sim\mathcal{N}(0,\sigma^2_{U}) \\
D_i   & = \uns{y_i^B+\kappa_i Z_i + V_i\leq\bar{y}} \\
\kappa_i & = 
\begin{cases}
-\bar{\kappa} & \text{ if } \xi_i = 1 \\
\underline{\kappa} & \text{ if } \xi_i = 0
\end{cases} \\
\xi & \sim\mathcal{B}(p_{\xi}) \\
V_i   & = \gamma(\mu_i-\bar{\mu}) + \omega_i \\
(\eta_i,\omega_i) & \sim\mathcal{N}(0,0,\sigma^2_{\eta},\sigma^2_{\omega},\rho_{\eta,\omega}) \\
Z_i   & \sim\mathcal{B}(p_Z) \\
Z_i   & \Ind (y_i^0,y_i^1,y_i^B,V_i) \\
\xi_i & \Ind (y_i^0,y_i^1,y_i^B,V_i,Z_i)
\end{align*}

The key component of the model that generates a failure of Monotonicity is the coefficient $\kappa_i$, that determines how individuals' participation into the program reacts to the instrument $Z_i$.
$\kappa_i$ is a coefficient whose value varies accross the population.
In my simplified model, $\kappa_i$ can take only two values, $-\bar{\kappa}$ or $\underline{\kappa}$.
When $-\bar{\kappa}$ and $\underline{\kappa}$ have opposite signs (let's say $-\bar{\kappa}<0$ and $\underline{\kappa}>0$), then individuals with $\kappa_i=-\bar{\kappa}$ are going to be more likely to enter the program when they receive an encouragement (when $Z_i=1$) while individuals with $\kappa_i=\underline{\kappa}$ will be less likely to enter the program when $Z_i=1$.
When $-\bar{\kappa}$ and $\underline{\kappa}$ have different signs, we have four types of reactions when the instrumental variable moves from $Z_i=0$ to $Z_i=1$, holding everything else constant.
These four types of reactions define four types of individuals:

  * **Always takers** ($T_i=a$): individuals that participate in the program both when $Z_i=0$ and $Z_i=1$.
  * **Never takers** ($T_i=n$): individuals that do not participate in the program both when $Z_i=0$ and $Z_i=1$.
  * **Compliers** ($T_i=c$): individuals that do not participate in the program when $Z_i=0$ but that participate in the program when $Z_i=1$ .
  * **Defiers** ($T_i=d$): individuals that participate in the program when $Z_i=0$ but that do not participate in the program when $Z_i=1$ .
  
In our model, these four types are a function of $y_i^B+V_i$ and $\kappa_i$.
In order to see this let's define, as in Section \@ref(sec:design4), $D^z_i$ the participation decision of individual $i$ when the instrument is exogenously set to $Z_i=z$, with $z\in\left\{0,1\right\}$.
When $\kappa_i=-\bar{\kappa}<0$, we have three types of reactions to the instrument.
It turns out that each of type can be defined by where $y_i^B+V_i$ lies with respect to a series of thresholds:

  * **Always takers** ($T_i=a$) are such that $D^1_i=\uns{y_i^B-\bar{\kappa} + V_i\leq\bar{y}}=1$ and $D^0_i=\uns{y_i^B + V_i\leq\bar{y}}=1$, so that they actually are such that: $y_i^B+V_i\leq\bar{y}$.
  This is because $y_i^B+V_i\leq\bar{y} \Rightarrow y_i^B+V_i\leq\bar{y}+\bar{\kappa}$, when $\bar{\kappa}>0$.
  * **Never takers** ($T_i=n$) are such that $D^1_i=\uns{y_i^B-\bar{\kappa} + V_i\leq\bar{y}}=0$ and $D^0_i=\uns{y_i^B + V_i\leq\bar{y}}=0$, so that they actually are such that: $y_i^B+V_i>\bar{y}+\bar{\kappa}$.
  This is because $y_i^B+V_i>\bar{y}+\bar{\kappa} \Rightarrow y_i^B+V_i>\bar{y}$, when $\bar{\kappa}>0$.
  * **Compliers** ($T_i=c$) are such that $D^1_i=\uns{y_i^B-\bar{\kappa} + V_i\leq\bar{y}}=1$ and $D^0_i=\uns{y_i^B + V_i\leq\bar{y}}=0$, so that they actually are such that: $\bar{y}<y_i^B+V_i\leq\bar{y}+\bar{\kappa}$.
  
When $\kappa_i=\underline{\kappa}>0$, we have three types defined by where $V_i$ lies with respect to a series of thresholds:

  * **Always takers** ($T_i=a$) are such that $D^1_i=\uns{y_i^B+\underline{\kappa} + V_i\leq\bar{y}}=1$ and $D^0_i=\uns{y_i^B + V_i\leq\bar{y}}=1$, so that they actually are such that: $y_i^B+V_i\leq\bar{y}-\underline{\kappa}$.
  This is because $y_i^B+V_i\leq\bar{y}-\underline{\kappa} \Rightarrow y_i^B+V_i\leq\bar{y}$, when $\underline{\kappa}>0$.
  * **Never takers** ($T_i=n$) are such that $D^1_i=\uns{y_i^B-\bar{\kappa} + V_i\leq\bar{y}}=0$ and $D^0_i=\uns{y_i^B + V_i\leq\bar{y}}=0$, so that they actually are such that: $y_i^B+V_i>\bar{y}$.
  This is because $y_i^B+V_i>\bar{y} \Rightarrow y_i^B+V_i\leq\bar{y}-\underline{\kappa}$, when $\underline{\kappa}>0$.
  * **Defiers** ($T_i=d$) are such that $D^1_i=\uns{y_i^B+\underline{\kappa} + V_i\leq\bar{y}}=0$ and $D^0_i=\uns{y_i^B + V_i\leq\bar{y}}=1$, so that they actually are such that: $\bar{y}-\underline{\kappa}<V_i+y_i^B\leq\bar{y}$.

Let's visualize how this works in a plot.
Before that, let's generate some data according to this process.
For that, let's choose values for the new parameters.

```{r param.IV,eval=TRUE,echo=TRUE,results='hide'}
param <- c(8,.5,.28,1500,0.9,0.01,0.05,0.05,0.05,0.1,0.1,7.98,0.5,1,0.5,0.9,0.28,0)
names(param) <- c("barmu","sigma2mu","sigma2U","barY","rho","theta","sigma2epsilon","sigma2eta","delta","baralpha","gamma","baryB","pZ","barkappa","underbarkappa","pxi","sigma2omega","rhoetaomega")
```

```{r simul.IV,eval=TRUE,echo=TRUE,results='hide'}
set.seed(1234)
N <-1000
cov.eta.omega <- matrix(c(param["sigma2eta"],param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),param["sigma2omega"]),ncol=2,nrow=2)
eta.omega <- as.data.frame(mvrnorm(N,c(0,0),cov.eta.omega))
colnames(eta.omega) <- c('eta','omega')
mu <- rnorm(N,param["barmu"],sqrt(param["sigma2mu"]))
UB <- rnorm(N,0,sqrt(param["sigma2U"]))
yB <- mu + UB 
YB <- exp(yB)
Ds <- rep(0,N)
Z <- rbinom(N,1,param["pZ"])
xi <- rbinom(N,1,param["pxi"]) 
kappa <- ifelse(xi==1,-param["barkappa"],param["underbarkappa"])
V <- param["gamma"]*(mu-param["barmu"])+eta.omega$omega
Ds[yB+kappa*Z+V<=log(param["barY"])] <- 1 
epsilon <- rnorm(N,0,sqrt(param["sigma2epsilon"]))
U0 <- param["rho"]*UB + epsilon
y0 <- mu +  U0 + param["delta"]
alpha <- param["baralpha"]+  param["theta"]*mu + eta.omega$eta
y1 <- y0+alpha
Y0 <- exp(y0)
Y1 <- exp(y1)
y <- y1*Ds+y0*(1-Ds)
Y <- Y1*Ds+Y0*(1-Ds)
```

We can now define the types variable $T_i$:

```{r types.illustration,eval=TRUE,echo=TRUE,results='hide'}
D1 <- ifelse(yB+kappa+V<=log(param["barY"]),1,0)
D0 <- ifelse(yB+V<=log(param["barY"]),1,0)
AT <- ifelse(D1==1 & D0==1,1,0)
NT <- ifelse(D1==0 & D0==0,1,0)
C <- ifelse(D1==1 & D0==0,1,0)
D <- ifelse(D1==0 & D0==1,1,0)
Type <- ifelse(AT==1,'a',
            ifelse(NT==1,'n',
                   ifelse(C==1,'c',
                          ifelse(D==1,'d',""))))

data.non.mono <- data.frame(cbind(Type,C,NT,AT,D1,D0,Y,y,Y1,Y0,y0,y1,yB,alpha,U0,eta.omega$eta,epsilon,Ds,kappa,xi,Z,mu,UB))
```

```{r plottypes,eval=TRUE,echo=TRUE,fig.cap='Types',fig.subcap=c('$\\kappa=\\bar{\\kappa}$','$\\kappa=\\underline{\\kappa}$'),fig.align='center',out.width='50%',fig.pos='htbp'}
#ggplot(data.non.mono, aes(x=V, y=yB),color(as.factor(Type))) +
#    geom_point(shape=1)+
#    facet_grid(.~ as.factor(kappa))

plot(yB[AT==1 & kappa==-param["barkappa"]]+V[AT==1 & kappa==-param["barkappa"]],y[AT==1 & kappa==-param["barkappa"]],pch=1,xlim=c(5,11),ylim=c(5,11),xlab='yB+V',ylab="Outcomes")
points(yB[NT==1 & kappa==-param["barkappa"]]+V[NT==1 & kappa==-param["barkappa"]],y[NT==1 & kappa==-param["barkappa"]],pch=1,col='blue')
points(yB[C==1 & kappa==-param["barkappa"]]+V[C==1 & kappa==-param["barkappa"]],y[C==1 & kappa==-param["barkappa"]],pch=1,col='red')
points(yB[D==1 & kappa==-param["barkappa"]]+V[D==1 & kappa==-param["barkappa"]],y[D==1 & kappa==-param["barkappa"]],pch=1,col='green')
abline(v=log(param["barY"]),col='red')
abline(v=log(param["barY"])+param['barkappa'],col='red')
#abline(v=log(param["barY"])-param['underbarkappa'],col='red')
text(x=c(log(param["barY"]),log(param["barY"])+param['barkappa']),y=c(5,5),labels=c(expression(bar('y')),expression(bar('y')+bar(kappa))),pos=c(2,4),col=c('red','red'),lty=c('solid','solid'))
legend(5,10.5,c('AT','NT','C','D'),pch=c(1,1,1,1),col=c('black','blue','red','green'),ncol=1)
title(expression(kappa=bar(kappa)))

plot(yB[AT==1 & kappa==param["underbarkappa"]]+V[AT==1 & kappa==param["underbarkappa"]],y[AT==1 & kappa==param["underbarkappa"]],pch=1,xlim=c(5,11),ylim=c(5,11),xlab='yB+V',ylab="Outcomes")
points(yB[NT==1 & kappa==param["underbarkappa"]]+V[NT==1 & kappa==param["underbarkappa"]],y[NT==1 & kappa==param["underbarkappa"]],pch=1,col='blue')
points(yB[C==1 & kappa==param["underbarkappa"]]+V[C==1 & kappa==param["underbarkappa"]],y[C==1 & kappa==param["underbarkappa"]],pch=1,col='red')
points(yB[D==1 & kappa==param["underbarkappa"]]+V[D==1 & kappa==param["underbarkappa"]],y[D==1 & kappa==param["underbarkappa"]],pch=1,col='green')
abline(v=log(param["barY"]),col='red')
#abline(v=log(param["barY"])-param['barkappa'],col='red')
abline(v=log(param["barY"])-param['underbarkappa'],col='red')
text(x=c(log(param["barY"]),log(param["barY"])-param['underbarkappa']),y=c(5,5),labels=c(expression(bar('y')),expression(bar('y')-underbar(kappa))),pos=c(2,2),col=c('red','red'),lty=c('solid','solid'))
legend(5,10.5,c('AT','NT','C','D'),pch=c(1,1,1,1),col=c('black','blue','red','green'),ncol=1)
title(expression(kappa=underbar(kappa)))

```

As Figure \@ref(fig:plottypes) shows how the different types interact with $\kappa_i$.
When $\kappa_i=-\bar{\kappa}$, individuals with $y_i^B+V_i$ below $\bar{y}$ always take the program.
Even when $Z_i=1$ and $\bar{\kappa}$ is subtracted from their index, it is still low enough so that they get to participate.
When $y_i^B+V_i$ is in between $\bar{y}$ and $\bar{y}+\bar{\kappa}$, the individuals are such that their index without subtracting $\bar{\kappa}$ is above $\bar{y}$, but it is below $\bar{y}$ when $\bar{\kappa}$ is subtracted from it.
These individuals participate when $Z_i=1$ and do not participate when $Z_i=0$: they are compliers.
Individuals such that $y_i^B+V_i$ is above $\bar{y}+\bar{\kappa}$ will have an index above $\bar{y}$ whether we substract $\bar{\kappa}$ from it or not.
They are never takers.

When $\kappa_i=\underline{\kappa}$, individuals with $y_i^B+V_i$ below $\bar{y}-\underline{\kappa}$ always take the program.
Even when $Z_i=0$ and $\underline{\kappa}$ is not subtracted from their index, it is still low enough so that they get to participate.
When $y_i^B+V_i$ is in between $\bar{y}-\underline{\kappa}$ and $\bar{y}$, the individuals are such that their index without adding $\underline{\kappa}$ is below $\bar{y}$, but it is above $\bar{y}$ when $\underline{\kappa}$ is added to it.
These individuals participate when $Z_i=0$ and do not participate when $Z_i=1$: they are defiers.
Individuals such that $y_i^B+V_i$ is above $\bar{y}$ will have an index above $\bar{y}$ whether we add $\underline{\kappa}$ from it or not.
They are never takers.

### Identification 

We need several assumptions for identification in an Instrumental Variable framework.
We are going to explore two sets of assumption that secure the identification of two different parameters: 

  * The Average Treatment Effect on the Treated ($TT$): identification will happen through the assumption of independence of treatment effects from potential treatment choice
  * The Local Average Treatment Effect ($LATE$)

```{hypothesis,FirstStage,name='First Stage Full Rank'}
We assume that the instrument $Z_i$ has a direct effect on treatment participation:

\begin{align*}
\Pr(D_i=1|Z_i=1)\neq\Pr(D_i=1|Z_i=0).
\end{align*}
```

```{example}
Let's see how this assumption works in our example.
Let's first compute the average values of $Y_i$ and $D_i$ as a function of $Z_i$, for later use.
```

```{r graph.illus.IV,eval=TRUE,echo=TRUE,results='markup'}
means.IV <- c(mean(Ds[Z==0]),mean(Ds[Z==1]),mean(y0[Z==0]),mean(y0[Z==1]),mean(y[Z==0]),mean(y[Z==1]),0,1)
means.IV <- matrix(means.IV,nrow=2,ncol=4,byrow=FALSE,dimnames=list(c('Z=0','Z=1'),c('D','y0','y','Z')))
means.IV <- as.data.frame(means.IV)
```

```{r IVFirstStage,eval=TRUE,echo=FALSE,results='hide',echo=FALSE,warning=FALSE,error=FALSE,message=FALSE,fig.cap='Proportion of participants as a function of $Z_i$',fig.align='center',out.width=cst,fig.pos='htbp'}
ggplot(means.IV, aes(x=as.factor(Z), y=D)) +
  geom_bar(position=position_dodge(), stat="identity", colour='black')+
  xlab('Z')+
  ylab('Pr(D=1|Z)')
```

Figure \@ref(fig:IVFirstStage) shows that the proportion of treated when $Z_i=1$ in our sample is equal to `r round(mean(Ds[Z==1]),2)` while the proportion of treated when $Z_i=0$ is equal to  `r round(mean(Ds[Z==0]),2)`, in accordance with Assumption \@ref(hyp:FirstStage).
In the population, the proportion of treated when $Z_i=1$ depends on the value of $\kappa_i$. 
Let's derive its value:

\begin{align*}
  \Pr(D_i=1|Z_i=1) & = \Pr(y_i^B+\kappa_i Z_i + V_i\leq\bar{y}|Z_i=1) \\
                  & =  \Pr(y_i^B+\kappa_i + V_i\leq\bar{y}) \\
                  & =  \Pr(y_i^B+ V_i\leq\bar{y}+\bar{\kappa}|\xi_i=1)\Pr(\xi_i=1) + \Pr(y_i^B+V_i\leq\bar{y}-\underline{\kappa}|\xi_i=0)\Pr(\xi_i=0) \\
                                    & =  \Pr(y_i^B+ V_i\leq\bar{y}+\bar{\kappa})p_{\xi} + \Pr(y_i^B+ V_i\leq\bar{y}-\underline{\kappa})(1-p_{\xi}) \\
                  & =  p_{\xi}\Phi\left(\frac{\bar{y}+\bar{\kappa}-\bar{\mu}}{\sqrt{(1+\gamma^2)\sigma^2_{\mu}+\sigma^2_{U}+\sigma^2_{\omega}}}\right) + (1-p_{\xi})\Phi\left(\frac{\bar{y}-\underline{\kappa}-\bar{\mu}}{\sqrt{(1+\gamma^2)\sigma^2_{\mu}+\sigma^2_{U}+\sigma^2_{\omega}}}\right)
\end{align*}

where the second equality follows from $Z_i$ being independent of $(y_i^0,y_i^1,y_i^B,V_i)$, the third equality follows from $\xi_i$ being independent from  $(y_i^0,y_i^1,y_i^B,V_i,Z_i)$ and the last equality follows from the formula for the cumulative of a normal distribution. 
The formula for $\Pr(D_i=1|Z_i=0)$ is the same except for $\bar{\kappa}$ and $\underline{\kappa}$ that are set to zero.

Let's write two functions to compute these probabilities:

```{r prob.IV,eval=TRUE,echo=TRUE,results='hide'}
prob.D.Z.1 <- function(param){
  part.1 <- param['pxi']*pnorm((log(param["barY"])+param['barkappa']-param['barmu'])/sqrt((1+param['gamma']^2)*param['sigma2mu']+param["sigma2U"]+param['sigma2omega']))
  part.2 <- (1-param['pxi'])*pnorm((log(param["barY"])-param['underbarkappa']-param['barmu'])/sqrt((1+param['gamma']^2)*param['sigma2mu']+param["sigma2U"]+param['sigma2omega']))
  return(part.1+part.2)
}
prob.D.Z.0 <- function(param){
  part.1 <- param['pxi']*pnorm((log(param["barY"])-param['barmu'])/sqrt((1+param['gamma']^2)*param['sigma2mu']+param["sigma2U"]+param['sigma2omega']))
  part.2 <- (1-param['pxi'])*pnorm((log(param["barY"])-param['barmu'])/sqrt((1+param['gamma']^2)*param['sigma2mu']+param["sigma2U"]+param['sigma2omega']))
  return(part.1+part.2)
}
```

With these functions, we know that, in the population, $\Pr(D_i=1|Z_i=1)=$ `r round(prob.D.Z.1(param),2)` and $\Pr(D_i=1|Z_i=0)=$ `r round(prob.D.Z.0(param),2)`, which is not far from what we have found in our sample.

Our next set of assumptions imposes that the instrument has no direct effect on the outcome and that it is not correlated with all the potential outcomes.
Let's start with the exclusion restriction:

```{hypothesis,ExclusionRestriction,name='Exclusion Restriction'}
We assume that there is no direct effect of $Z_i$ on outcomes:

\begin{align*}
\forall d,z \in \left\{0,1\right\}\text{, } Y_i^{d,z} = Y_i^d.
\end{align*}
```

```{example}
In our example, this assumption is automatically satisfied.
```
Indeed, $y_i^{d,z}=y_i^0 + d(y_i^1-y_i^0)$ which is parameterized as $y_i^{d,z}=\mu_i+\delta+U_i^0+d(\bar{\alpha}+\theta\mu_i+\eta_i)$.
Since $y_i^{d,z}$ does not depend on $z$, we have $y_i^{d,z} = y_i^d$, $\forall d,z \in \left\{0,1\right\}$.
The assumption would not be satisfied if $Z_i$ entered the equations for $y_i^0$ or $y_i^1$.
For example, if $Z_i$ is the Vietnam draft lottery number (high or low) used by Angrist to study the impact of army experience on earnings, the exclusion restriction would not work if $Z_i$ was directly influencing outcomes, independent of miitary experience, by example by generating a higher education level. 
In that case, we could have $E_i=\alpha+\beta Z_i + v_i$, where $E_i$ is education, and, for example, $y_i^0=\mu_i+\delta+\lambda E_i+U_i^0$.
We then have $y_i^{d,z}=\mu_i+\delta +\lambda(\alpha+\beta z + v_i) +U_i^0+d(\bar{\alpha}+\theta\mu_i+\eta_i)$ which depends on $z$ and thus the exclusion restriction does not hold any more. 

Let us now state the independence assumption:

```{hypothesis,Independence,name='Independence'}
We assume that $Z_i$ is independent from the other determinants of $Y_i$ and $D_i$:

\begin{align*}
(Y_i^1,Y_i^0,D_i^1,D_i^0)\Ind Z_i.
\end{align*}
```

```{remark}
Why do we say that independence from the potential outcomes is the same as independence from the other determinants of $Y_i$ and $D_i$?
Because the only sources of variation that remain in $Y_i^d$ and $D_i^z$ are the other sources of variations (that is not the treatment $D_i=d$ nor the instrument variable $Z_i=z$).
```

```{example}
In our example, this assumption is also satisfied.
```
If we assumed that unobserved determinants of earnings contained in $U^0_i$ are correlated with the instrument value, then we would have a problem.
For example, if children that leave close to college have also rich parents, or parents that spend a lot of time with them, or parents with large networks, there probably is a correlation between distance to college and earnings in the absence of the program.
For the draft lottery example, you might have that people with a high draft lottery number who have well-connected parents obtain discharges on special medical grounds. 
Is that a violation of the independence assumption?
Actually no.
Indeed, these individuals are simply going to become never takers (they avoid the draft whatever their lottery number).
But $Z_i$ is still independent from the level of connections of the parents.
For the independence assumption to fail in the draft lottery number example, you would need that children of well-connected parents obtain lower lottery numbers because the lottery is rigged.
In that case, since well-connected individuals would have had higher earnings even absent the lottery, there is a negative correlation between $y_i^0$ and having a high draft lottery number ($Z_i$).  

The last assumption we need in order to identify the Local Average Treatment Effect is that of Monotonicity.
We already know this assumption:

```{hypothesis,MonotonicityIV,name='Monotonicity'}
We assume that the instrument moves everyone in the population in the same direction:

\begin{align*}
\forall i\text{, either } D^1_i\geq D_i^0 \text{ or } D^1_i\leq D_i^0.
\end{align*}
```

Without loss of generality, we generally assume that $\forall i$, $D^1_i\geq D_i^0$.
As a consequence, there are no defiers.

```{example}
In our example, this assumption is not satisfied.
```
There are defiers, as Figure \@ref(fig:plottypes) shows, when $\xi_i = 0$ and thus $\kappa_i=\underline{\kappa}$. 
Indeed, in that case, for the individuals who are such that $\bar{y}-\underline{\kappa}<y_i^B+V_i\leq\bar{y}$, we have $D^1_i=\uns{y_i^B+\underline{\kappa} + V_i\leq\bar{y}}=0$ and $D^0_i=\uns{y_i^B + V_i\leq\bar{y}}=1$.
This would happen for example if some people would go to college less if their house is located closer to the college, maybe for example because they have a preference not to stay at their parents' house. 

```{remark}
Why are defiers a problem for the instrumental variable strategy?
Because the Intention to Treat Effect that measures the difference in expected outcomes at the two levels of the instrument is going to be characterized by two-way flows in and out of the program, as we have already seen with Theorem \@ref(thm:ITELATE).
This means that some treatment effects will have negative weights in the ITE formula. 
In that case, you might have a negative Intention to Treat Effect despite the treatment having positive effects for everyone, or you might under estimate the true effect of the treatment.
This matters only when the treatment effects are heterogeneous. 
```

```{example}
Let us detail how non-monotonicity and the existence defiers act on the ITE in our example, since we now have defiers.
The first very important thing to understand is that all the problems we have happend because treatment effects are heterogeneous **AND** they are correlated with the type of individuals: defiers and compliers do not have the same distribution of treatment effects and, case in point, they do not have the same average treatment effects. 
The average effects of the treatment on compliers and defiers are not the same. 
Let us first look at the distribution of treatment effects among compliers and defiers in the sample and in the population.
```

In order to derive the distribution of $\alpha_i$ conditional on Type in the population, we need to derive the joint distribution of $\alpha_i$ and $y_i^B+V_i$ and use the **trmtvnorm** package to recover its density when it is truncated.
This distribution is normal and fully characterized by its mean and covariance matrix.

\begin{align*}
  (\alpha_i,y_i^B+V_i) & \sim \mathcal{N}\left(\bar{\alpha}+\theta\bar{\mu},\bar{\mu},
                                        \left(\begin{array}{cc}
                                              \theta^2\sigma^2_{\mu}+\sigma^2_{\eta} & (\theta+\gamma)\sigma^2_{\mu}+\rho_{\eta,\omega}\sigma^2_{\eta}\sigma^2_{\omega}\\
                                              (\theta+\gamma)\sigma^2_{\mu}+\rho_{\eta,\omega}\sigma^2_{\eta}\sigma^2_{\omega} &  (1+\gamma^2)\sigma^2_{\mu}+\sigma^2_U+\sigma^2_{\omega}\\
                                              \end{array}
                                        \right)
                                      \right)
\end{align*}

Let us write a function to generate them.

```{r AlphaTypesPopulation,eval=TRUE,echo=TRUE,results='hide'}
mean.alpha.yBV <- c(param['baralpha']+param['theta']*param['barmu'],param['barmu'])
cov.alpha.yBV <- matrix(c((param['theta']^2)*param['sigma2mu']+param['sigma2eta'],
                          (param['theta']+param['gamma'])*param['sigma2mu']+param['rhoetaomega']*param['sigma2eta']*param['sigma2omega'],
                            (param['theta']+param['gamma'])*param['sigma2mu']+param['rhoetaomega']*param['sigma2eta']*param['sigma2omega'],
                            (1+param['gamma']^2)*param['sigma2mu']+param['sigma2U']+param['sigma2omega']),2,2,byrow=TRUE)
# density of alpha for compliers
lower.cut.comp <- c(-Inf,log(param['barY']))
upper.cut.comp <- c(Inf,log(param['barY'])+param['barkappa'])
d.alpha.compliers <- function(x){
  return(dtmvnorm.marginal(xn=x,n=1,mean=mean.alpha.yBV,sigma=cov.alpha.yBV,lower=lower.cut.comp,upper=upper.cut.comp))
}
# density of alpha for defiers
lower.cut.def <- c(-Inf,log(param['barY']-param['underbarkappa']))
upper.cut.def <- c(Inf,log(param['barY']))
d.alpha.defiers <- function(x){
  return(dtmvnorm.marginal(xn=x,n=1,mean=mean.alpha.yBV,sigma=cov.alpha.yBV,lower=lower.cut.def,upper=upper.cut.def))
}
```

Let us now plot the empirical and theoretical distributions of the treatment effects for compliers and defiers.

```{r AlphaTypesPlot,eval=TRUE,echo=TRUE,fig.cap='Distribution of treatment effects by Type in the sample (dashed line) and in the population (full line)',fig.align='center',out.width='50%',fig.pos='htbp'}
# building the data frame
alpha.types <- as.data.frame(cbind(alpha,C,D,AT,NT)) %>%
                mutate(
                  Type = ifelse(AT==1,"Always Takers",
                                ifelse(NT==1,"Never Takers",
                                       ifelse(C==1,"Compliers","Defiers")))
                ) %>%
                mutate(Type = as.factor(Type))

ggplot(filter(alpha.types,Type=="Compliers" | Type=="Defiers"), aes(x=alpha, colour=Type)) + 
  geom_density(linetype="dashed") +
  geom_function(fun = d.alpha.compliers, colour = "red") +
  geom_function(fun = d.alpha.defiers, colour = "blue") +
  ylab('density') +
  theme_bw()
```

Figure \@ref(fig:AlphaTypesPlot) shows that the two distributions are actually very similar in our example. 
The distribution for the compliers is slightly above that for the defiers, meaning that the defiers should have lower expected outcomes in the population.
Let us check that by computing the average outcomes of compliers and defiers both in the sample and in the population.

```{r AlphaTypesMean,eval=TRUE,echo=TRUE,results='hide'}
# sample means
mean.alpha.compliers.samp <- mean(alpha[C==1]) 
mean.alpha.defiers.samp <- mean(alpha[D==1]) 

# population means
mean.alpha.compliers.pop <- mtmvnorm(mean=mean.alpha.yBV,sigma=cov.alpha.yBV,lower=lower.cut.comp,upper=upper.cut.comp,doComputeVariance=FALSE)[[1]]
mean.alpha.defiers.pop <-  mtmvnorm(mean=mean.alpha.yBV,sigma=cov.alpha.yBV,lower=lower.cut.def,upper=upper.cut.def,doComputeVariance=FALSE)[[1]]
```

In the population, the average treatment effect for compliers is equal to `r round(mean.alpha.compliers.pop[[1]],2)` and the average treatment effect for defiers is equal to `r round(mean.alpha.defiers.pop[[1]],2)`.
In the sample, the average treatment effect for compliers is equal to `r round(mean.alpha.compliers.samp[[1]],2)` and the average treatment effect for defiers is equal to `r round(mean.alpha.defiers.samp[[1]],2)`.

The difference between the treatment effect for compliers and defiers is a problem for the Wald estimator.
Let's look at how the Wald estimator behaves in the population (in order to avoid considerations due to sampling noise).
By Theorem \@ref(thm:ITELATE), the numerator of the Wald estimator is equal to the difference between the average treatment on compliers and the average treatment effect on defiers weighted by their respective proportions in the population. 
In order to be able to compute the Wald estimator, we need to compute the proportion of compliers and of defiers in the population. 
These proportions are equal to:

\begin{align*}
  \Pr(T_i=c) & = \Pr(\bar{y}< y_i^B+V_i\leq\bar{y}+\bar{\kappa}\cap\kappa_i=-\bar{\kappa}) \\
              & = \Pr(\bar{y}< y_i^B+V_i\leq\bar{y}+\bar{\kappa})p_{\xi} \\
  \Pr(T_i=d) & = \Pr(\bar{y}-\underline{\kappa}< y_i^B+V_i\leq\bar{y}\cap\kappa_i=\underline{\kappa}) \\
              & = \Pr(\bar{y}-\underline{\kappa}< y_i^B+V_i\leq\bar{y})(1-p_{\xi}),
\end{align*}

where the second equality follows from the fact that $\xi$ is independent from $y_i^B+V_i$ and uses the fact that $\Pr(A\cap B)=\Pr(A|B)\Pr(B)$.
Since $y_i^B+V_i$ is normally distributed and we know its mean and variance, these proportions can be computed as: 

\begin{align*}
  \Pr(T_i=c) & = p_{\xi}\left(\Phi\left(\frac{\bar{y}+\bar{\kappa}-\bar{\mu}}{\sqrt{(1+\gamma^2)\sigma^2_{\mu}+\sigma^2_U+\sigma^2_{\omega}}}\right)
                  -\Phi\left(\frac{\bar{y}-\bar{\mu}}{\sqrt{(1+\gamma^2)\sigma^2_{\mu}+\sigma^2_U+\sigma^2_{\omega}}}\right)\right) \\
  \Pr(T_i=d) & = (1-p_{\xi})\left(\Phi\left(\frac{\bar{y}-\bar{\mu}}{\sqrt{(1+\gamma^2)\sigma^2_{\mu}+\sigma^2_U+\sigma^2_{\omega}}}\right)
                  -\Phi\left(\frac{\bar{y}-\underline{\kappa}-\bar{\mu}}{\sqrt{(1+\gamma^2)\sigma^2_{\mu}+\sigma^2_U+\sigma^2_{\omega}}}\right)\right).
\end{align*}

Let's write functions to compute these objects:

```{r PropCompDef,eval=TRUE,echo=TRUE,results='hide'}
# proportion compliers
Prop.Comp <- function(param){
  first <- pnorm((log(param['barY'])+param['barkappa']-param['barmu'])/(sqrt((1+param['gamma']^2)*param['sigma2mu']+param['sigma2U']+param['sigma2omega'])))
  second <- pnorm((log(param['barY'])-param['barmu'])/(sqrt((1+param['gamma']^2)*param['sigma2mu']+param['sigma2U']+param['sigma2omega'])))
  return(param['pxi']*(first - second))  
}

# proportion defiers
Prop.Def <- function(param){
  first <- pnorm((log(param['barY'])-param['barmu'])/(sqrt((1+param['gamma']^2)*param['sigma2mu']+param['sigma2U']+param['sigma2omega'])))
  second <- pnorm((log(param['barY'])-param['underbarkappa']-param['barmu'])/(sqrt((1+param['gamma']^2)*param['sigma2mu']+param['sigma2U']+param['sigma2omega'])))
  return((1-param['pxi'])*(first - second))  
}

```

In our example, the proportion of compliers is equal to `r round(Prop.Comp(param),2)` and the proportion of defiers is equal to `r round(Prop.Def(param),2)`.
As a consequence, the population value of the numerator of the Wald estimator is equal to `r round(mean.alpha.compliers.pop[[1]]*Prop.Comp(param) - mean.alpha.defiers.pop[[1]]*Prop.Def(param),2)`.
In the Wald estimator, this quantity is divided by the difference between the proportion of participants when $Z_i=1$ and when $Z_i=0$. 
We have already computed this quantity earlier, but it is nice to try to compute it in a different way using the types.
The difference in the proportion of participants when $Z_i=1$ and when $Z_i=0$ is indeed equal to the difference in the proportion of compliers and the proportion of defiers. 
The difference between the proportion of compliers and the proportion of defiers is equal to `r round(Prop.Comp(param)-Prop.Def(param),2)`, while the difference between the proportion of participants when $Z_i=1$ and when $Z_i=0$ is equal to `r round(prob.D.Z.1(param)-prob.D.Z.0(param),2)`.
It is reassuring that we find the same thing (actually, full disclosure, I did not find the same thing at first, and this help me spot a mistake in the formulas for the proportions of participants: mistakes are normal and natural and that is how we learn and grow).

So we are now equipped to compute the value of the Wald estimator in the population in our model without monotonicity.
It is equal to `r round((mean.alpha.compliers.pop[[1]]*Prop.Comp(param) - mean.alpha.defiers.pop[[1]]*Prop.Def(param))/(prob.D.Z.1(param)-prob.D.Z.0(param)),3)`.
In practice, the bias of the Wald estimator is rather small for the average treatment effect on the compliers (remember that it is equal to `r round(mean.alpha.compliers.pop[[1]],3)`). 
In order to understand why, it is useful to see that the bias of the Wald estimator for the average treatment effect on the compliers is equal to:

\begin{align*}
  \esp{\Delta_i^Y|T_i=c}-\Delta^Y_{Wald} & = \esp{\Delta_i^Y|T_i=c} + (\esp{\Delta_i^Y|T_i=c}-\esp{\Delta_i^Y|T_i=d})\frac{\Pr(T_i=d)}{\Pr(T_i=c)-\Pr(T_i=d)},
\end{align*}

where the equality follows from Theorem \@ref(thm:ITELATE) and some algebra.
In the absence of Monotonicity, when the impact on defiers is smaller than the impact of compliers, the Wald estimator is baised upward for the effect on the compliers (as it happens in our example).
In a model in which the effect of the treatment is larger on defiers than on compliers, the Wald estimator is biased downwards for the effect on compliers because defiers make the outcome of the control group seem too good.
In the extreme, when $\esp{\Delta_i^Y|T_i=d}>\esp{\Delta_i^Y|T_i=c}(1+\frac{\Pr(T_i=c)-\Pr(T_i=d)}{\Pr(T_i=d)})$, the Wald estimator can be negative whereas the effects on compliers and on defiers are both positive.
This happens when the effect on defiers is $1+\frac{\Pr(T_i=c)-\Pr(T_i=d)}{\Pr(T_i=d)}$ times larger than the effect on compliers. 
In our case, that means that the effect on defiers should be `r round(1+(Prop.Comp(param)-Prop.Def(param))/Prop.Def(param),0)` times larger than the effect on compliers for the Wald estimator to be negative, that is to say the effect on defiers should be equal to `r round((1+(Prop.Comp(param)-Prop.Def(param))/Prop.Def(param))*mean.alpha.compliers.pop[[1]],2)`, really much much much larger than the effect on compliers.

From there, we are going to explore three strategies in order to identify some true effect of the treatment using the Wald estimator:

  * The first strategy has been recently proposed by [de Chaisemartin (2017)](https://drive.google.com/file/d/16XWlDECIvreM7l_NHe-JkXgyuPhFT1QG/view). 
  It is valid in a model without monotonicity.
  * The second strategy assumes that the heterogeneity in treatment effects is uncorrelated to the treatment.
  * The last strategy is due to Imbens and Angrist (1994) and assumes that Monotonicity holds.
  
Let's review these solutions in turn.

#### Identification without Monotonicity

The approach delineated by [de Chaisemartin (2017)](https://drive.google.com/file/d/16XWlDECIvreM7l_NHe-JkXgyuPhFT1QG/view) does not assume away non-monotonicity.
Clement instead assumes that we can divide the population of compliers in two-subpopulations: the **compliers-defiers** ($T_i=cd$) and the **surviving-compliers** ($T_i=sc$).
The main assumption in Clement's approach is that *(i)* the compliers-defiers are in the same proportion as the defiers and *(ii)* that the average effect of the treatment on the compliers defiers is equal as the average effect of the treatment on the defiers.
These two assumptions can be formalized as follows:

```{hypothesis,CD,name="Compliers-defiers"}
We assume that there exists as subpopulation of compliers that are in the same proportion as the defiers and for whom the average effect of the treatment is equal as the average effect of the treatment on the defiers: 
  
\begin{align*}
(T_i=c) & = (T_i=cd)\cup (T_i=sc) \\
\Pr(T_i=cd) & = \Pr(T_i=d) \\
\esp{Y^1_i-Y^0_i|T_i=cd} & = \esp{Y^1_i-Y^0_i|T_i=d}.
\end{align*}
```

The first equation in Assumption \@ref(hyp:CD) imposes that the compliers-defiers and the surviving-compliers are a partition of the population of compliers.
From Assumption \@ref(hyp:CD), we can prove the following theorem:

```{theorem,deChaise,name="Identification of the effect on the surviving-compliers"}
Under Assumptions \@ref(hyp:FirstStage), \@ref(hyp:ExclusionRestriction), \@ref(hyp:Independence) and \@ref(hyp:CD), the Wald estimator identifies the effect of the treatment on the surviving-compliers:
  
\begin{align*}
  \Delta^Y_{Wald} & = \Delta^Y_{sc},
\end{align*}
```

with:

\begin{align*}
  \Delta^Y_{Wald} & = \frac{\esp{Y_i|Z_i=1} - \esp{Y_i|Z_i=0}}{\Pr(D_i=1|Z_i=1)-\Pr(D_i=1|Z_i=0)}\\
  \Delta^Y_{sc} & = \esp{Y^1_i-Y^0_i|T_i=sc}.
\end{align*}

```{proof}
Under Assumptions \@ref(hyp:ExclusionRestriction) and \@ref(hyp:Independence), Theorems \@ref(thm:ITELATE) and \@ref(thm:ITEEncourag) imply that the numerator of the Wald estimator is equal to $\Delta^Y_{ITE}$ with:
  
\begin{align*}
  \Delta^Y_{ITE}  & = \esp{Y_i^{1}-Y_i^{0}|T_i=c}\Pr(T_i=c)-\esp{Y_i^{1}-Y_i^{0}|T_i=d}\Pr(T_i=d).
\end{align*}

Now, we have that the effect on compliers can be decomposed in the effect on surviving-compliers and the effect on compliers-defiers using the Law of Iterated Expectations and the fact that $T_i=sc \Rightarrow T_i=c$ and $T_i=cd \Rightarrow T_i=c$:
  
\begin{align*}
\Delta^Y_{c} & = \esp{Y_i^{1}-Y_i^{0}|T_i=sc}\Pr(T_i=sc|T_i=c)+\esp{Y_i^{1}-Y_i^{0}|T_i=cd}\Pr(T_i=cd|T_i=c),
\end{align*}

Now, using the fact that $\Pr(T_i=sc|T_i=c)\Pr(T_i=c)=\Pr(T_i=sc)$ and $\Pr(T_i=cd|T_i=c)\Pr(T_i=c)=\Pr(T_i=cd)$ (because $\Pr(A|B)\Pr(B)=\Pr(A\cap B)$ and $\Pr(A\cap B)=\Pr(A)$ if $A \Rightarrow B$), we have:
  
\begin{align*}
  \Delta^Y_{ITE} & = \esp{Y_i^{1}-Y_i^{0}|T_i=sc}\Pr(T_i=sc)\\
                & \phantom{=}+\esp{Y_i^{1}-Y_i^{0}|T_i=cd}\Pr(T_i=cd)-\esp{Y_i^{1}-Y_i^{0}|T_i=d}\Pr(T_i=d).
\end{align*}

The second part of the right-hand side of the above equation is equal to zero by virtue of Assumption \@ref(hyp:CD).
Now, under Assumptions \@ref(hyp:FirstStage), \@ref(hyp:ExclusionRestriction) and \@ref(hyp:Independence), we know, from the proof of Theorem \@ref(thm:IdentLATE), that $\Pr(D_i=1|Z_i=1)-\Pr(D_i=1|Z_i=0)=\Pr(T_i=c)-\Pr(T_i=d)$.
Under Assumption \@ref(hyp:CD), we have $\Pr(T_i=c)=\Pr((T_i=cd)\cup(T_i=sc))=\Pr(T_i=cd)+\Pr(T_i=sc)$.
Replacing $\Pr(T_i=c)$ gives $\Pr(D_i=1|Z_i=1)-\Pr(D_i=1|Z_i=0)=\Pr(T_i=sc)$.
Dividing $\Delta^Y_{ITE}$ by $\Pr(T_i=sc)$ gives the result.
```

```{remark}
[de Chaisemartin (2017)](https://drive.google.com/file/d/16XWlDECIvreM7l_NHe-JkXgyuPhFT1QG/view) shows in his Theorem 2.1 that the reciprocal of Theorem \@ref(thm:deChaise) is actually valid: if there exists surviving-compliers such that their effect is estimated by the Wald estimator and their proportion is equal to the denominator of the Wald estimator, then it has to be that there exists a sub-population of compliers-defiers that are in the same proportion as the defiers and have the same average treatment effect.
```
  
```{example}  
Let us now see if the conditions in [de Chaisemartin (2017)](https://drive.google.com/file/d/16XWlDECIvreM7l_NHe-JkXgyuPhFT1QG/view) are verified in our numerical example.
```
I have bad news: they are not. 
It is not super easy to see why, but an intuitive explanation is that the average effect on the defiers in our model is taken conditional on $y^B_i+V_i\in]\bar{y}-\underline{\kappa},\bar{y}]$ while the effect on compliers is taken conditional on $y^B_i+V_i\in]\bar{y},\bar{y}+\bar{\kappa}]$. 
These two intervals do not overlap. 
Since the expected value of the treatment effect conditional on $y^B_i+V_i=v$ is monotonous in $v$ (because both variables come from a bivariate normal distribution), then all the effects on the defiers interval are either smaller or larger than all the effects on the compliers interval, making it impossible to find a sub-population of compliers that have the same average effect of the treatment as the defiers.

More formally, it is possible to prove this result by using the concept of Marginal Treatment Effect developed by [Heckman and Vytlacil (1999)](https://www.pnas.org/content/pnas/96/8/4730.full.pdf). 
I might devote a specific section of the book to the MTE and its derivations. 
For now, I let it as a possibility.

What can we do then?
Probably the best that we can do is to find $\kappa^*$ such that $\Pr(\bar{y}<y_i^B+V\leq\bar{y}+\kappa^*)p_{\xi}=\Pr(T_i=d)$, that is the value such that the interval of values of $y_i^B+V$ that are for compliers and closest to the interval for defiers and that contains the same proportion of compliers as there are defiers.
This value is going to produce an average effect for compliers-defiers as close as possible to the average effect on defiers. 
It can be computed as follows:

\begin{align*}
  \kappa^* & = \bar{\mu}-\bar{y}+\sqrt{(1+\gamma^2)\sigma^2_{\mu}+\sigma^2_U+\sigma^2_{\omega}}
                                  \Phi^{-1}\Bigg(\Phi\left(\frac{\bar{y}-\bar{\mu}}{\sqrt{(1+\gamma^2)\sigma^2_{\mu}+\sigma^2_U+\sigma^2_{\omega}}}\right)\\
           & \phantom{=}+\frac{1-p_{\xi}}{p_{\xi}}\left(\Phi\left(\frac{\bar{y}-\bar{\mu}}{\sqrt{(1+\gamma^2)\sigma^2_{\mu}+\sigma^2_U+\sigma^2_{\omega}}}\right)-\Phi\left(\frac{\bar{y}-\underline{\kappa}-\bar{\mu}}{\sqrt{(1+\gamma^2)\sigma^2_{\mu}+\sigma^2_U+\sigma^2_{\omega}}}\right)\right)\Bigg)
 \end{align*}

Let's write functions to compute $\kappa^*$, the implied proportion of compliers-defiers and the average effect of the treatment on compliers-defiers and on surviving-compliers:

```{r KappaStar,eval=TRUE,echo=TRUE,results='hide'}
# kappa star
KappaStar <- function(param){
  prop.def <- Prop.Def(param)
  prop.below.bary <- pnorm((log(param['barY'])-param['barmu'])/(sqrt((1+param['gamma']^2)*param['sigma2mu']+param['sigma2U']+param['sigma2omega'])))
  st.dev.yB.V <- sqrt((1+param['gamma']^2)*param['sigma2mu']+param['sigma2U']+param['sigma2omega'])
  return(param['barmu']-log(param['barY'])+st.dev.yB.V*qnorm(prop.below.bary+prop.def/param['pxi']))
}

# proportion of compliers-defiers
Prop.Comp.Def <- function(param){
  first <- pnorm((log(param['barY'])+KappaStar(param)-param['barmu'])/(sqrt((1+param['gamma']^2)*param['sigma2mu']+param['sigma2U']+param['sigma2omega'])))
  second <- pnorm((log(param['barY'])-param['barmu'])/(sqrt((1+param['gamma']^2)*param['sigma2mu']+param['sigma2U']+param['sigma2omega'])))
  return(param['pxi']*(first - second))  
}

# mean impact on compliers-defiers
lower.cut.comp.def <- c(-Inf,log(param['barY']))
upper.cut.comp.def <- c(Inf,log(param['barY'])+KappaStar(param))
mean.alpha.comp.def.pop <- mtmvnorm(mean=mean.alpha.yBV,sigma=cov.alpha.yBV,lower=lower.cut.comp.def,upper=upper.cut.comp.def,doComputeVariance=FALSE)[[1]]

# mean impact on surviving compliers
lower.cut.surv.comp <- c(-Inf,log(param['barY'])+KappaStar(param))
upper.cut.surv.comp <- c(Inf,log(param['barY'])+param['barkappa'])

mean.alpha.surv.comp.pop <- mtmvnorm(mean=mean.alpha.yBV,sigma=cov.alpha.yBV,lower=lower.cut.surv.comp,upper=upper.cut.surv.comp,doComputeVariance=FALSE)[[1]]

```

The first have that $\kappa^*=$ `r round(KappaStar(param),4)`. 
For this value of $\kappa^*$, we have that $\Pr(T_i=cd)=$ `r round(Prop.Comp.Def(param),4)`.
As expected, this is very close to the proportion of compliers in the population: $\Pr(T_i=d)=$ `r round(Prop.Def(param),4)`.
Finally, the average treatment effect on the compliers-defiers is equal to: $\Delta^y_{cd}=$ `r round(mean.alpha.comp.def.pop[[1]],4)`.
As expected, but luckily enough, since it was absolutely not sure, it is very close to the to the average treatment effect on the defiers: $\Delta^y_{d}=$ `r round(mean.alpha.defiers.pop[[1]],4)`.
So, in our model, Assumption \@ref(hyp:CD) is almost satisfied, and so does Theorem \@ref(thm:deChaise).
As a consequence, the Wald estimator is very close to the effect on the surviving-compliers.
Indeed, the Wald estimator, in the population, is equal to $\Delta^y_{Wald}=$ `r round((mean.alpha.compliers.pop[[1]]*Prop.Comp(param) - mean.alpha.defiers.pop[[1]]*Prop.Def(param))/(prob.D.Z.1(param)-prob.D.Z.0(param)),6)`, while the average effect on surviving-compliers is equal to $\Delta^y_{sc}=$ `r round(mean.alpha.surv.comp.pop[[1]],6)`.

#### Identification under Independence of treatment effects

Another way to get around the issue of Non-Monotonicity is simply to assume away any meaningful role for treatment effect heterogeneity.
One approach to that would simply be to assume that treatment effects are constant across individuals.
I leave to the reader to prove that in that case, the Wald estimator would recover the treatment effect under only Independence and Exclusion Restriction.
We are going to use a slightly more general approach here by assuming that treatment effect heterogeneity is unrelated to the reaction to the instrument:

```{hypothesis,IndepTreatEffect,name="Independent Treatment Effects"}
We assume that the treatment effect is independent from potential reactions to the instrument:

\begin{align*}
\Delta^Y_i\Ind (D^1_i,D^0_i).
\end{align*}
```

We can now prove that, under Assumption \@ref(hyp:IndepTreatEffect), the Wald estimator identifies the Average Treatment Effect (ATE), the average effect of the Treatment on the Treated (TT) and the average effect on compliers and on defiers.
The first thing to know before we state the result is that, under Assumption \@ref(hyp:IndepTreatEffect), all these average treatment effects are equal to each other.
This is a direct implication of the following lemma:

```{lemma,IndepTreatEffectType,name="Independence of Treatment Effects from Types"}
Under Assumption \@ref(hyp:IndepTreatEffect), the treatment effect is independent from types:
  
\begin{align*}
\Delta^Y_i\Ind T_i.
\end{align*}
```

```{proof}
Lemma (4.2) in [Dawid (1979)](https://rss.onlinelibrary.wiley.com/doi/10.1111/j.2517-6161.1979.tb01052.x) states that if $X \Ind Y|Z$ and $U$ is a function of $X$, then $U \Ind Y|Z$.
Since $T_i$ is a function of $(D^1_i,D^0_i)$ under Assumption \@ref(hyp:IndepTreatEffect), Lemma \@ref(lem:IndepTreatEffectType) follows. 
```

A direct corollary of Lemma \@ref(lem:IndepTreatEffectType) is:

```{corollary,IndepTreatEffectAve,name="Independence of Treatment Effects and Average Effects"}
Under Assumption \@ref(hyp:IndepTreatEffect), the Average Treatment Effect (ATE), the average effect of the Treatment on the Treated (TT) and the average effect on compliers and on defiers are all equal:
  
\begin{align*}
\Delta^Y_{ATE} = \Delta^Y_{TT(1)} = \Delta^Y_{TT(0)} = \Delta^Y_{c} = \Delta^Y_{d}.
\end{align*}
```

with:
\begin{align*}
\Delta^Y_{TT(z)} = \esp{Y_i^1-Y_i^0|D_i=1,Z_i=z}.
\end{align*}

```{proof}
Using Lemma \@ref(lem:IndepTreatEffectType), we have that:

\begin{align*}
  \Delta^Y_{c} = \Delta^Y_{d} = \Delta^Y_{at} =\Delta^Y_{nt}.
\end{align*}

Because $T_i$ is a partition, we have $\Delta^Y_{ATE}=\Delta^Y_{c}\Pr(T_i=c)+\Delta^Y_{d}\Pr(T_i=d)+\Delta^Y_{at}\Pr(T_i=at)+\Delta^Y_{nt}\Pr(T_i=nt)=\Delta^Y_{c}$ (since $\Pr(T_i=c)+\Pr(T_i=d)+\Pr(T_i=at)+\Pr(T_i=nt)=1$).
Finally, we also have that $\Delta^Y_{TT(1)}=\Delta^Y_{c}\Pr(T_i=c|D_i=1,Z_i=1)+\Delta^Y_{at}\Pr(T_i=at|D_i=1,Z_i=1)=\Delta^Y_{c}$ and $\Delta^Y_{TT(0)}=\Delta^Y_{d}\Pr(T_i=d|D_i=1,Z_i=0)+\Delta^Y_{at}\Pr(T_i=at|D_i=1,Z_i=0)=\Delta^Y_{c}$, since $(D_i=1)\cap(Z_i=1)\Rightarrow (T_i=c)\cup(T_i=at)$ and $(D_i=1)\cap(Z_i=0)\Rightarrow (T_i=d)\cup(T_i=at)$.
```

We are now equioped to state the final result of this section:

```{theorem,IdentIndepTreatEffect,name="Identification under Independent Treatment Effect"}
Under Assumptions \@ref(hyp:FirstStage), \@ref(hyp:ExclusionRestriction), \@ref(hyp:Independence) and \@ref(hyp:IndepTreatEffect), the Wald estimator identifies the average effect of the Treatment on the Treated:
  
\begin{align*}
  \Delta^Y_{Wald} & = \Delta^Y_{TT}.
\end{align*}
```

```{proof}
Using the formula for the Wald estimator, we have, for the two components of its numerator:

\begin{align*}
\esp{Y_i|Z_i=1} & = \esp{Y_i^0+(Y_i^1-Y_i^0)D_i|Z_i=1} \\
                & = \esp{Y_i^0|Z_i=1}+\esp{\Delta^Y_i|D_i=1,Z_i=1}\Pr(D_i=1|Z_i=1)\\
                & = \esp{Y_i^0|Z_i=1}+\Delta^Y_{TT(1)}\Pr(D_i=1|Z_i=1)\\
\esp{Y_i|Z_i=0} & = \esp{Y_i^0+(Y_i^1-Y_i^0)D_i|Z_i=0} \\
                & = \esp{Y_i^0|Z_i=0}+\esp{\Delta^Y_i|D_i=0,Z_i=1}\Pr(D_i=1|Z_i=0)\\
                & = \esp{Y_i^0|Z_i=0}+\Delta^Y_{TT(0)}\Pr(D_i=1|Z_i=0),\\
\end{align*}

where the first equalities use Assumption \@ref(hyp:ExclusionRestriction).
Now, under Assumption \@ref(hyp:IndepTreatEffect), Corollary \@ref(cor:IndepTreatEffectAve) implies that $\Delta^Y_{TT(0)}=\Delta^Y_{TT(1)}=\Delta^Y_{TT}$.
We thus have that the numerator of the Wald estimator is equal to:

\begin{align*}
\esp{Y_i|Z_i=1}-\esp{Y_i|Z_i=0} & = \Delta^Y_{TT}(\Pr(D_i=1|Z_i=1)-\Pr(D_i=1|Z_i=0))\\
                                & \phantom{=}+\esp{Y_i^0|Z_i=1}-\esp{Y_i^0|Z_i=0}.
\end{align*}

Assumption \@ref(hyp:Independence) implies that $\esp{Y_i^0|Z_i=1}=\esp{Y_i^0|Z_i=0}$.
Using Assumption \@ref(hyp:FirstStage) proves the result.
```

#### Identification under Monotonicity

The classical approach to identification using instrumental variables is due to [Imbens and Angrist (1994)](https://www.jstor.org/stable/2951620) and [Angrist, Imbens and Rubin (1996)](https://www.jstor.org/stable/2291629). 
It rests on Assumption \@ref(hyp:MonotonicityIV) or Monotonicity that we are now familiar with, that requires that the effect of the instrument on treatment participation moves everyone in the same direction.

```{remark}
For the rest of the section, we will assume  that $\forall i$, $D^1_i\geq D_i^0$.
It is without loss of generality, since if the initial treatment does not comply with this requirement, you can simply redefine a new treatment equal to $-D_i$.
```

Under Monotonicity, there are no defiers.
This is what the following lemma shows:

```{lemma,NoDefiers,Name="No Defiers"}
Under Assumption \@ref(hyp:MonotonicityIV), there are no defiers a.s.: 
  
\begin{align*}
  \Pr(T_i=c) & = 0.
\end{align*}
```

```{proof}
Under Assumption \@ref(hyp:MonotonicityIV), $\forall i$, $D^1_i\geq D_i^0$.
As a consequence, $\Pr(D^1_i < D_i^0)=0$.
Since defiers are defined as $D^1_i < D_i^0$, the result follows.
```

In the absence of defiers, the Wald estimator identifies the average effect of the treatment on the compliers, also called the Local Average Treatment Effect:

```{theorem,IdentLATEIV,Name="Identification of the Local Average Treatment Effect with Instrumental Variables"}
Under Assumptions  \@ref(hyp:FirstStage), \@ref(hyp:ExclusionRestriction), \@ref(hyp:Independence) and \@ref(hyp:MonotonicityIV), the Wald estimator identifies the average effect of the treatment on the compliers, also called the Local Average Treatment Effect: 
  
\begin{align*}
  \Delta^Y_{Wald}& = \Delta^Y_{LATE}.
\end{align*}
```

```{proof}
Using Theorem \@ref(thm:IdentLATE) directly proves the result.
```

```{remark}
The magic of the instrumental variables setting applies again.
By moving the instrument, we are able to learn something about the causal effect of the treatment. 
Monotonicity is a very strong assumption though, as are Independence and Exclusion Restriction. 
They are very rarely met in practice.
Even the case of RCTs with encouragement design, where Independence holds by design, might be affected by failures of Exclusion Restriction and/or Monotonicity.
```

```{example}
Let's see how monotonicity works in our example.
```

First, we have to generate a model in which monotonicity holds.
For that, we need to shut down heterogeneous reactions to the instrument.
In practice, we are going to replace the participation equation in our model, which was characterized by a random coefficient, by the following one, which has a constant coefficient:

\begin{align*}
  D_i & = \uns{y_i^B-\bar{\kappa} Z_i + V_i\leq\bar{y}} 
\end{align*}

As a consequence, we have no more defiers and monotonicity holds.
Let us now generate the data from the model with monotonicity:

```{r simulIVMono,eval=TRUE,echo=TRUE,results='hide'}
set.seed(12345)
N <-1000
cov.eta.omega <- matrix(c(param["sigma2eta"],param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),param["sigma2omega"]),ncol=2,nrow=2)
eta.omega <- as.data.frame(mvrnorm(N,c(0,0),cov.eta.omega))
colnames(eta.omega) <- c('eta','omega')
mu <- rnorm(N,param["barmu"],sqrt(param["sigma2mu"]))
UB <- rnorm(N,0,sqrt(param["sigma2U"]))
yB <- mu + UB 
YB <- exp(yB)
Ds <- rep(0,N)
Z <- rbinom(N,1,param["pZ"])
V <- param["gamma"]*(mu-param["barmu"])+eta.omega$omega
Ds[yB-param["barkappa"]*Z+V<=log(param["barY"])] <- 1 
epsilon <- rnorm(N,0,sqrt(param["sigma2epsilon"]))
U0 <- param["rho"]*UB + epsilon
y0 <- mu +  U0 + param["delta"]
alpha <- param["baralpha"]+  param["theta"]*mu + eta.omega$eta
y1 <- y0+alpha
Y0 <- exp(y0)
Y1 <- exp(y1)
y <- y1*Ds+y0*(1-Ds)
Y <- Y1*Ds+Y0*(1-Ds)
```

We can now define the types variable $T_i$:

```{r typesillustrationMono,eval=TRUE,echo=TRUE,results='hide'}
D1 <- ifelse(yB-param["barkappa"]+V<=log(param["barY"]),1,0)
D0 <- ifelse(yB+V<=log(param["barY"]),1,0)
AT <- ifelse(D1==1 & D0==1,1,0)
NT <- ifelse(D1==0 & D0==0,1,0)
C <- ifelse(D1==1 & D0==0,1,0)
D <- ifelse(D1==0 & D0==1,1,0)
Type <- ifelse(AT==1,'a',
            ifelse(NT==1,'n',
                   ifelse(C==1,'c',
                          ifelse(D==1,'d',""))))

data.mono <- data.frame(cbind(Type,C,NT,AT,D1,D0,Y,y,Y1,Y0,y0,y1,yB,alpha,U0,eta.omega$eta,epsilon,Ds,Z,mu,UB))
```

The first thing we can check is that there are no defiers. 
For that, let's count the number of individuals who have $T_i=1$.
It is equal to `r sum(Type=="d")`.

One thing that helped me understand how the IV approach under monotonicity works is the following graph:

```{r plottypesMono,eval=TRUE,echo=TRUE,fig.cap='Types under Monotonicity',fig.align='center',out.width='50%',fig.pos='htbp'}
plot(yB[AT==1]+V[AT==1],y[AT==1],pch=1,xlim=c(5,11),ylim=c(5,11),xlab="yB+V",ylab="Outcomes")
points(yB[NT==1]+V[NT==1],y[NT==1],pch=1,col='blue')
points(yB[C==1 & Ds==1]+V[C==1 & Ds==1],y[C==1 & Ds==1],pch=1,col='red')
points(yB[C==1 & Ds==0]+V[C==1 & Ds==0],y[C==1 & Ds==0],pch=1,col='green')
abline(v=log(param["barY"]),col="red")
abline(v=log(param["barY"])+param['barkappa'],col="red")
text(x=c(log(param["barY"]),log(param["barY"])+param['barkappa']),y=c(5,5),labels=c(expression(bar('y')),expression(bar('y')+bar(kappa))),pos=c(2,4),col=c("red","red"))
legend(5,10.5,c('AT','NT','C|D=1','C|D=0'),pch=c(1,1,1,1),col=c("black",'blue',"red",'green'),ncol=1)
```

What \@ref(fig:plottypesMono) shows is that the IV acts as a randomized controlled trial among compliers.
Within the population of compliers, whether one receives the treatment or not is as good as random.
If we actually knew who the compliers were, we could directly estimate the effect of the treatment by comparing the outcomes of the treated compliers to the outcomes of the untreated compliers. 
Actually, this approach, applied in our sample, yields an estimated treatment effect on the compliers of `r round(mean(y[C==1 & Ds==1])-mean(y[C==1 & Ds==0]),2)`, whereas the simple comparison of participants and non participants would give an estimate of  `r round(mean(y[Ds==1])-mean(y[Ds==0]),2)`.
In our sample, the average effect of the treatment on compliers is actually equal to  `r round(mean(alpha[C==1]),2)`.

Let us finally check that Theorem \@ref(thm:IdentLATEIV) works in the population in our new model.
We need to compute the various parts of the Wald estimator and the average effect of the treatment on the compliers.
The key to understand the Wald estimator is to see that its numerator is composed of the difference between two means, with both means containing the average outcomes of always takers and never takers weighted by their respective proportions in the population, as shown in the proof of Theorem \@ref(thm:IdentLATEIV).
These two means cancel out, leaving only the differences in the means of the compliers in and out of the treatment, weighted by their proportion in the population.
The denominator of the Wald estimator simply provides an estimate of the proportion of compliers. 
In order to illustrate these intuitions in our example, I am going to use the formula for a truncated multivariate normal variable and the package `tmvtnorm`.
The most important thing to notice here is that $(y^0_i,y^1_i,y_i^B+V_i) \sim \mathcal{N}\left(\bar{\mu}+\delta,\bar{\mu}(1+\theta)+\delta+\bar{\alpha},\bar{\mu},\mathbf{C}\right)$ with:

\begin{align*}
  \mathbf{C} &=                    \left(\begin{array}{ccc}
                                              \sigma^2_{\mu}+\rho^2\sigma^2_{U} +\sigma^2_{\epsilon} &
                                              (1+\theta)\sigma^2_{\mu}+\rho^2\sigma^2_U + \sigma^2_{\epsilon} &
                                              (1+\gamma)\sigma^2_{\mu}+\rho\sigma^2_U \\
                                              (1+\theta)\sigma^2_{\mu}+\rho^2\sigma^2_U + \sigma^2_{\epsilon} &
                                              (1+\theta^2)\sigma^2_{\mu}+\rho^2\sigma^2_{U} +\sigma^2_{\epsilon} + \sigma^2_{\eta} &
                                              (1+\theta+\gamma)\sigma^2_{\mu}+\rho\sigma^2_U+\rho_{\eta,\omega}\sigma^2_{\eta}\sigma^2_{\omega} \\
                                              (1+\gamma)\sigma^2_{\mu}+\rho\sigma^2_U &
                                              (1+\theta+\gamma)\sigma^2_{\mu}+\rho\sigma^2_U+\rho_{\eta,\omega}\sigma^2_{\eta}\sigma^2_{\omega} &
                                              (1+\gamma^2)\sigma^2_{\mu}+\sigma^2_U+\sigma^2_{\omega} \\
                                              \end{array}
                                        \right)
\end{align*}

We now simply have to derive the mean outcomes and proportions of each type in the population in order to form the Wald estimator.
Let me first derive the joint distribution of the portential outcomes and the means and proportions of each type in the population.

```{r OutcomesTypesPopulation,eval=TRUE,echo=TRUE,results='hide'}
mean.y0.y1.yBV <- c(param['barmu']+param['delta'],param['barmu']*(1+param['theta'])+param['delta']+param['baralpha'],param['barmu'])
cov.y0.y1.yBV <- matrix(c(param['sigma2mu']+param['rho']^2*param['sigma2U']+param['sigma2epsilon'],
                          (1+param['theta'])*param['sigma2mu']+param['rho']^2*param['sigma2U']+param['sigma2epsilon'],
                          (1+param['gamma'])*param['sigma2mu']+param['rho']*param['sigma2U'],
                          (1+param['theta'])*param['sigma2mu']+param['rho']^2*param['sigma2U']+param['sigma2epsilon'],
                          (1+param['theta']^2)*param['sigma2mu']+param['rho']^2*param['sigma2U']+param['sigma2epsilon']+param['sigma2eta'],
                          (1+param['theta']+param['gamma'])*param['sigma2mu']+param['rho']*param['sigma2U']+param['rhoetaomega']*param['sigma2eta']*param['sigma2omega'],
                          (1+param['gamma'])*param['sigma2mu']+param['rho']*param['sigma2U'],
                          (1+param['theta']+param['gamma'])*param['sigma2mu']+param['rho']*param['sigma2U']+param['rhoetaomega']*param['sigma2eta']*param['sigma2omega'],
                          (1+param['gamma']^2)*param['sigma2mu']+param['sigma2U']+param['sigma2omega']),3,3,byrow=TRUE)

# cuts
#always takers
lower.cut.at <- c(-Inf,-Inf,-Inf)
upper.cut.at <- c(Inf,Inf,log(param['barY']))
# compliers
lower.cut.comp <- c(-Inf,-Inf,log(param['barY']))
upper.cut.comp <- c(Inf,Inf,log(param['barY'])+param['barkappa'])
# never takers
lower.cut.nt <- c(-Inf,-Inf,log(param['barY'])+param['barkappa'])
upper.cut.nt <- c(Inf,Inf,Inf)

# means by types
#always takers
mean.y1.at.pop <- mtmvnorm(mean=mean.y0.y1.yBV,sigma=cov.y0.y1.yBV,lower=lower.cut.at,upper=upper.cut.at,doComputeVariance=FALSE)[[1]][[2]]
mean.y0.at.pop <- mtmvnorm(mean=mean.y0.y1.yBV,sigma=cov.y0.y1.yBV,lower=lower.cut.at,upper=upper.cut.at,doComputeVariance=FALSE)[[1]][[1]]
# never takers
mean.y1.nt.pop <- mtmvnorm(mean=mean.y0.y1.yBV,sigma=cov.y0.y1.yBV,lower=lower.cut.nt,upper=upper.cut.nt,doComputeVariance=FALSE)[[1]][[2]]
mean.y0.nt.pop <- mtmvnorm(mean=mean.y0.y1.yBV,sigma=cov.y0.y1.yBV,lower=lower.cut.nt,upper=upper.cut.nt,doComputeVariance=FALSE)[[1]][[1]]
#compliers
mean.y1.comp.pop <- mtmvnorm(mean=mean.y0.y1.yBV,sigma=cov.y0.y1.yBV,lower=lower.cut.comp,upper=upper.cut.comp,doComputeVariance=FALSE)[[1]][[2]]
mean.y0.comp.pop <- mtmvnorm(mean=mean.y0.y1.yBV,sigma=cov.y0.y1.yBV,lower=lower.cut.comp,upper=upper.cut.comp,doComputeVariance=FALSE)[[1]][[1]]

# Proportion of each types
# always takers
prop.at.pop <- ptmvnorm.marginal(log(param['barY']),n=3,mean=mean.y0.y1.yBV,sigma=cov.y0.y1.yBV)[[1]]
# never takers
prop.nt.pop <- 1-ptmvnorm.marginal(log(param['barY'])+param['barkappa'],n=3,mean=mean.y0.y1.yBV,sigma=cov.y0.y1.yBV)[[1]]
# compliers
prop.comp.pop <- ptmvnorm.marginal(log(param['barY'])+param['barkappa'],n=3,mean=mean.y0.y1.yBV,sigma=cov.y0.y1.yBV)[[1]]-ptmvnorm.marginal(log(param['barY']),n=3,mean=mean.y0.y1.yBV,sigma=cov.y0.y1.yBV)[[1]]

# LATE
late.pop <- mean.y1.comp.pop-mean.y0.comp.pop
late.prop.comp.pop <- late.pop*prop.comp.pop
# Wald
num.Wald.pop <- (mean.y1.comp.pop*prop.comp.pop+mean.y1.at.pop*prop.at.pop+mean.y0.nt.pop*prop.nt.pop-(mean.y0.comp.pop*prop.comp.pop+mean.y1.at.pop*prop.at.pop+mean.y0.nt.pop*prop.nt.pop))
denom.Wald.pop <- (prop.at.pop+prop.comp.pop-prop.at.pop)
Wald.pop <- num.Wald.pop/denom.Wald.pop
```

We are now equipped to compute the Wald estimator in the population.
Before that, let us compute the LATE.
We have $\Delta^Y_{LATE} =$ `r round(late.pop,3)`.
The Wald estimator is equal to $\Delta^Y_{Wald} =$ `r round(Wald.pop,3)`.
They are obviously equal.
This is because the numerator of the Wald is equal to the product of the LATE multiplied by the proportion of compliers (which is equal to `r round(late.prop.comp.pop,3)`).
This is because the outcomes of never takers and always takers cancel out on each separate term of the numerator of the Wald estimator.
Indeed, we have that the numerator of the Wald estimator is equal to: `r round(num.Wald.pop,3)`.

### Estimation

Estimation of the LATE under the IV assumptions closely follows the same steps that we have delineated in Section \@ref(IVRCT):

  1. **First stage** regression of $D_i$ on $Z_i$: this estimates the impact of the instrument on participation into the program and estimates the proportion of compliers.
  2. **Reduced form** regression of $Y_i$ on $Z_i$: this estimates the impact of the instrument on outcomes, *a.k.a* the ITE.
  3. **Structural** regression of $Y_i$ on $D_i$ using $Z_i$ as an instrument, which estimates the LATE.

Let's take these three steps in turn.

#### First stage regression

The first stage regression regresses $D_i$ on $Z_i$ and thus estimates the impact of the instrument on treatment participation, which is equal to the proportion of compliers.
It can be run using the With/Without estimator or OLS (both are numerically equivalent as Lemma \@ref(lem:WWOLS) shows) or OLS conditioning on observed covariates.

```{example}
Let's see how these three approaches fare in our example.
```

```{r FirstStageIV,eval=TRUE,echo=TRUE,results='hide'}
# WW first stage
WW.First.Stage.IV <- mean(Ds[Z==1])-mean(Ds[Z==0])
# Simple OLS
OLS.D.Z.IV <- lm(Ds~Z)
OLS.First.Stage.IV <- coef(OLS.D.Z.IV)[[2]]
# OLS conditioning on yB
OLS.D.Z.yB.IV <- lm(Ds~Z+yB)
OLSX.First.Stage.IV <- coef(OLS.D.Z.yB.IV)[[2]]
```

The WW estimator of the first stage impact of $Z_i$ on $D_i$ is equal to `r round(WW.First.Stage.IV,3)`.
The OLS estimator of the first stage impact of $Z_i$ on $D_i$ is equal to `r round(OLS.First.Stage.IV,3)`.
The OLS estimator of the first stage impact of $Z_i$ on $D_i$ conditioning on $y^B_i$ is equal to `r round(OLSX.First.Stage.IV,3)`.
Remember that the true proportion of compliers in the population in our model is equal to `r round(prop.comp.pop,3)`.

#### Reduced form regression

The reduced form regression regresses $Y_i$ on $Z_i$ and thus estimates the impact of the instrument on outcomes, which is equal to the ITE.
It can be run using the With/Without estimator or OLS (both are numerically equivalent as Lemma \@ref(lem:WWOLS) shows) or OLS conditioning on observed covariates.

```{example}
Let's see how these three approaches fare in our example.
```

```{r ReducedFormIV,eval=TRUE,echo=TRUE,results='hide'}
# WW reduced form
WW.Reduced.Form.IV <- mean(y[Z==1])-mean(y[Z==0])
# Simple OLS
OLS.y.Z.IV <- lm(y~Z)
OLS.Reduced.Form.IV <- coef(OLS.y.Z.IV)[[2]]
# OLS conditioning on yB
OLS.y.Z.yB.IV <- lm(y~Z+yB)
OLSX.Reduced.Form.IV <- coef(OLS.y.Z.yB.IV)[[2]]
```

The WW estimator of the reduced form impact of $Z_i$ on $y_i$ is equal to `r round(WW.Reduced.Form.IV,3)`.
The OLS estimator of the reduced form impact of $Z_i$ on $y_i$ is equal to `r round(OLS.Reduced.Form.IV,3)`.
The OLS estimator of the reduced form impact of $Z_i$ on $y_i$ conditioning on $y^B_i$ is equal to `r round(OLSX.Reduced.Form.IV,3)`.
Remember that the true ITE in the population in our model is equal to `r round(late.prop.comp.pop,3)`.

#### Structural regression

The final step of the analysis is to estimate the impact of $D_i$ on $Y_i$ using $Z_i$ as an instrument.
This can be done either by directly using the Wald estimator, by dividing the estimate of the reduced form by the result of the first stage, or by directly using the IV estimator (which is equivalent to the Wald estimator as Theorem \@ref(thm:WaldIV) shows) or the IV estimator conditional on covariates.

```{example}
Let's see how these four approaches fare in our example.
```

```{r StructuralFormIV,eval=TRUE,echo=TRUE,results='hide'}
# Wald structural form
Wald.Structural.Form.IV <- (mean(y[Z==1])-mean(y[Z==0]))/(mean(Ds[Z==1])-mean(Ds[Z==0]))
# Simple IV
TSLS.y.D.Z.IV <- ivreg(y~Ds|Z)
TSLS.Structural.Form.IV <- coef(TSLS.y.D.Z.IV)[[2]]
# IV conditioning on yB
TSLS.y.D.Z.yB.IV <- ivreg(y~Ds+yB|Z+yB)
TSLSX.Structural.Form.IV <- coef(TSLS.y.D.Z.yB.IV)[[2]]
```

The Wald estimator of the LATE is equal to $\hat{\Delta}_{Wald}^{y}=$ `r round(Wald.Structural.Form.IV,3)`.
The IV estimator of the LATE is equal to $\hat{\Delta}_{IV}^{y}=$ `r round(TSLS.Structural.Form.IV,3)`, and is numerically identical to the Wald estimator, as expected.
The IV estimator of the LATE conditioning on $y_i^B$ is equal to `r round(TSLSX.Structural.Form.IV,3)`.
Remember that the true LATE in the population in our model is equal to `r round(late.pop,3)`.

```{remark}
The last thing we might want to check is what the sampling noise of the IV estimator looks like and whether it is reduced by conditioning on observed covariates.
```

```{example}
Let's see how sampling noise moves in our example.
```

**Do it**


### Estimation of sampling noise



```{remark}
The framework we have seen here as been extended to multivalued instruments or treatments by several papers.
[Imbens and Angrist (1994)](https://www.jstor.org/stable/2951620) extend the framework to an ordered instrument.
They show that the 2SLS estimator is a weighted average of LATEs for each values of the instrument, with positive weights summing to one.
[Angrist and Imbens (1995)](https://www.tandfonline.com/doi/abs/10.1080/01621459.1995.10476535) extend the framework to he case where the treatment is an ordered discrete variable and there are multiple dichotomous instruments.
They again show that the 2SLS estimator is a weighted average of LATEs with positive weights summing to one. 
[Heckman and Vytlacil (1999)](https://www.pnas.org/content/96/8/4730) extend the framework to a case with a continuous instrument and show that one can the define a Marginal Treatment Effect (or MTE) that is equal to the effect of the treatment on individuals that have the same unobserved propensity to take the treatment.
They show that the MTE can be identified by a limiting form of Wald estimator that they call a Local Instrumental Variable estimator.
They also show that average treatment effect parameters such as TT, ATE and LATE are all weighted averages of the MTE, with positive weights summing to one. 
Under strong support conditions on the side of the instrument, one can thus in principle recover all treatment effect parameters with a continuous instrument.
```

```{remark}
One important concern with the first stage regression is that of weak instruments. 
When Assumption \@ref(hyp:FirstStage) does not hold and the impact on the instrument on take up is actually zero in the population, the Wald estimator is not well-defined.
```

**Expand**

## Regression Discontinuity Designs

**To do**

## Difference In Differences

In Difference In Differences (a.k.a. DID), the difference between treated and untreated before the treatment is used to approximate selection bias.
As a consequence, DID works by correcting the With/Without comparison after treatment by the With/Without comparison before treatment and hopes that it is enough to recover the TT.
Hence the name Difference in Differences (DID), since the estimator, in its simplest form, is a difference between two differences.
In this section, we are going to look at identification using DID, estimation and estimation of sampling noise.
At first, we are going to assume that we have only access to two time periods.
In that case, estimation and inference are pretty straightforward. 
We will then examine the case of several time periods, but we will first allow for only one treatment date.
In that case, we will introduce the standard tools used by applied researchers to analyze these types of designs: the event study graph and the Two-Way Fixed Effects estimator (a.k.a. TWFE).
We will determine which effect is estimated by the TWFE estimator and what are the goals of the event study graph.
We will then look at the most complex case: the staggered design, where we have several time periods (strictly more than two) and the date of treatment differs across units.
In the staggered design, troubles start appearing for the TWFE estimator.
We will survey these problems and the proposed solutions to address them.
Finally, we will look at the combination of DID with instrumental variables (the DID-IV estimator) and see which specific types of problems happen there as well.
Let's get to it.

### Difference In Differences with two time periods {#DIDbasic}

Before getting into the rigorous derivations, let's start with a very simple illustration using our workhorse example.

```{example}
How does DID perform and what does it look like in our example model?
```
Let's first generate a dataset with selection bias.

\begin{align*}
y_i^1 & = y_i^0+\bar{\alpha}+\theta\mu_i+\eta_i \\
y_i^0 & = \mu_i+\delta+U_i^0 \\
U_i^0 & = \rho U_i^B+\epsilon_i \\
y_i^B & =\mu_i+U_i^B \\
U_i^B & \sim\mathcal{N}(0,\sigma^2_{U}) \\
D_i   & = \uns{y_i^B+ V_i\leq\bar{y}} \\
V_i   & = \gamma(\mu_i-\bar{\mu}) + \omega_i \\
(\eta_i,\omega_i) & \sim\mathcal{N}(0,0,\sigma^2_{\eta},\sigma^2_{\omega},\rho_{\eta,\omega})
\end{align*}

```{r SimulDID,eval=TRUE,echo=FALSE,results='hide'}
set.seed(1234)
N <-1000
cov.eta.omega <- matrix(c(param["sigma2eta"],param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),param["sigma2omega"]),ncol=2,nrow=2)
eta.omega <- as.data.frame(mvrnorm(N,c(0,0),cov.eta.omega))
colnames(eta.omega) <- c('eta','omega')
mu <- rnorm(N,param["barmu"],sqrt(param["sigma2mu"]))
UB <- rnorm(N,0,sqrt(param["sigma2U"]))
yB <- mu + UB 
YB <- exp(yB)
Ds <- rep(0,N)
V <- param["gamma"]*(mu-param["barmu"])+eta.omega$omega
Ds[yB+V<=log(param["barY"])] <- 1 
epsilon <- rnorm(N,0,sqrt(param["sigma2epsilon"]))
U0 <- param["rho"]*UB + epsilon
y0 <- mu +  U0 + param["delta"]
alpha <- param["baralpha"]+  param["theta"]*mu + eta.omega$eta
y1 <- y0+alpha
Y0 <- exp(y0)
Y1 <- exp(y1)
y <- y1*Ds+y0*(1-Ds)
Y <- Y1*Ds+Y0*(1-Ds)
```

Let's see how DID works on this data.

```{r PlotDID,eval=TRUE,fig.cap='Evolution of average outcomes in the treated and control group',fig.align='center',out.width='50%',echo=FALSE,results='hide',fig.pos='htbp'}
x <- c("Before","After")
y1.observed <- c(mean(yB[Ds==1]),mean(y[Ds==1]))
y1.counterfactual <- c(mean(yB[Ds==1]),mean(y0[Ds==1]))
y0.observed <- c(mean(yB[Ds==0]),mean(y0[Ds==0]))
y1.DID <- c(mean(yB[Ds==1]),mean(y0[Ds==0])+mean(yB[Ds==1])-mean(yB[Ds==0]))
data.DID.plot <- as.data.frame(c(y1.observed,y1.counterfactual,y0.observed,y1.DID))
colnames(data.DID.plot) <- c("Outcome") 
data.DID.plot$Period <- factor(rep(x,4),levels=c("Before","After"))
data.DID.plot$Group <- factor(c("Treated","Treated","Treated counterfactual","Treated counterfactual","Untreated","Untreated","Treated DID","Treated DID"),levels=c("Untreated","Treated","Treated counterfactual","Treated DID"))
data.DID.plot$Observed <- factor(c("Observed","Observed","Unobserved","Unobserved","Observed","Observed","Observed","Observed"),levels=c("Observed","Unobserved"))

WW.before <- mean(yB[Ds==1])-mean(yB[Ds==0])
WW.after <- mean(y[Ds==1])-mean(y[Ds==0])
BA.treated <- mean(y[Ds==1])-mean(yB[Ds==1])
BA.untreated <- mean(y[Ds==0])-mean(yB[Ds==0])
Counterfactual.after <- mean(yB[Ds==1])+BA.untreated
DID <- WW.after - WW.before 
TT <- mean(alpha[Ds==1])

ggplot(data.DID.plot,aes(x=Period,y=Outcome,group=Group,color=Group,shape=Group,linetype=Observed))+
    geom_line() +
    geom_point()+
    scale_linetype_discrete(guide='none') +
    theme_bw()
```

Figure \@ref(fig:PlotDID) shows the evolution of the mean log-outcomes for the treated and untreated groups over time in our simulated dataset.
We can see that in the **Before** period, outcomes ($y_i^B$ in that case) are much higher for the non participants than for the participants, in agreement with the selection rule that makes participation into the program more likely for individuals with lower pre-treatment outcomes.
The With/Without difference in outcomes before the program takes place is $\hat{\Delta}^{y^B}_{WW}=$ `r round(WW.before,3)`.
Second, we see that the difference between participants and non-participants decreases after receiving the treatment.
This is because the outcomes of the participants increase faster than the outcomes of the non participants.
As a consequence, the With/Without difference in outcomes after the program takes place is $\hat{\Delta}^{y}_{WW}=$ `r round(WW.after,3)`.
The DID estimator is built by comparing these two differences.
In our example, $\hat{\Delta}^{y}_{DID}=$ `r round(DID,3)`.
It is not too far from the true treatment effect of $\hat{\Delta}^{y}_{TT}=$ `r round(TT,3)`.

Figure \@ref(fig:PlotDID) also demonstrates that the DID estimator can also be seen as the difference between the Before/After differences in outcomes of the treated and the untreated.
The Before/After difference in outcomes for the non participants is $\hat{\Delta}^{y}_{BA|D=0}=$ `r round(BA.untreated,3)` while the Before/After difference for the participants is $\hat{\Delta}^{y}_{BA|D=1}=$ `r round(BA.treated,3)`, leading to the same DID estimand.
One way to understand the DID estimator is to see it as recreating the counterfactual trajectory of the participants (show as a discontinuous line on Figure \@ref(fig:PlotDID)) by using the trajectory of the non participants and making it start at the pre-treatment level of the participants.
This estimated counterfactual trajectory is shown as the purple continuous line at the bottom of Figure \@ref(fig:PlotDID).
In our example, the true counterfactual trajectory (the discontinuous line) and the estimated counterfactual trajectory almost coincide, making the estimated counterfactual outcome of the participants very close to their true counterfactual outcome (`r round(Counterfactual.after,3)` vs `r round(mean(y0[Ds==1]),3)`).
The difference between these two quantities measures the bias of the DID estimator, and we can see that it is very low in our example.
The fact that the Before/After difference in outcomes for the non participants approximates well the counterfactual Before/After difference in outcomes for the participants is **THE** crucial assumption of the DID estimator. 
It is called the parallel trends assumption.

#### Identification 

The formal setting for introducing the DID estimator is to start with two time periods, **Before** and **After** ($t=B$ and $t=A$ respectively).
Outcomes with and without the treatment in both periods are denoted $Y^d_{i,t}$, for $d\in\left\{0,1\right\}$ and $t\in\left\{B,A\right\}$.
Treatment participation in both periods is denoted $D_{i,t}$ for $t\in\left\{B,A\right\}$.
In the Before period, the treatment is unavailable, so that we get to observe the potential outcomes of the agents in the absence of the treatment.
These two very specific requirements of DID are encoded in the following way:

```{hypothesis,NoTreatmentFirst,name="No Treatment in the Before Period"}
We assume that no unit in the population receives the treatment in the Before period: $D_{i,B}=0$, $\forall i$.
```

Under Assumption \@ref(hyp:NoTreatmentFirst), and without loss of generality, we are going to write $D_i=D_{i,A}$.

```{hypothesis,NoAnticipationEffects,name="No Anticipation Effects"}
We assume that, in the Before period, agents cannot anticipate that the program will happen in the After period, or that they do not change their behavior as a consequence: $Y_{i,B}=Y^0_{i,B}$, $\forall i$.
```

A consequence of Assumptions \@ref(hyp:NoTreatmentFirst) and \@ref(hyp:NoAnticipationEffects) is that we can write observed outcomes as a function of treatment and potential outcomes using the usual switching equation:

\begin{align}\label{eqn:switchDID}
  Y_{i,t} & = Y^1_{i,t}D_{i,t} + Y^0_{i,t}(1-D_{i,t}).
\end{align}

The final very important assumption that we can make is to assume that the trends in the potential outcomes in the absence the treatment are the same for the treated and the untreated units:

```{hypothesis,ParallelTrends,name="Parallel Trends"}
We assume that the trends in the potential outcomes in the absence the treatment are the same for the treated and the untreated units:

\begin{align*}
    \esp{Y^0_{i,A}|D_i=1} - \esp{Y^0_{i,B}|D_i=1} & =   \esp{Y^0_{i,A}|D_i=0} - \esp{Y^0_{i,B}|D_i=0}.
\end{align*}
```

Assumption \@ref(hyp:ParallelTrends) is actually equivalent to assuming that selection bias is constant over time.
This is what this very simple lemma shows:

```{lemma,ParallelTrendsCstSelectionBias,name="Parallel Trends is Constant Selection Bias"}
Assumption \@ref(hyp:ParallelTrends) is equivalent to assuming that selection bias is constant over time:

\begin{align*}
    \esp{Y^0_{i,A}|D_i=1} - \esp{Y^0_{i,A}|D_i=0} & =   \esp{Y^0_{i,B}|D_i=1} - \esp{Y^0_{i,B}|D_i=0} .
\end{align*}
```

```{proof}
The proof follows immediately by adding $\esp{Y^0_{i,B}|D_i=1}-\esp{Y^0_{i,A}|D_i=0}$ to both sides of the equation in Assumption \@ref(hyp:ParallelTrends). 
```

Under these assumptions, we are ready to state the main identification result of this section:

```{theorem,IdentDID,name="DID identifies TT"}
Under Assumptions \@ref(hyp:NoTreatmentFirst), \@ref(hyp:NoAnticipationEffects) and \@ref(hyp:ParallelTrends), the DID estimator identifies the average effect of the Treatment on the Treated after the treatment:

\begin{align*}
    \Delta_{DID}^{Y} & =  \Delta^{Y_A}_{TT},
\end{align*}
```

with:

\begin{align*}
  \Delta^Y_{DID} & = \esp{Y_{i,A}|D_i=1} - \esp{Y_{i,B}|D_i=1} - (\esp{Y_{i,A}|D_i=0} - \esp{Y_{i,B}|D_i=0}),\\
  \Delta^{Y_A}_{TT} & = \esp{Y^1_{i,A}-Y^0_{i,A}|D_{i}=1}.
\end{align*}


```{proof}
\begin{align*}
  \Delta^Y_{DID} & = \esp{Y_{i,A}|D_i=1}-\esp{Y_{i,B}|D_i=1}-(\esp{Y_{i,A}|D_i=0}-\esp{Y_{i,B}|D_i=0}) \\
                & = \esp{Y^1_{i,A}|D_i=1}-\esp{Y^0_{i,B}|D_i=1}-(\esp{Y^0_{i,A}|D_i=0}-\esp{Y^0_{i,B}|D_i=0})\\
                & = \esp{Y^1_{i,A}|D_i=1}-\left(\esp{Y^0_{i,A}|D_i=0}+(\esp{Y^0_{i,B}|D_i=1}-\esp{Y^0_{i,B}|D_i=0})\right)
\end{align*}

where the second equality follows from Assumptions \@ref(hyp:NoTreatmentFirst) and \@ref(hyp:NoAnticipationEffects) and the switching equation, and the third equality follows from Lemma \@ref(lem:ParallelTrendsCstSelectionBias).
Under Assumption \@ref(hyp:ParallelTrends), we have:

\begin{align*}
  \esp{Y^0_{i,A}|D_i=1} & = \esp{Y^0_{i,A}|D_i=0} + (\esp{Y^0_{i,B}|D_i=1}-\esp{Y^0_{i,B}|D_i=0})
\end{align*}

As a consequence, we have:

\begin{align*}
  \Delta^Y_{DID} & = \esp{Y^1_{i,A}|D_i=1}-\esp{Y^0_{i,A}|D_i=1}\\
                & = \esp{Y^1_{i,A}-Y^0_{i,A}|D_i=1}\\
                & = \Delta^{Y_A}_{TT}.
\end{align*}
```

```{example}
How does the DID estimator behave in our example?
```
The Before/After comparison among the participants is equal to $\hat{\Delta}^{y}_{BA|D=1}=$ `r round(BA.treated,3)`.
The Before/After comparison among the non-participants is equal to $\hat{\Delta}^{y}_{BA|D=0}=$ `r round(BA.untreated,3)`.
The DID estimator is thus equal to $\hat{\Delta}^{y}_{DID}=\hat{\Delta}^{y}_{BA|D=1}-\hat{\Delta}^{y}_{BA|D=0}=$ `r round(BA.treated,3)` $-$ `r round(BA.untreated,3)` $=$ `r round(DID,3)`.
It is also equal to the difference between the before and after With/Without estimators.
The Before With/Without estimator is equal to $\hat{\Delta}^{y^B}_{WW}=$ `r round(WW.before,3)`.
The After With/Without estimator is equal to $\hat{\Delta}^{y}_{WW}=$ `r round(WW.after,3)`.
The DID estimator is thus equal to $\hat{\Delta}^{y}_{DID}=\hat{\Delta}^{y}_{WW}-\hat{\Delta}^{y^B}_{WW}=$ `r round(WW.after,3)` $-($ `r round(WW.before,3)` $)=$ `r round(DID,3)`.
This is not too far from the true effect of the treatment in the sample which is equal to $\hat{\Delta}^{y}_{TT}=$ `r round(TT,3)`.

Now, another very important question is whether the DID estimator is consistent, that is whether it is equal to $\Delta^{y}_{TT}$ in our model.
A necessary and sufficient condition for that is for the Parallel Trends Assumption \@ref(hyp:ParallelTrends) to hold. 
Indeed, it can be shown that the bias of the DID estimator is $\Delta^{y}_{B(DID)}=\Delta^{y}_{DID}-\Delta^{y}_{TT}=$ $\esp{y^0_{i}|D_i=1}  - \esp{y^B_{i}|D_i=1}-(\esp{y^0_{i}|D_i=0} - \esp{y^B_{i}|D_i=0})$.
Let us derive $\Delta^{y}_{B(DID)}$ in our example. 
Let us compute the trend in potential outcomes among the treated: 

\begin{align*}
  \esp{y^0_{i,A}|D_i=1} & - \esp{y^0_{i,B}|D_i=1} \\
  & = \esp{y^0_{i}|D_i=1} - \esp{y^B_{i}|D_i=1} \\
  & = \esp{\mu_i+\delta+U_i^0|D_i=1}-\esp{\mu_i+U_i^B|D_i=1} \\
  & = \esp{\mu_i|D_i=1}+\delta+\esp{U_i^0|D_i=1}\\
  & \phantom{=}-\esp{\mu_i|D_i=1}-\esp{U_i^B|D_i=1} \\
  & = \delta + \esp{\rho U_i^B+\epsilon_i|D_i=1}-\esp{U_i^B|D_i=1}\\
  & = \delta -(1-\rho)\esp{U_i^B|D_i=1}.
\end{align*}

Following the same line of reasoning, the trend in potential outcomes among the untreated is:

\begin{align*}
\esp{y^0_{i}|D_i=0} - \esp{y^B_{i}|D_i=0} & = \delta -(1-\rho)\esp{U_i^B|D_i=0}.
\end{align*}

As a consequence, the bias of the DID estimator in our model is:

\begin{align*}
  \Delta^{y}_{B(DID)} & = -(1-\rho)(\esp{U_i^B|D_i=1}-\esp{U_i^B|D_i=0}) \\
  & = -(1-\rho)(\esp{U_i^B|\mu_i+U_i^B+V_i\leq\bar{y}}-\esp{U_i^B|\mu_i+U_i^B+V_i>\bar{y}})
\end{align*}

Is this zero?
The answer actually is that it is not.
In order to see why, notice intuitively that the conditional expectation of $U_i^B$ is taken conditional on something correlated with $U_i^B$ being above or below some threshold.
As a consequence, the two values whose difference is taken in the parenthesis cannot be equal.
More formally, let us derive the formula for the bias of the DID estimator in our model, using the formula for the expectation of a truncated bivariate normal distribution:

\begin{align*}
  \Delta^{y}_{B(DID)}  & = -(1-\rho)(\esp{U_i^B|\mu_i+U_i^B+V_i\leq\bar{y}}-\esp{U_i^B|\mu_i+U_i^B+V_i>\bar{y}}) \\
                        & = (1-\rho)\left(\frac{\sigma^2_U}{(1+\gamma^2)\sigma^2_{\mu}+\sigma^2_U+\sigma^2_{\omega}}\right)
                                         \left(\frac{\phi\left(\frac{\bar{y}-\bar{\mu}}{(1+\gamma^2)\sigma^2_{\mu}+\sigma^2_U+\sigma^2_{\omega}}\right)}
                                            {\Phi\left(\frac{\bar{y}-\bar{\mu}}{(1+\gamma^2)\sigma^2_{\mu}+\sigma^2_U+\sigma^2_{\omega}}\right)}
                                            +\frac{\phi\left(\frac{\bar{y}-\bar{\mu}}{(1+\gamma^2)\sigma^2_{\mu}+\sigma^2_U+\sigma^2_{\omega}}\right)}
                                            {1-\Phi\left(\frac{\bar{y}-\bar{\mu}}{(1+\gamma^2)\sigma^2_{\mu}+\sigma^2_U+\sigma^2_{\omega}}\right)}
                                      \right)
\end{align*}

In order to compute the value of this parameter, and of the average treatment effect, we are going to use the package `tmtvnorm` which provides the moments from a truncated multivariate normal variable.
Here, we use the distribution of $(\alpha_i,U_i^B,\mu_i+U_i^B+V_i)$ which is normal with mean $(\bar{\alpha}+\theta\bar{\mu},0,\bar{\mu})$ and covariance matrix $\mathbf{D}$ with:

\begin{align*}
  \mathbf{D} &=  \left(\begin{array}{ccc}
                      \theta^2\sigma^2_{\mu}+ \sigma^2_{\eta} & 0 & (\theta+\gamma\theta)\sigma^2_{\mu}+\rho_{\eta,\omega}\sigma_{\eta}\sigma_{\omega}\\
                      0 & \sigma^2_U & \sigma^2_U \\
                      (\theta+\gamma\theta)\sigma^2_{\mu}+\rho_{\eta,\omega}\sigma_{\eta}\sigma_{\omega}& \sigma^2_U & (1+\gamma^2)\sigma^2_{\mu}+\sigma^2_U+\sigma^2_{\omega}
                      \end{array}\right)
\end{align*}

```{r BiasDIDPopulation,eval=TRUE,echo=TRUE,results='hide'}
mean.alpha.UB.yBV <- c(param['baralpha']+param['barmu']*param['theta'],0,param['barmu'])
cov.alpha.UB.yBV <- matrix(c(param['theta']^2*param['sigma2mu']+param['sigma2eta'],
                             0,
                             (param['theta']+param['gamma']*param['theta'])*param['sigma2mu']+param['rhoetaomega']*param['sigma2eta']*param['sigma2omega'],
                             0, 
                             param['sigma2U'],
                             param['sigma2U'],
                             (param['theta']+param['gamma']*param['theta'])*param['sigma2mu']+param['rhoetaomega']*param['sigma2eta']*param['sigma2omega'],
                             param['sigma2U'],
                            (1+param['gamma']^2)*param['sigma2mu']+param['sigma2U']+param['sigma2omega']),3,3,byrow=TRUE)

# cuts
#non participants
lower.cut.D0 <- c(-Inf,-Inf,log(param['barY']))
upper.cut.D0 <- c(Inf,Inf,Inf)
# participants
lower.cut.D1 <- c(-Inf,-Inf,-Inf)
upper.cut.D1 <- c(Inf,Inf,log(param['barY']))

# means 
TT <- mtmvnorm(mean=mean.alpha.UB.yBV,sigma=cov.alpha.UB.yBV,lower=lower.cut.D1,upper=upper.cut.D1,doComputeVariance=FALSE)[[1]][[1]]
mean.UB.D0 <- mtmvnorm(mean=mean.alpha.UB.yBV,sigma=cov.alpha.UB.yBV,lower=lower.cut.D0,upper=upper.cut.D0,doComputeVariance=FALSE)[[1]][[2]]
mean.UB.D1 <- mtmvnorm(mean=mean.alpha.UB.yBV,sigma=cov.alpha.UB.yBV,lower=lower.cut.D1,upper=upper.cut.D1,doComputeVariance=FALSE)[[1]][[2]]
B.DID <- -(1-param['rho'])*(mean.UB.D1-mean.UB.D0)
```

In our example, the population $TT$ is equal to $\Delta^y_{TT}=$ `r round(TT,3)`.
The DID estimator is equal to $\Delta^y_{DID}=$ `r round(TT+B.DID,3)`.
As a consequence, the bias of the DID estimator is equal to $\Delta^y_{B(DID)}=$ `r round(B.DID,3)`.

In order to make the DID estimator consistent for the $TT$ parameter, we need to impose that $\rho=1$.
When shocks are permanent, their bias remains constant over time and thus DID can estimate it without error. 
Let us generate new data that are compatible with that assumption.

```{r SimulDIDPT,eval=TRUE,echo=TRUE,results='hide'}
set.seed(1234)
N <-1000
param["rho"] <- 1
cov.eta.omega <- matrix(c(param["sigma2eta"],param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),param["sigma2omega"]),ncol=2,nrow=2)
eta.omega <- as.data.frame(mvrnorm(N,c(0,0),cov.eta.omega))
colnames(eta.omega) <- c('eta','omega')
mu <- rnorm(N,param["barmu"],sqrt(param["sigma2mu"]))
UB <- rnorm(N,0,sqrt(param["sigma2U"]))
yB <- mu + UB 
YB <- exp(yB)
Ds <- rep(0,N)
V <- param["gamma"]*(mu-param["barmu"])+eta.omega$omega
Ds[yB+V<=log(param["barY"])] <- 1 
epsilon <- rnorm(N,0,sqrt(param["sigma2epsilon"]))
U0 <- param["rho"]*UB + epsilon
y0 <- mu +  U0 + param["delta"]
alpha <- param["baralpha"]+  param["theta"]*mu + eta.omega$eta
y1 <- y0+alpha
Y0 <- exp(y0)
Y1 <- exp(y1)
y <- y1*Ds+y0*(1-Ds)
Y <- Y1*Ds+Y0*(1-Ds)
```

Let's see how DID works on this data.

```{r PlotDIDPT,eval=TRUE,fig.cap='Evolution of average outcomes in the treated and control group when the Parallel Trends Assumption holds',fig.align='center',out.width='50%',echo=FALSE,results='hide',fig.pos='htbp'}
x <- c("Before","After")
y1.observed <- c(mean(yB[Ds==1]),mean(y[Ds==1]))
y1.counterfactual <- c(mean(yB[Ds==1]),mean(y0[Ds==1]))
y0.observed <- c(mean(yB[Ds==0]),mean(y0[Ds==0]))
y1.DID <- c(mean(yB[Ds==1]),mean(y0[Ds==0])+mean(yB[Ds==1])-mean(yB[Ds==0]))
data.DID.plot <- as.data.frame(c(y1.observed,y1.counterfactual,y0.observed,y1.DID))
colnames(data.DID.plot) <- c("Outcome") 
data.DID.plot$Period <- factor(rep(x,4),levels=c("Before","After"))
data.DID.plot$Group <- factor(c("Treated","Treated","Treated counterfactual","Treated counterfactual","Untreated","Untreated","Treated DID","Treated DID"),levels=c("Untreated","Treated","Treated counterfactual","Treated DID"))
data.DID.plot$Observed <- factor(c("Observed","Observed","Unobserved","Unobserved","Observed","Observed","Observed","Observed"),levels=c("Observed","Unobserved"))

WW.before <- mean(yB[Ds==1])-mean(yB[Ds==0])
WW.after <- mean(y[Ds==1])-mean(y[Ds==0])
BA.treated <- mean(y[Ds==1])-mean(yB[Ds==1])
BA.untreated <- mean(y[Ds==0])-mean(yB[Ds==0])
Counterfactual.after <- mean(yB[Ds==1])+BA.untreated
DID <- WW.after - WW.before 
TT <- mean(alpha[Ds==1])

ggplot(data.DID.plot,aes(x=Period,y=Outcome,group=Group,color=Group,shape=Group,linetype=Observed))+
    geom_line() +
    geom_point()+
    scale_linetype_discrete(guide='none') +
    theme_bw()
```

Now, the counterfactual change in outcome for the treated and its approximation using the trend experienced by the untreated are extremely close, as the curves *Treated counterfactual* and *Treated DID* show on Figure \@ref(fig:PlotDIDPT).

#### Estimation

Estimation of $TT$ under the $DID$ assumptions can be performed in a variety of ways: using directly the DID formula, using OLS with group fixed effects, using OLS with individual and time dummy variables, using first differences and using the within transformation (also known as the Two-Way Fixed Effects or TWFE estimator).
With only two periods of data and a fully balanced panel, all of these estimators are actually numerically equivalent. 
Let's examine them in turn.

##### Using the DID formula

One could go directly and use the DID formula of Theorem \@ref(thm:IdentDID).
The sample DID estimator is thus equal to:

\begin{align*} 
  \hat{\Delta}^Y_{DID} & = \frac{\sum_{i=1}^NY_{i,A}D_i}{\sum_{i=1}^ND_i} -\frac{\sum_{i=1}^NY_{i,B}D_i}{\sum_{i=1}^ND_i} - \left(\frac{\sum_{i=1}^NY_{i,A}(1-D_i)}{\sum_{i=1}^N(1-D_i)} -\frac{\sum_{i=1}^NY_{i,B}(1-D_i)}{\sum_{i=1}^N(1-D_i)}\right).
\end{align*}

```{example}
In our example, let's see how this estimator works.
```
The Before/After comparison among the participants is equal to $\hat{\Delta}^{y}_{BA|D=1}=$ `r round(BA.treated,3)`.
The Before/After comparison among the non-participants is equal to $\hat{\Delta}^{y}_{BA|D=0}=$ `r round(BA.untreated,3)`.
The DID estimator is thus equal to $\hat{\Delta}^{y}_{DID}=\hat{\Delta}^{y}_{BA|D=1}-\hat{\Delta}^{y}_{BA|D=0}=$ `r round(BA.treated,3)` $-$ `r round(BA.untreated,3)` $=$ `r round(DID,3)`.
It is also equal to the difference between the before and after With/Without estimators.
The Before With/Without estimator is equal to $\hat{\Delta}^{y^B}_{WW}=$ `r round(WW.before,3)`.
The After With/Without estimator is equal to $\hat{\Delta}^{y}_{WW}=$ `r round(WW.after,3)`.
The DID estimator is thus equal to $\hat{\Delta}^{y}_{DID}=\hat{\Delta}^{y}_{WW}-\hat{\Delta}^{y^B}_{WW}=$ `r round(WW.after,3)` $-($ `r round(WW.before,3)` $)=$ `r round(DID,3)`.
This is not too far from the true effect of the treatment in the sample which is equal to $\hat{\Delta}^{y}_{TT}=$ `r round(TT,3)`.
In the population, the $TT$ parameter has not changed, since its computation does not involve $\rho$.
We still have $\Delta^y_{TT}=$ `r round(TT,3)`.

##### Using the Least Squares pooling DID estimator

The most basic regression-based way to implement DID is to run a linear regression of outcomes on a treatment group dummy, a time dummy and their interaction.
The interaction captures the effect of the treatment estimated using DID.
The way it works is as follows: estimate the following equation using OLS and use $\hat{\beta}_{OLS}$ as your DID estimate: $\hat{\beta}_{OLS}=\hat{\Delta}^{Y}_{DID}$. 
\begin{align*}
  	Y_i &  = \alpha +  \mu D_i + \delta T_i + \beta D_iT_i + \epsilon_i.
\end{align*}
$D_i$ is our usual treatment indicator while $T_i$ takes value one when observation $i$ is observed in the *After* and zero otherwise.

```{example}
Let's see how this works in our example.
```
Before estimating the model, we need to build a data frame with all the necessary variables.

```{r RegDID,eval=TRUE,echo=TRUE,results='hide'}
# building a data frame
data.DID <- as.data.frame(cbind(c(y,yB),c(Ds,Ds),c(rep(1,N),rep(0,N))))
colnames(data.DID) <- c('y','D','T')

# running the OLS regression
reg.DID <- lm(y ~ D + T + D*T,data = data.DID)

# coefficients
yB.D0.reg <-  coef(reg.DID)[[1]]
WW.before.reg <-  coef(reg.DID)[[2]]
BA.untreated.reg <- coef(reg.DID)[[3]]
DID.est.reg <- coef(reg.DID)[[4]]

# comparisons
yB.D0.sample <- mean(yB[Ds==0])
```

The estimate of $\hat{\beta}_{OLS}$ in our sample is equal to `r round(DID.est.reg,3)`.
It is exactly equal to $\hat{\Delta}^{y}_{DID}$ as estimated just above.
What is interesting with the regression-based DID approach is that the other coefficients in the regression have a direct interpretation.
For example, the constant $\alpha$ estimates the mean outcome in the untreated group before the treatment.
In our case, we have $\hat{\alpha}_OLS=$ `r round(yB.D0.reg,3)`.
Remember that in our sample, the average outcomes of the untreated before the treatment is equal to $\hatesp{y_i^B|D_i=0}=$ `r round(yB.D0.sample,3)`.
$\mu$, the coefficient in front of the $D_i$ dummy, estimates the With/Without estimator before the treatment.
In our case, we have $\hat{\mu}_{OLS}=$ `r round(WW.before.reg,3)`.
Remember that in our sample, the With/Without estimator before the treatment is equal to $\hat{\Delta}^{y^B}_{WW}=$ `r round(WW.before,3)`.
$\delta$, the coefficient in front of the $T_i$ dummy, estimates the Before/After change in outcomes among the untreated.
In our case, we have $\hat{\delta}_{OLS}=$ `r round(BA.untreated.reg,3)`.
Remember that in our sample, the Before/After estimator among the untreated is equal to $\hat{\Delta}^{y}_{BA|D=0}=$ `r round(BA.untreated,3)`.

```{remark}
A pretty cool property of the regression-based DID estimator is that is does not require panel data.
It works even with repeated cross sections, *i.e.* when observations are drawn from the same population in both periods but are not the same.
```

##### Using First Differences

In the presence of panel data, an alternative to the regression-based DID estimator is the first-difference estimator. 
It simply regresses the change over time in outcomes on the treatment dummy:
\begin{align*}
  	Y_{i,A}-Y_{i,B} &  = \alpha^{FD} +  \beta^{FD} D_i + \epsilon^{FD}_i.
\end{align*}
The coefficient $\beta^{FD}$ estimated by OLS is an estimate of the DID parameter.

```{example}
Let's see how this works in our example.
```
Before running the model, we need to generate first the differenced estimates.
One very simple way to do that is simply to take the difference between the before and the after outcome vectors.

```{r RegFD,eval=TRUE,echo=TRUE,results='hide'}
# building a data frame
data.FD <- as.data.frame(cbind(y-yB,Ds))
colnames(data.FD) <- c('BAy','D')

# running the OLS regression
reg.FD <- lm(BAy ~ D,data = data.FD)

# coefficients
BA.untreated.FD <- coef(reg.FD)[[1]]
DID.est.FD <- coef(reg.FD)[[2]]
```

The estimate of $\hat{\beta}^{FD}_{OLS}$ in our sample is equal to `r round(DID.est.FD,3)`.
It is exactly equal to $\hat{\Delta}^{y}_{DID}$ as estimated just above.
Note also that $\alpha^{FD}$ estimates the Before/After change in outcomes among the untreated.
In our case, we have $\hat{\alpha}^{FD}_{OLS}=$ `r round(BA.untreated.FD,3)`.
Remember that in our sample, the Before/After estimator among the untreated is equal to $\hat{\Delta}^{y}_{BA|D=0}=$ `r round(BA.untreated,3)`.

##### Using the Least Squares Dummy Variables estimator

One very computer-intensive way to estimate $TT$ in a DID setting is to use the OLS estimator supplemented with dummies for each observation and for each time period, also called the Least-Squares Dummy Variables estimator.
In practice, the estimator is based on the following regression:
\begin{align*}
  	Y_{i,t} &  = \sum_{j=1}^N\mu_j\uns{j=i} + \sum_{l=0}^1\delta_l\uns{l=t} + \beta^{LSDV} D_{i,t} + \epsilon^{LSDV}_{i,t}.
\end{align*}
The notation is generally simplified as follows:
\begin{align*}
  	Y_{i,t} &  = \mu_i + \delta_t + \beta^{TWFE} D_{i,t} + \epsilon^{TWFE}_{i,t},
\end{align*}

This last estimator is generally called the Two-Way Fixed Effects estimator, since it has two-sets of so-called fixed effects (individual fixed effects, $\mu_i$, and time fixed effects $\delta_t$).
I will write it using this second, more compact, formulation, but I think the first formulation encapsulates better how the Least-Squares Dummy Variables estimator works.
In what follows, we will see other ways of estimating the Two-Way Fixed Effects model, but for now, let us focus on the Least-Squares Dummy Variables estimator. 
The way it works is simply by throwing a bunch of dummy variables in the regression.

```{example}
Let's see how the Least Squares Dummy Variable works in our example.
For that, we need to generate one dummy variable for each individual $i$ in our sample.
This is made simple by the `factor` function in `R`. 
We are also going to run the model without a constant, so that all the fixed effects are identified.
```

```{r RegLSDV,eval=TRUE,echo=TRUE,results='hide'}
# adding one column to the DID data frame with the individual index for each observation of the same $i$
data.DID$indiv <- as.factor(c(1:N,1:N))
# generating Dit (time varying)
data.DID$Dit <- data.DID$D*data.DID$T
# running the LSDV estimator
reg.LSDV <- lm(y~-1 + Dit + as.factor(T) + indiv,data=data.DID)
# result
DID.est.LSDV <- coef(reg.LSDV)[[1]]
```

The Least-Squares Dummy Variables estimate of $TT$ is equal to: $\hat{\beta}^{LSDV}=$ `r round(DID.est.LSDV,3)`.

```{remark}
The term *fixed effect* is specific to the panel data literature in econometrics. 
It refers to the fact that both $\mu_i$ and $\delta_t$ are allowed to be correlated with $D_{i,t}$ in this model.
This is in contrast to the *random effects model* where $\mu_i$ and $\delta_t$ are assumed to be independent of the regressors of interest.
```

##### Using the Within estimator

You might have noticed that the Least-Squares Dummy Variables estimator took some time to compute on your computer. 
This is because it requires the inversion of a very large matrix, as large as the number of fixed effects plus one. 
The size of this computation increases as the number of observation and time periods increases, meaning that this computation might become practically unfeasible in very large datasets. 
Several tricks have been developed to decrease the computational burden of the estimation of the Two-Way Fixed Effects model. 
One approach is to use the First Difference estimator.
Another approach is the Within estimator. 
The way the Within estimator works is by taking the difference between each observation and its mean over time or over individuals. 
More precisely, the Within estimator estimates the following model by OLS:
\begin{align*}
  	Y_{i,t}-\frac{1}{2}\sum_{t=0}^1Y_{i,t} &  = \delta^{W}_t + \beta^{W}(D_{i,t}-\frac{1}{2}\sum_{t=0}^1D_{i,t}) + \epsilon^{W}_{i,t}.
\end{align*}

The reason why this trick works is because of the shape of the Two-Way Fixed Effects model.
Indeed, taking the average of the Two-Way Fixed Effects model over time gives:
\begin{align*}
  	\frac{1}{2}\sum_{t=0}^1Y_{i,t} &  = \mu_i + \frac{1}{2}\sum_{t=0}^1\delta_t + \beta^{TWFE}\frac{1}{2}\sum_{t=0}^1D_{i,t} + \frac{1}{2}\sum_{t=0}^1\epsilon^{TWFE}_{i,t}.
\end{align*}
Taking the difference between the Two-Way Fixed Effects model and its time-averaged version gives the Within estimator.
The key is that the differencing gets rid of the individual fixed effects parameter $\mu_i$ and thus makes it unnecessary to estimate it.
The set of parameters to estimate is thus much smaller than in the Least-Squares Dummy Variables estimator.

```{example}
Let's see how the Within estimator works in our example.
For that, we need to compute the average over time of the outcome and of the treatment for each observation in our dataset. 
This is made simple by the `summarize` function of the `dplyr` package.
```

```{r RegW,eval=TRUE,echo=TRUE,results='hide'}
# generating the time means of Y and Dit
TimeMeansYDit <- data.DID %>%
                  group_by(indiv) %>%
                  summarize(
                    TimeMeanY = mean(y),
                    TimeMeanDit = mean(Dit)
                  )
# doubling the observations to be able to take the difference in both periods
TimeMeansYDit <- rbind(TimeMeansYDit,TimeMeansYDit)                  
# taking the difference in both periods
data.DID$W.y <- data.DID$y-TimeMeansYDit$TimeMeanY
data.DID$W.Dit <- data.DID$Dit-TimeMeansYDit$TimeMeanDit
# running the within estimator
reg.W <- lm(W.y~-1 + W.Dit + as.factor(T),data=data.DID)
# result
DID.est.W <- coef(reg.W)[[1]]
```

The Within estimate of $TT$ is equal to: $\hat{\beta}^{W}=$ `r round(DID.est.W,3)`.

The `plm` package directly implements the Within transformation.
The same package also estimates the First Difference model and the Least Squares pooling DID estimator.
Let's see how this works.

```{r RegWplm,eval=TRUE,echo=TRUE,results='hide'}
# running the within estimator
reg.W.plm <- plm(y ~  Dit + as.factor(T) , data = data.DID, index= c("indiv", "T"), model = "within")
# result
DID.est.W.plm <- coef(reg.W.plm)[[1]]

# running the first difference estimator
reg.FD.plm <- plm(y ~  Dit + as.factor(T) , data = data.DID, index= c("indiv", "T"), model = "fd")
# result
DID.est.FD.plm <- coef(reg.FD.plm)[[2]]

# running the OLS pooling DID estimator
reg.OLS.plm <- plm(y ~ as.factor(T) + D + Dit , data = data.DID, index= c("indiv", "T"), model = "pooling")
# result
DID.est.OLS.plm <- coef(reg.OLS.plm)[[4]]
```

As expected, `plm` gives the following estimates for $TT$: $\hat{\beta}^{W}=$ `r round(DID.est.W.plm,3)`, $\hat{\beta}^{FD}=$ `r round(DID.est.FD.plm,3)` and $\hat{\beta}^{OLS}=$ `r round(DID.est.OLS.plm,3)`. 

##### Using fast estimators of the Two-Way Fixed Effects model

All the estimators of the TWFE model that we have seen so far have issues. 
The OLS pooling DID estimator does not account for the panel structure of the data when it exists.
It does not alter the precision of the estimator but it makes it mode difficult to account for more dimensions of fixed effects than two.
The First Difference estimator, similarly, cannot easily account for more than two sets of fixed effects.
The Least Squares Dummy variable is slow because of the very large matrix inversion problem.
Therefore, applied econometricians tend to prefer using the Within estimator in practice.
The Within estimtor of the Two-Way Fixed Effects model is not without problems as well.
As the sample size grows large, or the number of fixed effects increases, it becomes more and more difficult to compute the within transformation.
As a consequence, recent packages have proposed to optimize the computation of the TWFE model using various computational tricks. 
Let's examine two in turn.

###### The Alternating Projections method

The `lfe` package in `R` implements an alternating projections method to estimate the $N$-Way Fixed effects model.
It is based on an algorithm proposed by [Gaure (2013)](https://doi.org/10.1016/j.csda.2013.03.024). 
The basic idea of [Gaure (2013)](https://www.econstor.eu/bitstream/10419/47280/1/637363027.pdf) is to repeat centering on the means of the fixed effects (the within operation) in an alternating manner between the various fixed effects dimensions until convergence. 

```{example}
Let's see how the `lfe` estimator works in our example.
```

```{r RegWlfe,eval=TRUE,echo=TRUE,results='hide'}
# running the within estimator
reg.W.lfe <- felm(y ~  Dit + as.factor(T) | indiv , data = data.DID)
# result
DID.est.W.lfe <- coef(reg.W.lfe)[[1]]
```

As expected, `lfe` gives the following estimate for $TT$: $\hat{\beta}^{AP}=$ `r round(DID.est.W.lfe,3)`.

###### The Likelihood Concentration method

One problem with the `lfe` package is that it works only for linear models.
The [`fixest`](https://cran.r-project.org/web/packages/fixest/vignettes/fixest_walkthrough.html) package in `R` proposes a solution for estimating fixed effects models in non-linear cases as well.
The solution is based on the concentrated likelihood as explained in [Berge (2018)](https://wwwen.uni.lu/content/download/110162/1299525/file/2018_13).
The intuition is as follows.
We first postulate a value for the treatment effect and the coefficient on the time dummies and we estimate each of the individual fixed effects using maximum likelihood.
We then use maximum likelihood to find the treatment effect using the values of the fixed effects estimated in the previous step. 
This seems complicated but the key idea is to separate the estimation of the fixed effects from the estimation of the parameters of interest. 

```{example}
Let's see how the `fixest` estimator works in our example.
```

```{r RegWfixest,eval=TRUE,echo=TRUE,results='hide'}
# running the within estimator
reg.W.fixest <- feols(y ~  Dit + as.factor(T) | indiv , data = data.DID)
# result
DID.est.W.fixest <- coef(reg.W.fixest)[[1]]
```

As expected, `fixest` gives the following estimate for $TT$: $\hat{\beta}^{LC}=$ `r round(DID.est.W.fixest,3)`.

##### Equivalence between the various DID methods with two time periods

The above results suggest that all DID estimators are equivalent when working with two time periods.
The following theorem actually states this result rigorously:

```{theorem,EstimDID,name="All DID estimators are numerically equivalent with two time periods"}
Under Assumptions \@ref(hyp:NoTreatmentFirst), \@ref(hyp:NoAnticipationEffects) and \@ref(hyp:ParallelTrends), in a panel with only two periods of data, all the DID estimators are numerically equivalent: $\hat{\beta}^{OLS}=\hat{\beta}^{FD}=\hat{\beta}^{W}=\hat{\beta}^{LSDV}=\hat{\beta}^{AP}=\hat{\beta}^{LC}=\hat{\Delta}^Y_{DID}$. 
```

```{proof}
See Section \@ref(proofEstimDID).
```

A corollary to Theorem \@ref(thm:EstimDID) shows that the coefficients in the Least Squares Pooling DID estimator all estimate some relevant parameters that help make sense of the DID estimator:

```{corollary,OLSDIDCoefs,name="Coefficients in the OLS DID model"}
Under Assumptions \@ref(hyp:NoTreatmentFirst), \@ref(hyp:NoAnticipationEffects) and \@ref(hyp:ParallelTrends), in a panel with only two periods of data, the coefficients of the Least Squares pooling DID estimator are:
```
\begin{align*}
  \hat{\alpha}^{OLS} & = \bar{Y}^0_B \\
  \hat{\mu}^{OLS} &  = \bar{Y}^1_B-\bar{Y}^0_B\\
  \hat{\delta}^{OLS} & = \bar{Y}^0_A-\bar{Y}^0_B \\
  \hat{\beta}^{OLS} & = \bar{Y}^1_A-\bar{Y}^1_B-(\bar{Y}^0_A-\bar{Y}^0_B),
 \end{align*}
with $\bar{Y}^d_t=\frac{\sum_{i=1}^NY_{i,t}\uns{D_i=d}}{\sum_{i=1}^N\uns{D_i=d}}$.

```{proof}
See Section \@ref(proofEstimDID), the proof for the OLS DID estimator.
```

Corollary \@ref(cor:OLSDIDCoefs) shows that the constant in the OLS DID model $\hat{\alpha}^{OLS}$ estimates the average outcome for the untreated group in the period before the treatment date; the coefficient on the group dummy $D_i$ $\hat{\mu}^{OLS}$ estimates the difference between the average outcome for the treated group and the average outcome in the untreated group in the period before the treatment takes place; the coefficient on the time dummy $T_i$ $\hat{\delta}^{OLS}$ estimates the difference in average outcomes in the untreated group before and after the treatment takes place.
These coefficients are useful to udenrstand how the DID estimator is formed.
They can also be used to plot the trajectory of the mean outcomes in each group over time to make a visual impression of how DID works.

Finally, let's see how our estimator varies across sampling replications.
A key difference is whether we have access to panel data or not. 
Indeed, estimates from a repeated cross section are going to be more noisy since they are going to sample different people in different periods and thus are going to be affected by sampling noise stemming from the fixed effects. 
This is not going to be the case with panel data, since all the estimators based on the TWFE estimator differentiate out the individual fixed effects.

**Do the simulations**

#### Inference

**Derive the distribution of the estimators with repeated cross sections and panels**

### Reverse Difference In Differences designs with two time periods

Before getting into the general case of DID with several time periods and several treatment dates, it is useful to quickly look at identification in the case of reverse DID designs.
We are going to look at two such designs. 
In the first type, some units are exposed to the treatment in the first period and the rest of the units enter the treatment in the second period.
In the second type of reverse DID design, all units receive the treatment in the first period and some units exit the treatment in the second period.

#### Reverse DID designs where everyone enters the treatment at the second period

Compared to the setting in the previous section, the main change is to Assumption \@ref(hyp:NoTreatmentFirst):

```{hypothesis,AllTreatmentSecond,name="Everyone Receives Treatment in the Second Period"}
We assume that every unit in the population receives the treatment in the second period: $D_{i,A}=1$, $\forall i$.
```

Under Assumption \@ref(hyp:AllTreatmentSecond), and without loss of generality, we can write $D_i=D_{i,B}$, $\forall i$.
We are going to call the units which stay in the treatment during the two periods *always takers* and the units who enter the treatment in the second period *switchers*.
*Always takers* are defined by $D_i=1$ while *switchers* are defined by $D_i=0$.

In this new setting, we have to redefine the DID estimator.
We are going to choose an estimator that compares the change in outcomes among individuals who have changed treatment status (*switchers*) to the change in outcome among individuals who have not changed treatment status (*always takers*):

\begin{align*}
  \Delta^Y_{DID^r} & = \esp{Y_{i,A}|D_i=0} - \esp{Y_{i,B}|D_i=0} - (\esp{Y_{i,A}|D_i=1} - \esp{Y_{i,B}|D_i=1}).\\
\end{align*}

Note that $\Delta^Y_{DID^r}$ is the opposite of the more usual DID estimator $\Delta^Y_{DID}$, hence the name of reverse DID.

```{example}
Let us generate data in our example model that complies with Assumption \@ref(hyp:AllTreatmentSecond).
```

\begin{align*}
y^1_{i,A} & = y_{i,A}^0+\bar{\alpha}_A+\bar{\alpha}_{AT}D_{i,B}+\theta_A\mu_i+\eta_{i,A} \\
y^0_{i,A} & = \mu_i+\delta+U^0_{i,A} \\
U^0_{i,A} & = \rho U_{i,B}+\epsilon_{i,A} \\
y^1_{i,B} & =y^0_{i,B} + \bar{\alpha}_B+\theta_B\mu_i+\eta_{i,B} \\
y^0_{i,B} & =\mu_i+U_{i,B} \\
U_{i,B} & \sim\mathcal{N}(0,\sigma^2_{U}) \\
D_{i,B}   & = \uns{y^0_{i,B}+ V_i\leq\bar{y}} \\
V_i   & = \gamma(\mu_i-\bar{\mu}) + \omega_i \\
(\eta_{i,A},\eta_{i,B},\omega_i) & \sim\mathcal{N}(0,0,0,\sigma^2_{\eta},\sigma^2_{\eta},\sigma^2_{\omega},0,\rho_{\eta,\omega})
\end{align*}

Note that in this model we first have imposed that some people enter the treatment in the first period (period $B$).
We also have added other important features, such as the fact that the effect of the treatment varies over time.
The most important component of this variation is the constant parameter $\bar{\alpha}$ which now differs from period to period ($\bar{\alpha}_A\neq\bar{\alpha}_B$).
The treatment effect also varies over group and over time, with the *always treated* group (characterized by $D_{i,B}=1$) having an additional increase in treatment effects of $\bar{\alpha}_{AT}$ in period $A$.
Let's encode new parameter values.

```{r param.DID.reverse.second,eval=TRUE,echo=TRUE,results='hide'}
param <- c(8,.5,.28,1500,0.9,0.01,0.01,0.05,0.05,0.05,0.2,0.1,0.3,0.1,0.28,0)
names(param) <- c("barmu","sigma2mu","sigma2U","barY","rho","thetaA","thetaB","sigma2epsilon","sigma2eta","delta","baralphaA","baralphaB","baralphaAT","gamma","sigma2omega","rhoetaomega")
```

Let's now simulate a dataset according to these new equations.

```{r SimulDIDRev2nd,eval=TRUE,echo=TRUE,results='hide'}
set.seed(1234)
N <- 1000
cov.eta.omega <- matrix(c(param["sigma2eta"],0,param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),
                          0,param["sigma2eta"],param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),
                          param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),param["sigma2omega"]),ncol=3,nrow=3,byrow=T)
eta.omega <- as.data.frame(mvrnorm(N,c(0,0,0),cov.eta.omega))
colnames(eta.omega) <- c('etaA','etaB','omega')
mu <- rnorm(N,param["barmu"],sqrt(param["sigma2mu"]))
UB <- rnorm(N,0,sqrt(param["sigma2U"]))
y0B <- mu + UB 
Y0B <- exp(y0B)
Ds <- rep(0,N)
V <- param["gamma"]*(mu-param["barmu"])+eta.omega$omega
Ds[y0B+V<=log(param["barY"])] <- 1 
alphaB <- param["baralphaB"]+  param["thetaB"]*mu + eta.omega$etaB
y1B <- y0B+alphaB
Y1B <- exp(y1B)
epsilonA <- rnorm(N,0,sqrt(param["sigma2epsilon"]))
U0A <- param["rho"]*UB + epsilonA
y0A <- mu +  U0A + param["delta"]
alphaA <- param["baralphaA"]+ param["baralphaAT"]*Ds+ param["thetaA"]*mu + eta.omega$etaA
y1A <- y0A+alphaA
Y0A <- exp(y0A)
Y1A <- exp(y1A)
yB <- y1B*Ds+y0B*(1-Ds)
YB <- Y1B*Ds+Y0B*(1-Ds)
yA <- y1A
YA <- Y1A
```

Let's see how DID works on this data.

```{r PlotDIDRev2nd,eval=TRUE,warning=FALSE,error=FALSE,message=FALSE,echo=TRUE,fig.cap='Evolution of average outcomes in the always treated and switchers group in the reverse DID design where everyone is treated in the second period',fig.align='center',out.width='50%',results='hide',fig.pos='htbp'}
x <- c("Before","After")
y.AT <- c(mean(yB[Ds==1]),mean(yA[Ds==1]))
y.AT.counterfactual <- c(mean(y0B[Ds==1]),mean(y0A[Ds==1]))
y.Switchers <- c(mean(yB[Ds==0]),mean(yA[Ds==0]))
y.Switchers.counterfactual <- c(mean(y0B[Ds==0]),mean(y0A[Ds==0]))
y.Switchers.counterfactual.1 <- c(mean(y1B[Ds==0]),mean(y1A[Ds==0]))
y.Switchers.DID <- c(mean(yB[Ds==0]),mean(yB[Ds==0])+mean(yA[Ds==1])-mean(yB[Ds==1]))
y.Switchers.DID.1 <- c(mean(yA[Ds==0])-(mean(yA[Ds==1])-mean(yB[Ds==1])),mean(yA[Ds==0]))
data.DID.plot <- as.data.frame(c(y.AT,y.AT.counterfactual,y.Switchers,y.Switchers.counterfactual,y.Switchers.counterfactual.1,y.Switchers.DID,y.Switchers.DID.1))
colnames(data.DID.plot) <- c("Outcome") 
data.DID.plot$Period <- factor(rep(x,7),levels=c("Before","After"))
data.DID.plot$Group <- factor(c("Always Treated","Always Treated","Always Treated counterfactual y0","Always Treated counterfactual y0","Switchers","Switchers","Switchers counterfactual y0","Switchers counterfactual y0","Switchers counterfactual y1","Switchers counterfactual y1","Switchers DIDr","Switchers DIDr","Switchers DIDr1","Switchers DIDr1"),levels=c("Switchers","Switchers counterfactual y1","Switchers counterfactual y0","Switchers DIDr","Switchers DIDr1","Always Treated","Always Treated counterfactual y0"))
data.DID.plot$Observed <- factor(c("Observed","Observed","Unobserved","Unobserved","Observed","Observed","Unobserved","Unobserved","Unobserved","Unobserved","Generated","Generated","Generated","Generated"),levels=c("Observed","Unobserved","Generated"))

WW.before <- (mean(yB[Ds==0])-mean(yB[Ds==1]))
WW.after <- (mean(yA[Ds==0])-mean(yA[Ds==1]))
BA.AT <- mean(yA[Ds==1])-mean(yB[Ds==1])
BA.Switchers <- mean(yA[Ds==0])-mean(yB[Ds==0])
Counterfactual.after <- mean(yB[Ds==0])+BA.AT
DIDr <- BA.Switchers - BA.AT 
TTASwitchers <- mean(alphaA[Ds==0])
TTBSwitchers <- mean(alphaB[Ds==0])
TTAAT <- mean(alphaA[Ds==1])
TTBAT <- mean(alphaB[Ds==1])

ggplot(data.DID.plot,aes(x=Period,y=Outcome,group=Group,color=Group,shape=Group,linetype=Observed))+
    geom_line() +
    geom_point()+
    scale_linetype_discrete(guide='none') +
    theme_bw()
```

Figure \@ref(fig:PlotDIDRev2nd) shows that DID does not work well in this example. 
Indeed, the true treatment effect among switchers after the treatment is equal to `r round(TTASwitchers,2)` in the sample, while the DID estimator is equal to `r round(DIDr,2)`.
The $DID^r$ estimator is of the wrong sign.
Why is that?
Note that the $DID^r$ estimator uses the change in outcomes among the *always treated* to approximate the change in outcome that would have occurred for the *switchers* if they have stayed outside of the treatment. 
The problem is that this approximation does not work at all: the increases in outcome for the *always treated* is much steeper than the increase in outcomes that would have happened to the *switchers* had they stayed outside of the treatment (`r round(BA.AT,2)` $>$ `r round(BA.Switchers,2)`).
As a consequence, the $DID^r$ estimator overestimates the counterfactual level that would have been reached by the *switchers* in the second period in the absence of the treatment.
Ultimately, the $DID^r$ estimator underestimates severely the effect of the treatment.
Note that the usual assumption of parallel trends does hold in this example.
The problem comes form somewhere else.
One way to understand the problems with the $DID^r$ estimator is to see that the change in treatment effects over time and between groups over time confounds the effect of the treatment. 
The only way to make the $DID^r$ estimator work is to assume these confounders away.

In order to clarify the conditions under which the $DID^r$ estimator is valid, let us state the following assumption:

```{hypothesis,ParallelTrendsy1,name="Parallel Trends in the presence of the treatment"}
We assume that the trends in the potential outcomes in the presence the treatment are the same for the treated and the untreated units:

\begin{align*}
    \esp{Y^1_{i,A}|D_i=1} - \esp{Y^1_{i,B}|D_i=1} & = \esp{Y^1_{i,A}|D_i=0} - \esp{Y^1_{i,B}|D_i=0}.
\end{align*}
```

Under Assumption \@ref(hyp:ParallelTrendsy1), we can show that the $DID^r$ estimator identifies the effect of the treatment on the *switchers* in the first period: 

```{theorem,IdentDIDr,name="DIDr identifies TUT in the first period"}
Under Assumptions \@ref(hyp:NoTreatmentFirst), \@ref(hyp:NoAnticipationEffects) and \@ref(hyp:ParallelTrendsy1), the $DID^r$ estimator identifies the average effect of the Treatment on the switchers before the treatment:

\begin{align*}
    \Delta_{DID^r}^{Y} & =  \Delta^{Y_B}_{TUT},
\end{align*}
```

with:

\begin{align*}
  \Delta^{Y_B}_{TUT} & = \esp{Y^1_{i,B}-Y^0_{i,B}|D_{i}=0}.
\end{align*}


```{proof}
\begin{align*}
  \Delta^Y_{DID^r} & = \esp{Y_{i,A}|D_i=0}-\esp{Y_{i,B}|D_i=0}-(\esp{Y_{i,A}|D_i=1}-\esp{Y_{i,B}|D_i=1}) \\
                & = \esp{Y^1_{i,A}|D_i=0}-\esp{Y^0_{i,B}|D_i=0}-(\esp{Y^1_{i,A}|D_i=1}-\esp{Y^1_{i,B}|D_i=1})\\
                & = \esp{Y^1_{i,A}|D_i=0} - \esp{Y^0_{i,B}|D_i=0}-(\esp{Y^1_{i,A}|D_i=0}-\esp{Y^1_{i,B}|D_i=0})\\
                & = \esp{Y^1_{i,B}-Y^0_{i,B}|D_i=0}
\end{align*}

where the second equality follows from Assumptions \@ref(hyp:NoTreatmentFirst) and \@ref(hyp:NoAnticipationEffects) and the switching equation, and the third equality follows from Assumption \@ref(hyp:ParallelTrendsy1).

```

Theorem \@ref(thm:IdentDIDr) shows that under an alternative assumption of parallel trends (that they hold for potential outcomes when units are in the treatment), the $DID^r$ estimator identifies the causal effect of the treatment on the *switchers* **before** the treatment takes place.

```{remark}
Note that it makes intuitive sense: the only true change is that of the *switchers* entering the treatment.
Using the *always takers*, we can only learn about the changes in potential outcomes when in the treatment.
Under Assumption \@ref(hyp:ParallelTrendsy1), the *switchers* would have experimented the same change in outcomes than the *always takers* if they have been constantly treated.
As a consequence, we can use the change in outcomes among the *always takers* to project back what would have been the outcomes of the *switchers* in the first period had they been exposed to the treatment. 
```

```{remark}
Note as well that Assumption \@ref(hyp:ParallelTrendsy1), when paired with Assumption \@ref(hyp:ParallelTrends), is actually restrictive in terms of how the treatment effects might change over time and between groups, as the following lemma shows:
```

```{lemma,ParallelTrendsCstTreatmentEffectsTime,name="Parallel Trends Restricts the Way Treatment Effects Change Over Time"}
Assumptions \@ref(hyp:ParallelTrends) and \@ref(hyp:ParallelTrendsy1) imply that *always takers* and *switchers* experience the same changes in treatment effects over time:

\begin{align*}
   \Delta^{Y_A}_{TUT}- \Delta^{Y_B}_{TUT} & = \Delta^{Y_A}_{TT}- \Delta^{Y_B}_{TT}.
\end{align*}
```

```{proof}
Substracting the parallel trends condition in Assumption \@ref(hyp:ParallelTrends) from the parallel trends condition in Assumption \@ref(hyp:ParallelTrendsy1), we have:

\begin{align*}
    \esp{Y^1_{i,A}|D_i=1} - \esp{Y^1_{i,B}|D_i=1}-(\esp{Y^0_{i,A}|D_i=1} - \esp{Y^0_{i,B}|D_i=1}) & = \esp{Y^1_{i,A}|D_i=0} - \esp{Y^1_{i,B}|D_i=0}-(\esp{Y^0_{i,A}|D_i=0} - \esp{Y^0_{i,B}|D_i=0}).
\end{align*}

After some manipulation, we get:

  \begin{align*}
    \esp{Y^1_{i,A}-Y^0_{i,A}|D_i=1} - \esp{Y^1_{i,B}-Y^0_{i,B}|D_i=1}& = \esp{Y^1_{i,A}-Y^0_{i,A}|D_i=0} - \esp{Y^1_{i,B}-Y^0_{i,B}|D_i=0},.
\end{align*}

which proves the result.

```

```{remark}
There remains a final question: are there any conditions under which we could use the $DID^r$ estimator to identify the effect of the treatment on the *switchers* after the treatment takes place?
In practice, that means that we need to recover the trends the *switchers* would have experienced had they not entered the treatment.
This puts a stark requirement on the available data because we have no information on what outcomes in the absence of the treatment would be in the second period.
One natural but also super strong assumption is to assume that the change in outcomes among the *always takers* in the presence of the treatment is the same as the one that the *switchers* would have experienced in the absence of the treatment:
```

```{hypothesis,ParallelTrendsy1y0,name="Parallel Trends for Always Takers in the Presence of the Treatment and Switchers in the Absence of the Treatment"}
We assume that the trends in the potential outcomes in the presence the treatment for the *always takers* are the same as the trends in potential outcomes in the absence of the treatment for the *switchers* :

\begin{align*}
    \esp{Y^1_{i,A}|D_i=1} - \esp{Y^1_{i,B}|D_i=1} & = \esp{Y^0_{i,A}|D_i=0} - \esp{Y^0_{i,B}|D_i=0}.
\end{align*}
```

Under Assumption \@ref(hyp:ParallelTrendsy1y0), we can recover the treatment effect on teh switchers in the second period:

```{theorem,IdentDIDry1y0,name="DIDr identifies TUT in the second period"}
Under Assumptions \@ref(hyp:NoTreatmentFirst), \@ref(hyp:NoAnticipationEffects) and \@ref(hyp:ParallelTrendsy1y0), the $DID^r$ estimator identifies the average effect of the Treatment on the switchers after the treatment:

\begin{align*}
    \Delta_{DID^r}^{Y} & =  \Delta^{Y_A}_{TUT},
\end{align*}
```

with:

\begin{align*}
  \Delta^{Y_A}_{TUT} & = \esp{Y^1_{i,A}-Y^0_{i,A}|D_{i}=0}.
\end{align*}


```{proof}
\begin{align*}
  \Delta^Y_{DID^r} & = \esp{Y_{i,A}|D_i=0}-\esp{Y_{i,B}|D_i=0}-(\esp{Y_{i,A}|D_i=1}-\esp{Y_{i,B}|D_i=1}) \\
                & = \esp{Y^1_{i,A}|D_i=0}-\esp{Y^0_{i,B}|D_i=0}-(\esp{Y^1_{i,A}|D_i=1}-\esp{Y^1_{i,B}|D_i=1})\\
                & = \esp{Y^1_{i,A}|D_i=0} - \esp{Y^0_{i,B}|D_i=0}-(\esp{Y^0_{i,A}|D_i=0}-\esp{Y^0_{i,B}|D_i=0})\\
                & = \esp{Y^1_{i,A}-Y^0_{i,A}|D_i=0}
\end{align*}

where the second equality follows from Assumptions \@ref(hyp:NoTreatmentFirst) and \@ref(hyp:NoAnticipationEffects) and the switching equation, and the third equality follows from Assumption \@ref(hyp:ParallelTrendsy1y0).

```

```{remark}
What does Assumption \@ref(hyp:ParallelTrendsy1y0) really mean?
It is unusual, but is it highly restrictive?
The following lemma helps to make sense of it:  
```

```{lemma,ParallelTrendsCstTreatmentEffects,name="Parallel Trends and Treatment Effects"}
The parallel trends assumptions restrict the way treatment effects might change over time: *(i)* Assumptions \@ref(hyp:ParallelTrends) and \@ref(hyp:ParallelTrendsy1y0) together imply the effect of the treatment is constant over time among *always takers*: $\Delta^{Y_A}_{TT} = \Delta^{Y_B}_{TT}$; *(ii)* Assumptions \@ref(hyp:ParallelTrendsy1) and \@ref(hyp:ParallelTrendsy1y0) together imply the effect of the treatment is constant over time among *switchers*: $\Delta^{Y_A}_{TUT} = \Delta^{Y_B}_{TUT}$; *(iii)* Assumptions \@ref(hyp:ParallelTrends), \@ref(hyp:ParallelTrendsy1) and \@ref(hyp:ParallelTrendsy1y0) together imply the effect of the treatment is constant over time among *switchers* and *always takers*: $\Delta^{Y_A}_{TUT} = \Delta^{Y_B}_{TUT}$ and $\Delta^{Y_A}_{TT} = \Delta^{Y_B}_{TT}$.
```

```{proof}
Substracting the parallel trends condition in Assumption \@ref(hyp:ParallelTrends) from the parallel trends condition in Assumption \@ref(hyp:ParallelTrendsy1y0), we have:

\begin{align*}
    \esp{Y^1_{i,A}|D_i=1} - \esp{Y^1_{i,B}|D_i=1}-(\esp{Y^0_{i,A}|D_i=1} - \esp{Y^0_{i,B}|D_i=1}) & = \esp{Y^0_{i,A}|D_i=0} - \esp{Y^0_{i,B}|D_i=0}-(\esp{Y^0_{i,A}|D_i=0} - \esp{Y^0_{i,B}|D_i=0}).
\end{align*}

After some manipulation, we get:

  \begin{align*}
    \esp{Y^1_{i,A}-Y^0_{i,A}|D_i=1}& = \esp{Y^1_{i,B}-Y^0_{i,B}|D_i=1}.
\end{align*}

which proves the first result.

Substracting the parallel trends condition in Assumption \@ref(hyp:ParallelTrendsy1) from the parallel trends condition in Assumption \@ref(hyp:ParallelTrendsy1y0), we have:

\begin{align*}
    \esp{Y^1_{i,A}|D_i=1} - \esp{Y^1_{i,B}|D_i=1}-(\esp{Y^1_{i,A}|D_i=1} - \esp{Y^1_{i,B}|D_i=1}) & = \esp{Y^1_{i,A}|D_i=0} - \esp{Y^1_{i,B}|D_i=0}-(\esp{Y^0_{i,A}|D_i=0} - \esp{Y^0_{i,B}|D_i=0}).
\end{align*}

After some manipulation, we get:

  \begin{align*}
    \esp{Y^1_{i,A}-Y^0_{i,A}|D_i=0}& = \esp{Y^1_{i,B}-Y^0_{i,B}|D_i=0}.
\end{align*}

which proves the second result.

The first two results imply the last one. 

```

```{remark}
It is noteworthy that combining the three assumptions together does not imply anything more than when combining them separately.
The key is that Assumptions \@ref(hyp:ParallelTrends) and \@ref(hyp:ParallelTrendsy1) together already imply that treatment effects change in the same way over time in both groups. 
Assumption \@ref(hyp:ParallelTrendsy1y0) together with Assumptions \@ref(hyp:ParallelTrends) and \@ref(hyp:ParallelTrendsy1) implies also that all potential outcomes have to change in the same way over time in  both groups.
The only way for these two properties to be true at the same time is for treatment effects in noth groups to be constant over time.
```

```{remark}
Note that Lemma \@ref(lem:ParallelTrendsCstTreatmentEffects) does not imply that treatment effects are the same in both groups. 
They do not have to be.
Assumptions \@ref(hyp:ParallelTrends), \@ref(hyp:ParallelTrendsy1) and \@ref(hyp:ParallelTrendsy1y0) allow for the treatment effects among *switchers* and always takers to be different.
```

```{remark}
A useful result is also to express the bias of the $DID^r$ estimator when only Assumption \@ref(hyp:ParallelTrends) holds.
The following lemma does the job:
```

```{lemma,BiasDIDr,name="Bias of the DIDr estimator"}
Under Assumptions \@ref(hyp:NoTreatmentFirst), \@ref(hyp:NoAnticipationEffects) and \@ref(hyp:ParallelTrends), the $DID^r$ estimator is biased for the average effect of the Treatment on the switchers before and after the treatment:

\begin{align*}
    \Delta_{DID^r}^{Y} & =  \Delta^{Y_B}_{TUT}+B^{Y_B}_{DID^r} \\
    \Delta_{DID^r}^{Y} & =  \Delta^{Y_A}_{TUT}+B^{Y_A}_{DID^r} 
\end{align*}
```

with:

\begin{align*}
    B^{Y_B}_{DID^r} & =  \Delta^{Y_A}_{TUT}-\Delta^{Y_B}_{TUT}-(\Delta^{Y_A}_{TT}-\Delta^{Y_B}_{TT})\\
    B^{Y_A}_{DID^r} & = -(\Delta^{Y_A}_{TT}-\Delta^{Y_B}_{TT}). 
\end{align*}

```{proof}
\begin{align*}
  \Delta^Y_{DID^r} & = \esp{Y_{i,A}-Y_{i,B}|D_i=0}-\esp{Y_{i,A}-Y_{i,B}|D_i=1} \\
                & = \esp{Y^1_{i,A}-Y^0_{i,B}|D_i=0}-\esp{Y^1_{i,A}-Y^1_{i,B}|D_i=1}\\
                & = \esp{Y^1_{i,A}-Y^0_{i,B}|D_i=0}-\esp{Y^1_{i,A}-Y^1_{i,B}|D_i=0}+\esp{Y^1_{i,A}-Y^1_{i,B}|D_i=0}-\esp{Y^1_{i,A}-Y^1_{i,B}|D_i=1} \\
                & = \esp{Y^1_{i,B}-Y^0_{i,B}|D_i=0}+\esp{Y^1_{i,A}-Y^1_{i,B}|D_i=0}-\esp{Y^1_{i,A}-Y^1_{i,B}|D_i=1} \\
                & = \Delta^{Y_B}_{TUT}+\esp{Y^1_{i,A}-Y^1_{i,B}|D_i=0}-\esp{Y^1_{i,A}-Y^1_{i,B}|D_i=1}\\
                & \phantom{=}-(\esp{Y^0_{i,A}-Y^0_{i,B}|D_i=0}-\esp{Y^0_{i,A}-Y^0_{i,B}|D_i=1})\\
                & = \Delta^{Y_B}_{TUT}+\Delta^{Y_A}_{TUT}-\Delta^{Y_B}_{TUT}-(\Delta^{Y_A}_{TT}-\Delta^{Y_B}_{TT})
\end{align*}

where the second equality follows from Assumptions \@ref(hyp:NoTreatmentFirst) and \@ref(hyp:NoAnticipationEffects) and the switching equation, and the fifth equality follows from Assumption \@ref(hyp:ParallelTrends).

\begin{align*}
  \Delta^Y_{DID^r} & = \esp{Y_{i,A}-Y_{i,B}|D_i=0}-\esp{Y_{i,A}-Y_{i,B}|D_i=1} \\
                & = \esp{Y^1_{i,A}-Y^0_{i,B}|D_i=0}-\esp{Y^1_{i,A}-Y^1_{i,B}|D_i=1}\\
                & = \esp{Y^1_{i,A}-Y^0_{i,B}|D_i=0}-\esp{Y^0_{i,A}-Y^0_{i,B}|D_i=0}+\esp{Y^0_{i,A}-Y^0_{i,B}|D_i=0}\\
                & \phantom{=}-\esp{Y^0_{i,A}-Y^0_{i,B}|D_i=1}+\esp{Y^0_{i,A}-Y^0_{i,B}|D_i=1}-\esp{Y^1_{i,A}-Y^1_{i,B}|D_i=1} \\
                & = \esp{Y^1_{i,A}-Y^0_{i,A}|D_i=0}+\esp{Y^0_{i,A}-Y^0_{i,B}|D_i=1}-\esp{Y^1_{i,A}-Y^1_{i,B}|D_i=1} \\
                & = \Delta^{Y_A}_{TUT}-(\esp{Y^1_{i,A}-Y^0_{i,A}|D_i=1}-\esp{Y^1_{i,B}-Y^0_{i,B}|D_i=1}) \\
                & = \Delta^{Y_A}_{TUT}-(\Delta^{Y_A}_{TT}-\Delta^{Y_B}_{TT})
\end{align*}

where the second equality follows from Assumptions \@ref(hyp:NoTreatmentFirst) and \@ref(hyp:NoAnticipationEffects) and the switching equation, and the fourth equality follows from Assumption \@ref(hyp:ParallelTrends).

```

Lemma \@ref(lem:BiasDIDr) helps to make sense of Figure \@ref(fig:PlotDIDRev2nd).
The bias of the $DID^r$ estimator for the average effect of the treatment on the *switchers* in the second period is equal to the opposite of the change in treatment effects for the *always treated* between the first and the second period.
This means that if the effect of the treatment increases over time for the *always takers*, the $DID^r$ estimator will be biased negatively.
If this negative bias is sufficiently large, it can make an altogether positive treatment effect (both on *switchers* and *always takers* at every period) look negative.
This is a very serious problem and the main reason why you want to be very careful when using the $DID^r$ estimator.
This is actually what happens in Figure \@ref(fig:PlotDIDRev2nd): the change in treatment effect over time among the *always treated* is very large (it is equal to `r round(TTAAT-TTBAT,2)`) while the treatment effect is only equal to `r round(TTASwitchers,2)`.
As a consequence, the $DID^r$ estimator is equal to `r round(DIDr,2)` whereas every average treatment effect is positive: $\hat{\Delta}^{y_A}_{TT}=$ `r round(TTAAT,2)` $\hat{\Delta}^{y_B}_{TT}=$ `r round(TTBAT,2)`, $\hat{\Delta}^{y_A}_{TUT}=$ `r round(TTASwitchers,2)` and $\hat{\Delta}^{y_B}_{TUT}=$ `r round(TTBSwitchers,2)`.

Lemma \@ref(lem:BiasDIDr) also explains why the $DID^r$ estimator is biased for the effect of the treatment in the first period.
This is because the effect of the treatment changes differently over time among *switchers* and among *always takers*.
On Figure \@ref(fig:PlotDIDRev2nd), the average treatment effect on *switchers* increases by `r round(TTASwitchers-TTBSwitchers,2)`, and it is not approximated well by the change in treatment effect among the *always takers* (`r round(TTAAT-TTBAT,2)`).
As a consequence, the $DID^r$ estimator is equal to `r round(DIDr,2)` while the average effect of the treatment on the *switchers* in the first period is equal to: $\hat{\Delta}^{y_B}_{TUT}=$ `r round(TTBSwitchers,2)`. 

```{example}
Let us now explore how the way Lemma \@ref(lem:BiasDIDr) plays out in our data.
For that, we are going to first switch off the change in treatment effects that is specific to the *always takers* in the second period.
As a case in point, we are going to set $\bar{\alpha}_{AT}=0$.
```

```{r param.DID.reverse.second.baralphaAT,eval=TRUE,echo=TRUE,results='hide'}
param["baralphaAT"] <- 0
```

Let's now simulate a dataset according to these new equations.

```{r SimulDIDRev2ndbaralphaAT0,eval=TRUE,echo=TRUE,results='hide'}
set.seed(1234)
N <- 1000
cov.eta.omega <- matrix(c(param["sigma2eta"],0,param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),
                          0,param["sigma2eta"],param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),
                          param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),param["sigma2omega"]),ncol=3,nrow=3,byrow=T)
eta.omega <- as.data.frame(mvrnorm(N,c(0,0,0),cov.eta.omega))
colnames(eta.omega) <- c('etaA','etaB','omega')
mu <- rnorm(N,param["barmu"],sqrt(param["sigma2mu"]))
UB <- rnorm(N,0,sqrt(param["sigma2U"]))
y0B <- mu + UB 
Y0B <- exp(y0B)
Ds <- rep(0,N)
V <- param["gamma"]*(mu-param["barmu"])+eta.omega$omega
Ds[y0B+V<=log(param["barY"])] <- 1 
alphaB <- param["baralphaB"]+  param["thetaB"]*mu + eta.omega$etaB
y1B <- y0B+alphaB
Y1B <- exp(y1B)
epsilonA <- rnorm(N,0,sqrt(param["sigma2epsilon"]))
U0A <- param["rho"]*UB + epsilonA
y0A <- mu +  U0A + param["delta"]
alphaA <- param["baralphaA"]+ param["baralphaAT"]*Ds+ param["thetaA"]*mu + eta.omega$etaA
y1A <- y0A+alphaA
Y0A <- exp(y0A)
Y1A <- exp(y1A)
yB <- y1B*Ds+y0B*(1-Ds)
YB <- Y1B*Ds+Y0B*(1-Ds)
yA <- y1A
YA <- Y1A
```

Let's see how DID works on this data.

```{r PlotDIDRev2ndbaralphaAT0,eval=TRUE,warning=FALSE,error=FALSE,message=FALSE,echo=TRUE,fig.cap='Evolution of average outcomes in the always treated and switchers group in the reverse DID design where everyone is treated in the second period and $\\bar{\\alpha}_{AT}=0$',fig.align='center',out.width='50%',results='hide',fig.pos='htbp'}
x <- c("Before","After")
y.AT <- c(mean(yB[Ds==1]),mean(yA[Ds==1]))
y.AT.counterfactual <- c(mean(y0B[Ds==1]),mean(y0A[Ds==1]))
y.Switchers <- c(mean(yB[Ds==0]),mean(yA[Ds==0]))
y.Switchers.counterfactual <- c(mean(y0B[Ds==0]),mean(y0A[Ds==0]))
y.Switchers.counterfactual.1 <- c(mean(y1B[Ds==0]),mean(y1A[Ds==0]))
y.Switchers.DID <- c(mean(yB[Ds==0]),mean(yB[Ds==0])+mean(yA[Ds==1])-mean(yB[Ds==1]))
y.Switchers.DID.1 <- c(mean(yA[Ds==0])-(mean(yA[Ds==1])-mean(yB[Ds==1])),mean(yA[Ds==0]))
data.DID.plot <- as.data.frame(c(y.AT,y.AT.counterfactual,y.Switchers,y.Switchers.counterfactual,y.Switchers.counterfactual.1,y.Switchers.DID,y.Switchers.DID.1))
colnames(data.DID.plot) <- c("Outcome") 
data.DID.plot$Period <- factor(rep(x,7),levels=c("Before","After"))
data.DID.plot$Group <- factor(c("Always Treated","Always Treated","Always Treated counterfactual y0","Always Treated counterfactual y0","Switchers","Switchers","Switchers counterfactual y0","Switchers counterfactual y0","Switchers counterfactual y1","Switchers counterfactual y1","Switchers DIDr","Switchers DIDr","Switchers DIDr1","Switchers DIDr1"),levels=c("Switchers","Switchers counterfactual y1","Switchers counterfactual y0","Switchers DIDr","Switchers DIDr1","Always Treated","Always Treated counterfactual y0"))
data.DID.plot$Observed <- factor(c("Observed","Observed","Unobserved","Unobserved","Observed","Observed","Unobserved","Unobserved","Unobserved","Unobserved","Generated","Generated","Generated","Generated"),levels=c("Observed","Unobserved","Generated"))

WW.before <- (mean(yB[Ds==0])-mean(yB[Ds==1]))
WW.after <- (mean(yA[Ds==0])-mean(yA[Ds==1]))
BA.AT <- mean(yA[Ds==1])-mean(yB[Ds==1])
BA.Switchers <- mean(yA[Ds==0])-mean(yB[Ds==0])
Counterfactual.after <- mean(yB[Ds==0])+BA.AT
DIDr <- BA.Switchers - BA.AT 
TTASwitchers <- mean(alphaA[Ds==0])
TTBSwitchers <- mean(alphaB[Ds==0])
TTAAT <- mean(alphaA[Ds==1])
TTBAT <- mean(alphaB[Ds==1])

ggplot(data.DID.plot,aes(x=Period,y=Outcome,group=Group,color=Group,shape=Group,linetype=Observed))+
    geom_line() +
    geom_point()+
    scale_linetype_discrete(guide='none') +
    theme_bw()
```

What is happening on Figure \@ref(fig:PlotDIDRev2ndbaralphaAT0)?
First, the $DID^r$ estimator is equal to `r round(DIDr,2)`, while the effect of the treatment on *switchers* is equal to `r round(TTASwitchers,2)` in the second period and to `r round(TTBSwitchers,2)` in the first period.
So now, the bias of the $DID^r$ is not so large as to make it reverse signs with respect to the true effect of the treatment.
It is actually almost zero for the effect on the *switchers* in the first period ($\hat{B}^{Y_B}_{DID^r}=$ `r round(DIDr-TTBSwitchers,2)`).
This is because the condition for $DID^r$ to capture the effect of the treatment on *switchers* in the first period is almost fulfilled in the data.
Lemma \@ref(lem:BiasDIDr) shows that this bias is equal to the difference in the change in teatment effect over time between the *switchers* and the *always takers*.
The change in treatment effect for the *switchers* is equal to $\hat{\Delta}^{Y_A}_{TUT}-\hat\Delta^{Y_B}_{TUT}=$ `r round(TTASwitchers-TTBSwitchers,2)` and the change in treatment effect for the *always takers* is equal to $\hat{\Delta}^{Y_A}_{TT}-\hat\Delta^{Y_B}_{TT}=$ `r round(TTAAT-TTBAT,2)`.
They are almost equal which makes $DID^r$ almost unbiased for the effect of the treatment on *switchers* in the first period.

On the contrary, the condition for $DID^r$ to capture the effect of the treatment on the *switchers* in the second period is not fulfilled in the data, not even almost.
Lemma \@ref(lem:BiasDIDr) shows that the condition for $DID^r$ to capture the effect of the treatment on the *switchers* in the second period is that the treatment effect on *always takers* be constant over time.
This is unfortunately not the case in this data, since $\hat{\Delta}^{Y_A}_{TT}-\hat\Delta^{Y_B}_{TT}=$ `r round(TTAAT-TTBAT,2)`.
The bias of the $DID^r$ estimator is thus large (and negative) for $\hat{\Delta}^{Y_A}_{TUT}$: $\hat{B}^{Y_A}_{DID^r}=$ `r round(DIDr-TTASwitchers,2)`.

```{remark}
Note that in this model, the $DID^r$ estimator is still biased for $\Delta^{Y_B}_{TUT}$.
The reasons why are left as an exercise.
```

```{example}
Let us finally explore the last condition in Lemma \@ref(lem:BiasDIDr) that makes $DID^r$ unbiased for $\Delta^{Y_A}_{TUT}$, the effect of the treatment on *switchers* in the second period.
We are going to switch off the change in treatment effects that occurs over time in both groups: we are going to set $\bar{\alpha}_{A}=\bar{\alpha}_{B}=0.1$.
```

```{r param.DID.reverse.second.baralphaAB,eval=TRUE,echo=TRUE,results='hide'}
param["baralphaA"] <- 0.1
param["baralphaB"] <- 0.1
```

Let's now simulate a dataset according to these new equations.

```{r SimulDIDRev2ndbaralphaAB0,eval=TRUE,warning=FALSE,error=FALSE,message=FALSE,echo=TRUE,results='hide'}
set.seed(1234)
N <- 1000
cov.eta.omega <- matrix(c(param["sigma2eta"],0,param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),
                          0,param["sigma2eta"],param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),
                          param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),param["sigma2omega"]),ncol=3,nrow=3,byrow=T)
eta.omega <- as.data.frame(mvrnorm(N,c(0,0,0),cov.eta.omega))
colnames(eta.omega) <- c('etaA','etaB','omega')
mu <- rnorm(N,param["barmu"],sqrt(param["sigma2mu"]))
UB <- rnorm(N,0,sqrt(param["sigma2U"]))
y0B <- mu + UB 
Y0B <- exp(y0B)
Ds <- rep(0,N)
V <- param["gamma"]*(mu-param["barmu"])+eta.omega$omega
Ds[y0B+V<=log(param["barY"])] <- 1 
alphaB <- param["baralphaB"]+  param["thetaB"]*mu + eta.omega$etaB
y1B <- y0B+alphaB
Y1B <- exp(y1B)
epsilonA <- rnorm(N,0,sqrt(param["sigma2epsilon"]))
U0A <- param["rho"]*UB + epsilonA
y0A <- mu +  U0A + param["delta"]
alphaA <- param["baralphaA"]+ param["baralphaAT"]*Ds+ param["thetaA"]*mu + eta.omega$etaA
y1A <- y0A+alphaA
Y0A <- exp(y0A)
Y1A <- exp(y1A)
yB <- y1B*Ds+y0B*(1-Ds)
YB <- Y1B*Ds+Y0B*(1-Ds)
yA <- y1A
YA <- Y1A
```

Let's see how DID works on this data.

```{r PlotDIDRev2ndbaralphaAB0,eval=TRUE,warning=FALSE,error=FALSE,message=FALSE,echo=TRUE,fig.cap='Evolution of average outcomes in the always treated and switchers group in the reverse DID design where everyone is treated in the second period and $\\bar{\\alpha}_{A}=\\bar{\\alpha}_{B}=0$',fig.align='center',out.width='50%',results='hide',fig.pos='htbp'}
x <- c("Before","After")
y.AT <- c(mean(yB[Ds==1]),mean(yA[Ds==1]))
y.AT.counterfactual <- c(mean(y0B[Ds==1]),mean(y0A[Ds==1]))
y.Switchers <- c(mean(yB[Ds==0]),mean(yA[Ds==0]))
y.Switchers.counterfactual <- c(mean(y0B[Ds==0]),mean(y0A[Ds==0]))
y.Switchers.counterfactual.1 <- c(mean(y1B[Ds==0]),mean(y1A[Ds==0]))
y.Switchers.DID <- c(mean(yB[Ds==0]),mean(yB[Ds==0])+mean(yA[Ds==1])-mean(yB[Ds==1]))
y.Switchers.DID.1 <- c(mean(yA[Ds==0])-(mean(yA[Ds==1])-mean(yB[Ds==1])),mean(yA[Ds==0]))
data.DID.plot <- as.data.frame(c(y.AT,y.AT.counterfactual,y.Switchers,y.Switchers.counterfactual,y.Switchers.counterfactual.1,y.Switchers.DID,y.Switchers.DID.1))
colnames(data.DID.plot) <- c("Outcome") 
data.DID.plot$Period <- factor(rep(x,7),levels=c("Before","After"))
data.DID.plot$Group <- factor(c("Always Treated","Always Treated","Always Treated counterfactual y0","Always Treated counterfactual y0","Switchers","Switchers","Switchers counterfactual y0","Switchers counterfactual y0","Switchers counterfactual y1","Switchers counterfactual y1","Switchers DIDr","Switchers DIDr","Switchers DIDr1","Switchers DIDr1"),levels=c("Switchers","Switchers counterfactual y1","Switchers counterfactual y0","Switchers DIDr","Switchers DIDr1","Always Treated","Always Treated counterfactual y0"))
data.DID.plot$Observed <- factor(c("Observed","Observed","Unobserved","Unobserved","Observed","Observed","Unobserved","Unobserved","Unobserved","Unobserved","Generated","Generated","Generated","Generated"),levels=c("Observed","Unobserved","Generated"))

WW.before <- (mean(yB[Ds==0])-mean(yB[Ds==1]))
WW.after <- (mean(yA[Ds==0])-mean(yA[Ds==1]))
BA.AT <- mean(yA[Ds==1])-mean(yB[Ds==1])
BA.Switchers <- mean(yA[Ds==0])-mean(yB[Ds==0])
Counterfactual.after <- mean(yB[Ds==0])+BA.AT
DIDr <- BA.Switchers - BA.AT 
TTASwitchers <- mean(alphaA[Ds==0])
TTBSwitchers <- mean(alphaB[Ds==0])
TTAAT <- mean(alphaA[Ds==1])
TTBAT <- mean(alphaB[Ds==1])

ggplot(data.DID.plot,aes(x=Period,y=Outcome,group=Group,color=Group,shape=Group,linetype=Observed))+
    geom_line() +
    geom_point()+
    scale_linetype_discrete(guide='none') +
    theme_bw()
```

Figure \@ref(fig:PlotDIDRev2ndbaralphaAB0) shows that the $DID^r$ estimator is almost OK in our setting. 
The $DID^r$ estimator is equal to `r round(DIDr,2)` while the treatment effect on the *switchers* is equal to $\hat\Delta^{Y_A}_{TUT}=$ `r round(TTASwitchers,2)` in the second period and $\hat\Delta^{Y_B}_{TUT}=$ `r round(TTBSwitchers,2)` in the first period.
There still is a difference between the estimator and the treatment effect of interest, but the difference is small enough that it might be attributed to sampling noise.
Remember that the condition for $DID^r$ to identify $\Delta^{Y_A}_{TUT}$ is Assumption \@ref(hyp:ParallelTrendsy1y0) that the trends in potential outcomes in the absence of the treatment among *switchers* is the same as the trend in potential outcomes in the presence of the treatment among *always takers*.
This is almost what we see, since the change in potential outcomes absent the treatment among switchers is equal to `r round(mean(y0A[Ds==0])-mean(y0B[Ds==0]),2)` while the change in potential outcomes under the treatment regime among *always takers* is equal to `r round(BA.AT,2)`.
The fact that these two quantities differ slightly is what biases the $DID^r$ estimator in the sample that we have generated.
Note finally that Assumption \@ref(hyp:ParallelTrendsy1y0) together with Assumption \@ref(hyp:ParallelTrends) implies that the effect of the treatment is constant over time among *always takers*, as Lemma \@ref(lem:ParallelTrendsCstTreatmentEffects) shows.
This is also the condition for the $DID^r$ estimator to identify $\Delta^{Y_A}_{TUT}$ under Assumption \@ref(hyp:ParallelTrends), as Lemma \@ref(lem:ParallelTrendsCstTreatmentEffects) shows.
Here, the effect of the treatment among always takers is equal to `r round(TTBAT,2)` in the first period and to `r round(TTAAT,2)` in the second period. 

```{remark}
Actually, the conditions for $DID^r$ to indentify any treatment effect are not fulfilled in our model.
That reasons why are left as an exercise.
```

#### DID designs where everyone is in the treatment at the first period

Compared to the setting in the previous section, the main change is to Assumption \@ref(hyp:NoTreatmentFirst):

```{hypothesis,AllTreatmentFirst,name="Everyone Receives Treatment in the First Period"}
We assume that every unit in the population receives the treatment in the first period: $D_{i,B}=1$, $\forall i$.
```

Under Assumption \@ref(hyp:AllTreatmentFirst), and without loss of generality, we can still write $D_i=D_{i,A}$.
In order for the $DID$ estimator to identify a fully-fledged treatment effect, we are going to need a pretty stark assumption:

```{hypothesis,NoEffectsAfterExit,name="No Effect After Exiting the Treatment"}
We assume that, after exiting the treatment, agents experience the same outcomes as if they had never entered the treatment: $Y_{i,A}=Y^0_{i,A}$, $\forall i$ such that $D_{i,A}=0$.
```

A consequence of Assumptions \@ref(hyp:AllTreatmentFirst) and \@ref(hyp:NoEffectsAfterExit) is that we can write observed outcomes as a function of treatment and potential outcomes using the usual switching equation.

```{remark}
Note that Assumption \@ref(hyp:NoEffectsAfterExit) is extremely restrictive: units return immediately to their outcomes in the absence of the treatment right after exiting the treatment state.
We are going to relax that assumption later.
```

The following theorem shows that $DID$ identifies a fully-fledged treatment effect under (arguably strong) assumptions:

```{theorem,DIDExit,name="DID identifies TUT in the second period"}
Under Assumptions \@ref(hyp:AllTreatmentFirst), \@ref(hyp:NoEffectsAfterExit) and \@ref(hyp:ParallelTrendsy1), the $DID$ estimator identifies the effect of the treatment on the *switchers* in the second period:

\begin{align*}
    \Delta_{DID}^{Y} & =  \Delta^{Y_A}_{TUT},
\end{align*}
```

```{proof}
\begin{align*}
  \Delta^Y_{DID} & = \esp{Y_{i,A}|D_i=1}-\esp{Y_{i,B}|D_i=1}-(\esp{Y_{i,A}|D_i=0}-\esp{Y_{i,B}|D_i=0}) \\
                & = \esp{Y^1_{i,A}|D_i=1}-\esp{Y^1_{i,B}|D_i=1}-(\esp{Y^0_{i,A}|D_i=0}-\esp{Y^1_{i,B}|D_i=0})\\
                & = \esp{Y^1_{i,A}|D_i=0}-\esp{Y^1_{i,B}|D_i=0}-(\esp{Y^0_{i,A}|D_i=0}-\esp{Y^1_{i,B}|D_i=0})\\
                & = \esp{Y^1_{i,A}-Y^0_{i,A}|D_i=0}
\end{align*}

where the second equality follows from Assumptions \@ref(hyp:AllTreatmentFirst) and \@ref(hyp:NoEffectsAfterExit) and the switching equation, and the third equality follows from Assumption \@ref(hyp:ParallelTrendsy1).

```

Invoking another (even stronger) assumption, DID identifies the effect of the treatment on *switchers* in the first period:

```{theorem,DIDExitFirst,name="DID identifies TUT in the first period"}
Under Assumptions \@ref(hyp:AllTreatmentFirst), \@ref(hyp:NoEffectsAfterExit) and \@ref(hyp:ParallelTrendsy1y0), the $DID$ estimator identifies the effect of the treatment on the *switchers* in the first period:

\begin{align*}
    \Delta_{DID}^{Y} & =  \Delta^{Y_B}_{TUT},
\end{align*}
```

```{proof}
\begin{align*}
  \Delta^Y_{DID} & = \esp{Y_{i,A}|D_i=1}-\esp{Y_{i,B}|D_i=1}-(\esp{Y_{i,A}|D_i=0}-\esp{Y_{i,B}|D_i=0}) \\
                & = \esp{Y^1_{i,A}|D_i=1}-\esp{Y^1_{i,B}|D_i=1}-(\esp{Y^0_{i,A}|D_i=0}-\esp{Y^1_{i,B}|D_i=0})\\
                & = \esp{Y^0_{i,A}|D_i=0}-\esp{Y^0_{i,B}|D_i=0}-(\esp{Y^0_{i,A}|D_i=0}-\esp{Y^1_{i,B}|D_i=0})\\
                & = \esp{Y^1_{i,B}-Y^0_{i,B}|D_i=0}
\end{align*}

where the second equality follows from Assumptions \@ref(hyp:AllTreatmentFirst) and \@ref(hyp:NoEffectsAfterExit) and the switching equation, and the third equality follows from Assumption \@ref(hyp:ParallelTrendsy1y0).

```

We can also study the bias of the DID estimator under the classical parallel trends assumption (Assumption \@ref(hyp:ParallelTrends)):

```{lemma,BiasDID,name="Bias of the DID estimator"}
Under Assumptions \@ref(hyp:AllTreatmentFirst), \@ref(hyp:NoEffectsAfterExit) and \@ref(hyp:ParallelTrends), the $DID$ estimator is biased for the average effect of the Treatment on the switchers before and after the treatment:

\begin{align*}
    \Delta_{DID}^{Y} & =  \Delta^{Y_B}_{TUT}+B^{Y_B}_{DID} \\
    \Delta_{DID}^{Y} & =  \Delta^{Y_A}_{TUT}+B^{Y_A}_{DID} 
\end{align*}
```

with:

\begin{align*}
    B^{Y_B}_{DID} & = \Delta^{Y_A}_{TT}-\Delta^{Y_B}_{TT}\\
    B^{Y_A}_{DID} & = \Delta^{Y_A}_{TT}-\Delta^{Y_B}_{TT}-(\Delta^{Y_A}_{TUT}-\Delta^{Y_B}_{TUT}). 
\end{align*}

```{proof}
\begin{align*}
  \Delta^Y_{DID} & = \esp{Y_{i,A}-Y_{i,B}|D_i=1}-\esp{Y_{i,A}-Y_{i,B}|D_i=0} \\
                & = \esp{Y^1_{i,A}-Y^1_{i,B}|D_i=1}-\esp{Y^0_{i,A}-Y^1_{i,B}|D_i=0}\\
                & = \esp{Y^1_{i,A}-Y^1_{i,B}|D_i=1}-\esp{Y^0_{i,A}-Y^0_{i,B}|D_i=1}+\esp{Y^0_{i,A}-Y^0_{i,B}|D_i=0}-\esp{Y^0_{i,A}-Y^1_{i,B}|D_i=0} \\
                & = \esp{Y^1_{i,B}-Y^0_{i,B}|D_i=0}+ \esp{Y^1_{i,A}-Y^1_{i,B}-(Y^0_{i,A}-Y^0_{i,B})|D_i=1}
                & = \Delta^{Y_B}_{TUT}+\Delta^{Y_A}_{TT}-\Delta^{Y_B}_{TT},
\end{align*}

where the second equality follows from Assumptions \@ref(hyp:AllTreatmentFirst), \@ref(hyp:NoEffectsAfterExit) and the switching equation, and the third equality follows from Assumption \@ref(hyp:ParallelTrends).

\begin{align*}
  \Delta^Y_{DID} & = \esp{Y_{i,A}-Y_{i,B}|D_i=1}-\esp{Y_{i,A}-Y_{i,B}|D_i=0} \\
                & = \esp{Y^1_{i,A}-Y^1_{i,B}|D_i=1}-\esp{Y^0_{i,A}-Y^1_{i,B}|D_i=0}\\
                & = \esp{Y^1_{i,A}-Y^1_{i,B}|D_i=1}-\esp{Y^1_{i,A}-Y^1_{i,B}|D_i=0}+\esp{Y^1_{i,A}-Y^1_{i,B}|D_i=0}-\esp{Y^0_{i,A}-Y^1_{i,B}|D_i=0}\\
                & = \esp{Y^1_{i,A}-Y^0_{i,A}|D_i=0}+\esp{Y^1_{i,A}-Y^1_{i,B}|D_i=1}-\esp{Y^1_{i,A}-Y^1_{i,B}|D_i=0} \\
                & = \Delta^{Y_A}_{TUT}+\esp{Y^1_{i,A}-Y^1_{i,B}|D_i=1}-\esp{Y^1_{i,A}-Y^1_{i,B}|D_i=0}\\
                & \phantom{=} -\esp{Y^0_{i,A}-Y^0_{i,B}|D_i=1}+\esp{Y^0_{i,A}-Y^0_{i,B}|D_i=0} \\
                & = \Delta^{Y_A}_{TUT}+\Delta^{Y_A}_{TT}-\Delta^{Y_B}_{TT}-(\Delta^{Y_A}_{TUT}-\Delta^{Y_B}_{TUT}),
\end{align*}

where the second equality follows from Assumptions \@ref(hyp:AllTreatmentFirst), \@ref(hyp:NoEffectsAfterExit) and the switching equation, and the fifth equality follows from Assumption \@ref(hyp:ParallelTrends).

```

```{example}
Let us generate data in our example model that complies with Assumptions \@ref(hyp:AllTreatmentFirst) and \@ref(hyp:NoEffectsAfterExit).
```

\begin{align*}
y_{i,A}^1 & = y_{i,A}^0+\bar{\alpha}_A+\bar{\alpha}_{AT}D_{i,A}+\theta_A\mu_i+\eta_{i,A} \\
y_{i,A}^0 & = \mu_i+\delta+U_{i,A}^0 \\
U_{i,A}^0 & = \rho U_{i,B}+\epsilon_{i,A} \\
y^1_{i,B} & =y^0_{i,B} + \bar{\alpha}_B+\theta_B\mu_i+\eta_{i,B} \\
y^0_{i,B} & =\mu_i+U_{i,B} \\
U_{i,B} & \sim\mathcal{N}(0,\sigma^2_{U}) \\
D_{i,A}   & = \uns{y^0_{i,B}+ V_i\leq\bar{y}} \\
V_i   & = \gamma(\mu_i-\bar{\mu}) + \omega_i \\
(\eta_{i,A},\eta_{i,B},\omega_i) & \sim\mathcal{N}(0,0,0,\sigma^2_{\eta},\sigma^2_{\eta},\sigma^2_{\omega},0,\rho_{\eta,\omega})
\end{align*}

```{r param.DID.reverse,eval=TRUE,warning=FALSE,error=FALSE,message=FALSE,echo=TRUE,results='hide'}
param <- c(8,.5,.28,1500,0.9,0.01,0.01,0.05,0.05,0.05,0.2,0.1,0.3,0.1,0.28,0)
names(param) <- c("barmu","sigma2mu","sigma2U","barY","rho","thetaA","thetaB","sigma2epsilon","sigma2eta","delta","baralphaA","baralphaB","baralphaAT","gamma","sigma2omega","rhoetaomega")
```

```{r SimulDIDRev,eval=TRUE,warning=FALSE,error=FALSE,message=FALSE,echo=TRUE,results='hide'}
set.seed(1234)
N <- 1000
cov.eta.omega <- matrix(c(param["sigma2eta"],0,param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),
                          0,param["sigma2eta"],param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),
                          param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),param["sigma2omega"]),ncol=3,nrow=3,byrow=T)
eta.omega <- as.data.frame(mvrnorm(N,c(0,0,0),cov.eta.omega))
colnames(eta.omega) <- c('etaA','etaB','omega')
mu <- rnorm(N,param["barmu"],sqrt(param["sigma2mu"]))
UB <- rnorm(N,0,sqrt(param["sigma2U"]))
y0B <- mu + UB 
Y0B <- exp(y0B)
Ds <- rep(0,N)
V <- param["gamma"]*(mu-param["barmu"])+eta.omega$omega
Ds[y0B+V<=log(param["barY"])] <- 1 
alphaB <- param["baralphaB"]+  param["thetaB"]*mu + eta.omega$etaB
y1B <- y0B+alphaB
Y1B <- exp(y1B)
epsilonA <- rnorm(N,0,sqrt(param["sigma2epsilon"]))
U0A <- param["rho"]*UB + epsilonA
y0A <- mu +  U0A + param["delta"]
alphaA <- param["baralphaA"]+ param["baralphaAT"]*Ds+ param["thetaA"]*mu + eta.omega$etaA
y1A <- y0A+alphaA
Y0A <- exp(y0A)
Y1A <- exp(y1A)
yA <- y1A*Ds+y0A*(1-Ds)
YA <- Y1A*Ds+Y0A*(1-Ds)
yB <- y1B
YB <- Y1B
```

Let's see how DID works on this data.

```{r PlotDIDRev,eval=TRUE,warning=FALSE,error=FALSE,message=FALSE,echo=TRUE,fig.cap='Evolution of average outcomes in the always treated and switchers group in the reverse DID design where everyone is treated in the first period',fig.align='center',out.width='50%',results='hide',fig.pos='htbp'}
x <- c("Before","After")
y.AT <- c(mean(yB[Ds==1]),mean(yA[Ds==1]))
y.AT.counterfactual <- c(mean(y0B[Ds==1]),mean(y0A[Ds==1]))
y.Switchers <- c(mean(yB[Ds==0]),mean(yA[Ds==0]))
y.Switchers.counterfactual <- c(mean(y0B[Ds==0]),mean(y0A[Ds==0]))
y.Switchers.counterfactual.1 <- c(mean(y1B[Ds==0]),mean(y1A[Ds==0]))
y.Switchers.DID <- c(mean(yB[Ds==0]),mean(yB[Ds==0])+mean(yA[Ds==1])-mean(yB[Ds==1]))
y.Switchers.DID.1 <- c(mean(yA[Ds==0])-(mean(yA[Ds==1])-mean(yB[Ds==1])),mean(yA[Ds==0]))
data.DID.plot <- as.data.frame(c(y.AT,y.AT.counterfactual,y.Switchers,y.Switchers.counterfactual,y.Switchers.counterfactual.1,y.Switchers.DID,y.Switchers.DID.1))
colnames(data.DID.plot) <- c("Outcome") 
data.DID.plot$Period <- factor(rep(x,7),levels=c("Before","After"))
data.DID.plot$Group <- factor(c("Always Treated","Always Treated","Always Treated counterfactual y0","Always Treated counterfactual y0","Switchers","Switchers","Switchers counterfactual y0","Switchers counterfactual y0","Switchers counterfactual y1","Switchers counterfactual y1","Switchers DIDr","Switchers DIDr","Switchers DIDr1","Switchers DIDr1"),levels=c("Switchers","Switchers counterfactual y1","Switchers counterfactual y0","Switchers DIDr","Switchers DIDr1","Always Treated","Always Treated counterfactual y0"))
data.DID.plot$Observed <- factor(c("Observed","Observed","Unobserved","Unobserved","Observed","Observed","Unobserved","Unobserved","Unobserved","Unobserved","Generated","Generated","Generated","Generated"),levels=c("Observed","Unobserved","Generated"))

WW.before <- (mean(yB[Ds==1])-mean(yB[Ds==0]))
WW.after <- (mean(yA[Ds==1])-mean(yA[Ds==0]))
BA.AT <- mean(yA[Ds==1])-mean(yB[Ds==1])
BA.Switchers <- mean(yA[Ds==0])-mean(yB[Ds==0])
Counterfactual.after <- mean(yB[Ds==0])+BA.AT
DID <- BA.AT  - BA.Switchers
TTASwitchers <- mean(alphaA[Ds==0])
TTBSwitchers <- mean(alphaB[Ds==0])
TTAAT <- mean(alphaA[Ds==1])
TTBAT <- mean(alphaB[Ds==1])

ggplot(data.DID.plot,aes(x=Period,y=Outcome,group=Group,color=Group,shape=Group,linetype=Observed))+
    geom_line() +
    geom_point()+
    scale_linetype_discrete(guide='none') +
    theme_bw()
```

In Figure \@ref(fig:PlotDIDRev), the effect of the treatment on the *switchers* is equal to $\hat\Delta^{y_A}_{TUT}=$ `r round(TTASwitchers,2)` in the second period and to $\hat\Delta^{y_B}_{TUT}=$ `r round(TTBSwitchers,2)` in the first period.
The $DID$ estimator is equal to $\hat\Delta^{y}_{DID}=$ `r round(DID,2)` which is of the correct sign but much too big for both treatment effects.
The problem is that the change in the outcomes of the *always treated* (`r round(BA.AT,2)`) overestimates the change in outcomes the *switchers* would have experienced had they stayed in the treatment  (`r round(mean(y1A[Ds==0])-mean(y1B[Ds==0]),2)`).
As a consequence, Assumption \@ref(hyp:ParallelTrendsy1) is not valid and the DID estimator is biased.
Following Lemma \@ref(lem:BiasDID), the bias of the DID estimator for the effect on the *switchers* in the second period is equal to the difference in the change of treatment effect over time between *always treated* ($\hat\Delta^{Y_A}_{TT}-\Delta^{Y_B}_{TT}=$ `r round(TTAAT,2)` $-$ `r round(TTBAT,2)` $=$ `r round(TTAAT - TTBAT,2)`) and *switchers* ($\hat\Delta^{Y_A}_{TUT}-\hat\Delta^{Y_B}_{TUT}=$ `r round(TTASwitchers,2)` $-$ `r round(TTBSwitchers,2)` $=$ `r round(TTASwitchers - TTBSwitchers,2)`).
The bias of the DID estimator for the effect of the treatment on the *switchers* in the first period is even larger ($\hat B^{y_B}_{DID}=$ `r round(DID-TTBSwitchers,2)`).
Following Lemma \@ref(lem:BiasDID), it is close to the change in treatment effect over time among the *switchers* ($\hat\Delta^{Y_A}_{TT}-\hat\Delta^{Y_B}_{TT}=$ `r round(TTAAT,2)` $-$ `r round(TTBAT,2)` $=$ `r round(TTAAT - TTBAT,2)`).

```{example}
What happens if we enforce the fact that treatment effects vary in the same way among *always takers* and *switchers*.
Let's find out.
```

```{r param.shut.down.ATD,eval=TRUE,echo=TRUE,results='hide'}
param["baralphaAT"] <- 0
```

Let's simulate the new data:

```{r SimulDIDRevShutDown,eval=TRUE,warning=FALSE,error=FALSE,message=FALSE,echo=TRUE,results='hide'}
set.seed(1234)
N <- 1000
cov.eta.omega <- matrix(c(param["sigma2eta"],0,param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),
                          0,param["sigma2eta"],param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),
                          param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),param["sigma2omega"]),ncol=3,nrow=3,byrow=T)
eta.omega <- as.data.frame(mvrnorm(N,c(0,0,0),cov.eta.omega))
colnames(eta.omega) <- c('etaA','etaB','omega')
mu <- rnorm(N,param["barmu"],sqrt(param["sigma2mu"]))
UB <- rnorm(N,0,sqrt(param["sigma2U"]))
y0B <- mu + UB 
Y0B <- exp(y0B)
Ds <- rep(0,N)
V <- param["gamma"]*(mu-param["barmu"])+eta.omega$omega
Ds[y0B+V<=log(param["barY"])] <- 1 
alphaB <- param["baralphaB"]+  param["thetaB"]*mu + eta.omega$etaB
y1B <- y0B+alphaB
Y1B <- exp(y1B)
epsilonA <- rnorm(N,0,sqrt(param["sigma2epsilon"]))
U0A <- param["rho"]*UB + epsilonA
y0A <- mu +  U0A + param["delta"]
alphaA <- param["baralphaA"]+ param["baralphaAT"]*Ds+ param["thetaA"]*mu + eta.omega$etaA
y1A <- y0A+alphaA
Y0A <- exp(y0A)
Y1A <- exp(y1A)
yA <- y1A*Ds+y0A*(1-Ds)
YA <- Y1A*Ds+Y0A*(1-Ds)
yB <- y1B
YB <- Y1B
```

Let's see how DID works on this data.

```{r PlotDIDRevShutDown,eval=TRUE,warning=FALSE,error=FALSE,message=FALSE,echo=TRUE,fig.cap='Evolution of average outcomes in the always treated and switchers group in the reverse DID design where everyone is treated in the first period and treatment effects that vary in the same way among switchers and always takers',fig.align='center',out.width='50%',results='hide',fig.pos='htbp'}
x <- c("Before","After")
y.AT <- c(mean(yB[Ds==1]),mean(yA[Ds==1]))
y.AT.counterfactual <- c(mean(y0B[Ds==1]),mean(y0A[Ds==1]))
y.Switchers <- c(mean(yB[Ds==0]),mean(yA[Ds==0]))
y.Switchers.counterfactual <- c(mean(y0B[Ds==0]),mean(y0A[Ds==0]))
y.Switchers.counterfactual.1 <- c(mean(y1B[Ds==0]),mean(y1A[Ds==0]))
y.Switchers.DID <- c(mean(yB[Ds==0]),mean(yB[Ds==0])+mean(yA[Ds==1])-mean(yB[Ds==1]))
y.Switchers.DID.1 <- c(mean(yA[Ds==0])-(mean(yA[Ds==1])-mean(yB[Ds==1])),mean(yA[Ds==0]))
data.DID.plot <- as.data.frame(c(y.AT,y.AT.counterfactual,y.Switchers,y.Switchers.counterfactual,y.Switchers.counterfactual.1,y.Switchers.DID,y.Switchers.DID.1))
colnames(data.DID.plot) <- c("Outcome") 
data.DID.plot$Period <- factor(rep(x,7),levels=c("Before","After"))
data.DID.plot$Group <- factor(c("Always Treated","Always Treated","Always Treated counterfactual y0","Always Treated counterfactual y0","Switchers","Switchers","Switchers counterfactual y0","Switchers counterfactual y0","Switchers counterfactual y1","Switchers counterfactual y1","Switchers DIDr","Switchers DIDr","Switchers DIDr1","Switchers DIDr1"),levels=c("Switchers","Switchers counterfactual y1","Switchers counterfactual y0","Switchers DIDr","Switchers DIDr1","Always Treated","Always Treated counterfactual y0"))
data.DID.plot$Observed <- factor(c("Observed","Observed","Unobserved","Unobserved","Observed","Observed","Unobserved","Unobserved","Unobserved","Unobserved","Generated","Generated","Generated","Generated"),levels=c("Observed","Unobserved","Generated"))

WW.before <- (mean(yB[Ds==1])-mean(yB[Ds==0]))
WW.after <- (mean(yA[Ds==1])-mean(yA[Ds==0]))
BA.AT <- mean(yA[Ds==1])-mean(yB[Ds==1])
BA.Switchers <- mean(yA[Ds==0])-mean(yB[Ds==0])
Counterfactual.after <- mean(yB[Ds==0])+BA.AT
DID <- BA.AT  - BA.Switchers
TTASwitchers <- mean(alphaA[Ds==0])
TTBSwitchers <- mean(alphaB[Ds==0])
TTAAT <- mean(alphaA[Ds==1])
TTBAT <- mean(alphaB[Ds==1])

ggplot(data.DID.plot,aes(x=Period,y=Outcome,group=Group,color=Group,shape=Group,linetype=Observed))+
    geom_line() +
    geom_point()+
    scale_linetype_discrete(guide='none') +
    theme_bw()
```
As expected from Theorem \@ref(thm:DIDExit), Figure \@ref(fig:PlotDIDRevShutDown) shows that DID almost estimates the effect of the treatment on the *switchers* in the second period.
This makes sense, since the change in outcomes for the *switchers* in the presence of the treatment (`r round(mean(y1A[Ds==0])-mean(y1B[Ds==0]),2)`) is well approximated by the observed change in outcomes for the *always treated* (`r round(BA.AT,2)`).
According to Lemma \@ref(lem:BiasDID), this is because the change in treatment effect over time for the *always treated* ($\hat\Delta^{Y_A}_{TT}-\Delta^{Y_B}_{TT}=$ `r round(TTAAT,2)` $-$  `r round(TTBAT,2)` $=$ `r round(TTAAT - TTBAT,2)`) is close to the change in treatment effect over time for the *switchers* ($\hat\Delta^{Y_A}_{TUT}-\hat\Delta^{Y_B}_{TUT}=$ `r round(TTASwitchers,2)` $-$ `r round(TTBSwitchers,2)` $=$ `r round(TTASwitchers - TTBSwitchers,2)`).
Note that the DID estimator is still biased for the effect of the treatment on the *switchers* in the first period, because the treatment effect on the *always takers* changes over time (Lemma \@ref(lem:BiasDID)).

```{remark}
Note that in this model, DID does not identify $\Delta^{Y_A}_{TUT}$.
The reasons why are left as an exercise.
```

```{remark}
We can relax Assumption \@ref(hyp:NoEffectsAfterExit) by redefining the potential outcomes observed after the *switchers* exit from the treatment as the potential outcomes observed when the treatment stops after having been experienced.
One way to parameterize this potential outcome is to make it a function of the time elapsed since exiting the treatment: $Y^0_{i,t}(\tau)$, where $\tau$ denotes the number of periods after exiting the treatment. 
For the *switchers*, in period $A$, $\tau=1$, for example.
One can then show that the DID estimator identifies the effect of the treatment relative to exiting the treatment: $\Delta^Y_{DID}=\esp{Y^1_{i,A}-Y^0_{i,A}(1)|D_i=0}$ under Assumptions \@ref(hyp:AllTreatmentFirst) and \@ref(hyp:ParallelTrendsy1).
The proof is left as an exercise.
```

### Difference In Differences with multiple time periods

In real life, we generally have access to several time periods before and after the treatment date.
What happens to DID in that case?
Well, several things actually happen:

  1. We now have several pre-treatment observations for each unit.
  Which one should we choose to form our DID estimator?
  If we use all of them, should we combine them?
  If yes, how?
  2. We also have several post-treatment observations.
  Which one should we choose to form our DID estimator?
  If we use all of them, should we combine them?
  If yes, how?
  3. We also have some units that will be treated for several periods in a row.
  Should we use them to form a $DID^r$ estimator?
  If yes, should we combine them with the DID estimates?
  If yes, how?
  4. We also might have some units that exit the treatment after some time.
  Should we use them to form a DID estimator?
  Should we combine this estimate with the others?
  If yes, how?
  
There is a lot of questions. 
In order to be able to answer them, I am for the moment going to abstract from the last one.
I am going to assume that once a unit has entered the treatment, it cannot exit it.
DID designs such as these are called *staggered designs*.
This is obviously a very strong assumption, but we will relax it at some point.
Let's go now.

#### Identification

In this section, we are going to define rigorously the setting that we have in front of us and the several treatment effects that we might want to estimate.
This will be the most important part of the identification exercise.
Once the definitions are in place, identification will be mostly straightforward.

In a DID design with multiple time periods, time flows from $t=1$ to $t=T$.
$D_{i,t}$ takes value one when unit $i$ is treated at period $t$ and zero otherwise. 
In a staggered design, once treated, a unit is treated forever (the treatment is said to be an absorbing state).
As a consequence, we can characterize units by the date at which they start to be treated.
We are going to call this variable $D_{i}$ and it takes values in the set $\left\{1,2,\dots,T,\infty\right\}$.
Units treated at period $1$ (or even before, we cannot say for sure) are *always treated* in a staggered design.
Then, units enter at successive periods until the last one.
Finally, some units may never receive the treatment (*never takers*).
By convention, we denote them with $D_{i}=\infty$.

We can define a separate treatment effect for each of the treatment groups and for each time period: $\Delta^{Y_{\tau}}_{TT_d}=\esp{Y^1_{i,d+\tau}-Y^0_{i,d+\tau}|D_i=d}$, for $\tau,d\in\left\{1,2,\dots,T\right\}$.

We can also form a very large bunch of DID estimators: 

\begin{align*}
  \Delta^{Y}_{DID}(d,d',\tau,\tau') & = \esp{Y_{i,d+\tau}|D_i=d}-\esp{Y_{i,d-\tau'}|D_i=d}-(\esp{Y_{i,d+\tau}|D_i=d'}-\esp{Y_{i,d-\tau'}|D_i=d'}),
\end{align*}

where $\tau,\tau'>0$ and $d'>d+\tau$. 
$\Delta^{Y}_{DID}(d,d',\tau,\tau')$ tries to estimate the effect of the treatment on units that first entered the treatment at period $t=d$ (the treated group here) using the units that received the treatment at period $d'>d$ as a benchmark.
$\Delta^{Y}_{DID}(d,d',\tau,\tau')$ compares how outcomes have changed between $\tau$ periods after the treatment and $\tau'$ periods before the treatment.

Imposing $d'>d+\tau$ ensures that $\Delta^{Y}_{DID}(d,d',\tau,\tau')$ is a proper DID estimator.
If $d-\tau'<d'<d+\tau$, $\Delta^{Y}_{DID}(d,d',\tau,\tau')$ is not a proper DID estimator since units in group $d'$ also receive the treatment between the two dates at which outcomes are measured.
When $d'<d-\tau'$, $\Delta^{Y}_{DID}(d,d',\tau,\tau')$ compares the change in outcomes in the group entering the treatment at date $d$ with the changes in outcomes occurring in a group that has already entered the treatment at a date $d'$ that is prior the starting date of the DID.
Since this estimator is a $DID^r$ estimator, I am going to denote it as such in the future.
$\Delta^{Y}_{DID^r}(d,d',\tau,\tau')$ is well-defined only when $d'<d-\tau'$.

Before stating our first identification result, let us make some assumptions that will mirror the simpler ones we made in the previous section.
First, we are going to assume that at least some units are untreated at some period:

```{hypothesis,NoTreatmentTime,name="Some Units are Not Treated"}
We assume that not all units in the population are treated in the first period: $\Pr(D_i=1)<1$.
```

Next, we assume that agents cannot anticipate the treatment:

```{hypothesis,NoAnticipationEffectsTime,name="No Anticipation Effects over Time"}
We assume that agents cannot anticipate that the program will happen and that they do not change their behavior as a consequence: $Y_{i,t}=Y^0_{i,t}$, $\forall i\in \left\{i:D_i=d\right\}$, $\forall t<d$.
```

As a consequence of Assumptions \@ref(hyp:NoTreatmentTime) and \@ref(hyp:NoAnticipationEffectsTime), we can write observed outcomes as a function of treatment and potential outcomes using the usual switching equation.

The final very important assumption that we can make is to assume that the trends in the potential outcomes in the absence the treatment are the same for the treated and the untreated units:

```{hypothesis,ParallelTrendsTime,name="Parallel Trends for All Groups"}
We assume that the trends in the potential outcomes in the absence the treatment are the same for all the treatment groups:

\begin{align*}
   \forall d,t,t'\in\left\{1,2,\dots,T\right\} & = \esp{Y^0_{i,t}|D_i=d} - \esp{Y^0_{i,t'}|D_i=d} =   \esp{Y^0_{i,t}|D_i=\infty} - \esp{Y^0_{i,t'}|D_i=\infty}.
\end{align*}
```

We are now ready to state our main identification result:

```{theorem,IdentDIDTime,name="DID identifies TT at Each Point in Time"}
Under Assumptions \@ref(hyp:NoTreatmentTime), \@ref(hyp:NoAnticipationEffectsTime) and \@ref(hyp:ParallelTrendsTime), the DID estimator identifies the average effect of the Treatment on the Treated in each time period:

\begin{align*}
    \Delta^{Y}_{DID}(d,d',\tau,\tau') & =  \Delta^{Y_{\tau}}_{TT_d},
\end{align*}
where $\tau,\tau'>0$ and $d'>d+\tau$. 
```

```{proof}
\begin{align*}
  \Delta^{Y}_{DID}(d,d',\tau,\tau') & = \esp{Y_{i,d+\tau}-Y_{i,d-\tau'}|D_i=d}-\esp{Y_{i,d+\tau}-Y_{i,d-\tau'}|D_i=d'}\\
                                    & = \esp{Y^1_{i,d+\tau}-Y^0_{i,d-\tau'}|D_i=d}-\esp{Y^0_{i,d+\tau}-Y^0_{i,d-\tau'}|D_i=d'}\\
                                    & = \esp{Y^1_{i,d+\tau}-Y^0_{i,d-\tau'}|D_i=d}-\esp{Y^0_{i,d+\tau}-Y^0_{i,d-\tau'}|D_i=d}\\
                                    & = \esp{Y^1_{i,d+\tau}-Y^0_{i,d+\tau}|D_i=d}
\end{align*}

where the second equality follows from Assumptions \@ref(hyp:NoTreatmentTime) and \@ref(hyp:NoAnticipationEffectsTime) and the fact that $d'>d+\tau$.
The third equality follows from Assumption \@ref(hyp:ParallelTrendsTime).
This proves the result.

```

Theorem \@ref(thm:IdentDIDTime) shows that the basic mechanics of the DID estimator extends to multiple periods. 
The problem with Theorem \@ref(thm:IdentDIDTime) is that we now have multiple ATT estimates for various groups and time periods, using various time periods and groups as reference.
How do we reconcile all of these estimates in a unique parameter, or at least a vector of parameters that makes some sense?
Let's define sets of positive weights $w^k(d,d',\tau,\tau')$ that sum to one. 
We can then define a set of DID estimators:

\begin{align*}
  \Delta^{Y}_{DID}(k)=\sum w^k(d,d',\tau,\tau')\Delta^{Y}_{DID}(d,d',\tau,\tau'),
\end{align*}

where the sum is taken in coherence with the weights.
These DID estimators are going to identify various features of the effects of the treatment, using various types of reference groups and time periods.
Let us be more precise:

  1. A first set of weights combines the various estimates of the same treatment effect on the outcomes of group $d$ observed at period $d=\tau$. 
  These weights, which we denote $w^s_{d,\tau}(d',\tau')$, are such that they take value zero for estimates $\Delta^{Y}_{DID}(d'',d',\tau'',\tau')$ that are such $d''\neq d$ and $\tau''\neq\tau$ and they have: $\sum_{\tau',d'>d+\tau}w^s_{d,\tau}(d',\tau')=1$. 
  One way to define these weights is to make them proportional to the proportion of $(d',\tau')$ groups of observations in the population.
  2. A second set of weights is going to combine the treatment effects themselves.
  For example, one might want to measure the average effect of the treatment $\tau$ periods after entering it.
  This type of dynamic treatment effect is useful to measure how the effect of the treatment varies over time.
  There are two versions of this set of weights: one unconditional and one conditional on at least reaching a certain number of periods in the treatment (let's say $\tau''>\tau$ periods after the treatment).
  With the second version, all the estimates of the dynamic effects of the treatment are going to be taken over the same set of groups.
  With the first version, changes in treatment effects over time might be confounded by changes in group composition. 
  Let's denote the first type of weights $w^u_{\tau}(d,d',\tau')$ and the second $w^c_{\tau,\tau''}(d,d',\tau')$ , with $\tau''>\tau$.
  We then have $\Delta^{Y_u}_{DID}(\tau)=\sum_{d,d'>d+\tau,\tau'} w^u_{\tau}(d,d',\tau')\Delta^{Y}_{DID}(d,d',\tau,\tau')$ and $\Delta^{Y_c}_{DID}(\tau,\tau'')=\sum_{d,d'>d+\tau,\tau'} w^c_{\tau,\tau''}(d,d',\tau')\Delta^{Y}_{DID}(d,d',\tau,\tau')$.
  These effects can also be restricted to versions using a single reference period $\tau'$ to build the DID estimator: $\Delta^{Y_u}_{DID}(\tau,\tau')$ and $\Delta^{Y_c}_{DID}(\tau,\tau',\tau'')$.
  3. A third set of effects is simply taking the average of all the treatment effects at a given time period. 
  Let's denote these set of weights $w^t(d,d',\tau,\tau')$ for the effect observed at period $t$.
  Then, we have $\Delta^{Y_t}_{DID}=\sum_{\tau+d=t,d'>d+\tau,\tau'} w^t(d,d',\tau,\tau')\Delta^{Y}_{DID}(d,d',\tau,\tau')$.
  Another version again uses only estimates taken with period $d-\tau'$ as a reference: $\Delta^{Y_t}_{DID}(\tau')=\sum_{\tau+d=t,d'>d+\tau} w^t_{\tau'}(d,d',\tau)\Delta^{Y}_{DID}(d,d',\tau,\tau')$.
  4. Finally, one can simply define the overall effect of the treatment on the treated as the sum of all relevant treatment effects estimated in the sample.
  Let's define the set of weights $w^a(d,d',\tau,\tau')$ and the estimate of the average treatment effect on the treated as $\Delta^{Y}_{DID}=\sum_{\tau,d,d'>d+\tau,\tau'} w^a(d,d',\tau,\tau')\Delta^{Y}_{DID}(d,d',\tau,\tau')$.
  Again, some authors restrict this estimate to be specific to a given reference period: $\Delta^{Y}_{DID}(\tau')=\sum_{\tau,d,d'>d+\tau} w^a_{\tau'}(d,d',\tau)\Delta^{Y}_{DID}(d,d',\tau,\tau')$.
  
As a consequence of Theorem \@ref(thm:IdentDIDTime), all the aggregate treatment effects are identified, as long as each of their separate components are identified. 
The following corollary makes that clear:

```{corollary,IdentDIDAgg,name="DID identifies Weighted TT"}
Under Assumptions \@ref(hyp:NoTreatmentTime), \@ref(hyp:NoAnticipationEffectsTime) and \@ref(hyp:ParallelTrendsTime), assuming that $\Pr(D_i=d)>0$ and $\Pr(D_i=d')>0$, $\forall (d,d')\in \left\{1,2,\dots,T,\infty\right\}$ such that $w^k(d,d',\tau,\tau')>0$ and assuming that $\forall d,d',\tau,\tau'$ such that $w^k(d,d',\tau,\tau')>0$, $(d+\tau,d'-\tau')\in\left\{1,2,\dots,T,\infty\right\}^2$, the weighted DID estimator identifies the corresponding weigthed average of Treatment on the Treated:

\begin{align*}
    \Delta^{Y}_{DID}(k) & =  \Delta^{Y}_{TT}(k),
\end{align*}
with 
\begin{align*}
    \Delta^{Y}_{TT}(k) & = \sum w^k(d,d',\tau,\tau')\Delta^{Y_{\tau}}_{TT_d}
\end{align*}
```

```{proof}
The proof follows from Theorem \@ref(thm:IdentDIDTime): as long as the groups for which the weights are non null exist, and the time periods for which the weights are non null also exist in the data, Theorem \@ref(thm:IdentDIDTime) ensures that each of the components of the weighted average is identifed and thus the weighted average is identified as well.
```

Before going through an example to illustrate all of these notions, let me introduce one estimator.

#### Estimation

Estimation of the various DID estimators that we have defined in the previous section can take several forms.
The simplest form estimates the separate individual DID components using the methods seen in Section \@ref(DIDbasic), and then manually computes their weighted averages. 
This approach has been proposed by [Sun and Abraham (2021)](https://www.sciencedirect.com/science/article/pii/S030440762030378X) and by [Callaway and Sant'Anna (2021)](https://www.sciencedirect.com/science/article/pii/S0304407620303948). 
A more intricate approach uses an imputation model to derive the predicted counterfactual values for all treated observations and then averages them.
This approach has been proposed by [Borusyak, Jaravel and Speiss (2021)](http://arxiv.org/abs/2108.12419).
[de Chaisemartin and d'Haultfoeuille](https://www.aeaweb.org/articles?id=10.1257/aer.20181169) propose to only use changes that occur around the treatment date.
Finally, one could use the Two Way Fixed Effects model presented in Section \@ref(DIDbasic), combining all the time periods in a single estimator.
Recent work by [Goodman-Bacon](https://www.sciencedirect.com/science/article/pii/S0304407621001445) has shown that this approach is only valid under much more restrictive assumptions than the ones stated in Corollary \@ref(cor:IdentDIDAgg).
The main reason for why is that the Two Way Fixed Effects estimator combines individual DID and $DID^r$ estimates, thereby generating strong biases if the assumptions that ensure the validity of $DID^r$ are not valid. 
An extension to the Two Way Fixed Effects estimator, the stacked DID estimator, restores its good properties.
It has been proposed by [Cengiz, Dube, Lindner and Zipperer (2019)](https://academic.oup.com/qje/article/134/3/1405/5484905) and extended by [Gardner (2021)](https://jrgcmu.github.io/2sdd_current.pdf) who also proposes an imputation estimator * la* Borusyak, Jaravel and Speiss. 

##### Using weighted averages of individual DID estimators {#IndivDID}

This estimator is pretty simple to define.
Simply take all the possible $2\times2$ possible DID estimators $\Delta^{Y}_{DID}(d,d',\tau,\tau')$, with $\tau,\tau'>0$ and $d'>d+\tau$, and then average them using the pre-defined weights $w^k(d,d',\tau,\tau')$ of your choice. 
The key to this section is to illustrate how to operationalize this approach in practice with an example.
Let's go.

```{example}
The key here is first to generate some data.
```
We are going to have four successive time periods, $1$, $2$, $3$, and $4$.
At each of these time periods, some units start receiving the treatment, generating four treatment groups: $D_i\in\{1,2,3,4\}$.
Let us write a model compatible with this setting, choose a parameterization and generate the data.

\begin{align*}
y^1_{i,t} & = y_{i,t}^0+\bar{\alpha}_t+\sum_{d}(\bar{\alpha}_{t,d}+\theta_d\mu_i)\uns{D_{i,d}=1}+\eta_{i,t} \\
y^0_{i,t} & = \mu_i+\delta_t+U^0_{i,t} \\
U^0_{i,t} & = \rho U^0_{i,t-1}+\epsilon_{i,t} \\
D_{i,t}   & = \uns{y^0_{i,1} + \xi_t+ V_i\leq\bar{y}} \\
V_i   & = \gamma(\mu_i-\bar{\mu}) + \omega_{i,1} \\
U^0_{i,1} & \sim\mathcal{N}(0,\sigma^2_{U}) \\
(\eta_{i,t},\omega_{i,t}) & \sim\mathcal{N}(0,0,\sigma^2_{\eta},\sigma^2_{\omega},\rho_{\eta,\omega})\\
\epsilon_{i,t} & \sim\mathcal{N}(0,\sigma^2_{\epsilon}).
\end{align*}

I am going to parameterize the $\bar{\alpha}_{t,d}$ process in order to avoid having to specify the 14 parameters that it otherwise would require.
The parameterization I am choosing is $\bar{\alpha}_{t,d}=\bar\chi_d+\kappa_d(t-d)\uns{t\geq d}$, so that treatment effects increase linearly as time into the treatment increases.
Let us now choose some parameter values: 

```{r param.DID.staggered,eval=TRUE,echo=TRUE,results='hide'}
param <- c(8,.5,.28,1500,0.9,
           0.01,0.01,0.01,0.01,
           0.05,0.05,
           0,0.1,0.2,0.3,
           0.05,0.1,0.15,0.2,
           0.25,0.1,0.05,0,
           0.75,0.5,0.25,0.1,
           0.5,0,-0.5,-1,
           0.1,0.28,0)
names(param) <- c("barmu","sigma2mu","sigma2U","barY","rho",
                  "theta1","theta2","theta3","theta4",
                  "sigma2epsilon","sigma2eta",
                  "delta1","delta2","delta3","delta4",
                  "baralpha1","baralpha2","baralpha3","baralpha4",
                  "barchi1","barchi2","barchi3","barchi4",
                  "kappa1","kappa2","kappa3","kappa4",
                  "xi1","xi2","xi3","xi4",
                  "gamma","sigma2omega","rhoetaomega")
```

Let us now generate the corresponding data (in long format):

```{r SimulDIDStaggered,eval=TRUE,warning=FALSE,error=FALSE,message=FALSE,echo=TRUE,results='hide'}
set.seed(1234)
N <- 1000
T <- 4
cov.eta.omega <- matrix(c(param["sigma2eta"],param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),param["rhoetaomega"]*sqrt(param["sigma2eta"]*param["sigma2omega"]),param["sigma2omega"]),ncol=2,nrow=2)
data <- as.data.frame(mvrnorm(N*T,c(0,0),cov.eta.omega))
colnames(data) <- c('eta','omega')
# time and individual identifiers
data$time <- c(rep(1,N),rep(2,N),rep(3,N),rep(4,N))
data$id <- rep((1:N),T)
# unit fixed effects
data$mu <- rep(rnorm(N,param["barmu"],sqrt(param["sigma2mu"])),T)
# time fixed effects
data$delta <- c(rep(param["delta1"],N),rep(param["delta2"],N),rep(param["delta3"],N),rep(param["delta4"],N))
data$baralphat <- c(rep(param["baralpha1"],N),rep(param["baralpha2"],N),rep(param["baralpha3"],N),rep(param["baralpha4"],N))

# building autocorrelated error terms
data$epsilon <- rnorm(N*T,0,sqrt(param["sigma2epsilon"]))
data$U[1:N] <- rnorm(N,0,sqrt(param["sigma2U"]))
data$U[(N+1):(2*N)] <- param["rho"]*data$U[1:N] + data$epsilon[(N+1):(2*N)]
data$U[(2*N+1):(3*N)] <- param["rho"]*data$U[(N+1):(2*N)] + data$epsilon[(2*N+1):(3*N)]
data$U[(3*N+1):(T*N)] <- param["rho"]*data$U[(2*N+1):(3*N)] + data$epsilon[(3*N+1):(T*N)]
# potential outcomes in the absence of the treatment
data$y0 <- data$mu + data$delta + data$U 
data$Y0 <- exp(data$y0)
# treatment timing
# error term
data$V <- param["gamma"]*(data$mu-param["barmu"])+data$omega
# treatment group, with 99 for the never treated instead of infinity
Ds <- if_else(data$y0[1:N]+param["xi1"]+data$V[1:N]<=log(param["barY"]),1,
              if_else(data$y0[1:N]+param["xi2"]+data$V[1:N]<=log(param["barY"]),2,
                      if_else(data$y0[1:N]+param["xi3"]+data$V[1:N]<=log(param["barY"]),3,
                              if_else(data$y0[1:N]+param["xi4"]+data$V[1:N]<=log(param["barY"]),4,99))))
data$Ds <- rep(Ds,T)
# Treatment status
data$D <- if_else(data$Ds>data$time,0,1)
# potential outcomes with the treatment
# effect of the treatment by group
data$baralphatd <- if_else(data$Ds==1,param["barchi1"],
                           if_else(data$Ds==2,param["barchi2"],
                                   if_else(data$Ds==3,param["barchi3"],
                                           if_else(data$Ds==4,param["barchi4"],0))))+
                  if_else(data$Ds==1,param["kappa1"],
                           if_else(data$Ds==2,param["kappa2"],
                                   if_else(data$Ds==3,param["kappa3"],
                                           if_else(data$Ds==4,param["kappa4"],0))))*(data$t-data$Ds)*if_else(data$time>=data$Ds,1,0)
data$y1 <- data$y0 + data$baralphat + data$baralphatd + if_else(data$Ds==1,param["theta1"],if_else(data$Ds==2,param["theta2"],if_else(data$Ds==3,param["theta3"],param["theta4"])))*data$mu + data$eta
data$Y1 <- exp(data$y1)
data$y <- data$y1*data$D+data$y0*(1-data$D)
data$Y <- data$Y1*data$D+data$Y0*(1-data$D)
```

Let us now plot the data, especially the potential outcomes for each group.

```{r PlotDIDStaggered,eval=TRUE,warning=FALSE,error=FALSE,message=FALSE,echo=TRUE,fig.cap='Evolution of average outcomes in the various treatment groups defined by their date of entry into the treatment',fig.align='center',out.width='50%',results='hide',fig.pos='htbp'}
dataplotDIDStaggered <- data %>%
                          group_by(Ds,time) %>%
                          summarize(
                            y1=mean(y1),
                            y0=mean(y0)
                          ) %>%
                          pivot_longer(cols=c("y1","y0"),values_to="Outcome",names_to="PotentialOutcome") %>%
                          mutate(
                            TreatmentDate = factor(Ds,levels=c("99","4","3","2","1"))
                          )

ggplot(dataplotDIDStaggered,aes(x=time,y=Outcome,color=TreatmentDate,shape=TreatmentDate,linetype=PotentialOutcome))+
      geom_line() +
      geom_point()+
#    scale_linetype_discrete(guide='none') +
    theme_bw()
```

Figure \@ref(fig:PlotDIDStaggered) shows that the first units to be treated have the lowest potential outcomes in the absence of the treatment ($y^0$, in full line), and that each successive cohort entering the treatment over time has increasingly large potential outcomes.
Assumption \@ref(hyp:ParallelTrendsTime) seems to hold in this dataset, at least visually: the trends in potential outcomes in the absence of the treatment seem to be rather parallel to each other in each group.
Once a group of unit has entered the treatment, it experiences an increase in outcomes that grows over time. 
Finally, note that we will be unable to estimate the impact on the group with $D_i=1$ since they enter the treatment at the first period. 

Let us now compute each possible DID estimator on this dataset.
In order to save some space and time, we will start by focusing on group 2.
Group 2 starts treatment at period 2, and thus only period 1 can be used for building a DID estimator.
But several comparison groups exist: the never treated (note that we have used $D_i=99$ instead of $D_i=\infty$ to characterize this group, in order to make it simpler to manipulate it in `R`) but also group 3, that can serve as an untreated benchmark between periods 1 and 2, and group 4, which can be used as an untreated benchmark in periods 1, 2 and 3.
Let's compute all these effects.
In order to make our lives simpler, we are going to generate a function to generate $\hat\Delta^{Y}_{DID}(d,d',\tau,\tau')$.

```{r DIDStaggeredFun22,eval=TRUE,warning=FALSE,error=FALSE,message=FALSE,echo=TRUE}
# StaggeredDID22 is a function that takes as inputs:
# y: name of outcome variable (character)
# D: name of treatment group variable (character)
# d: treatment group defined by date of entry into the treatment
# dprime: comparison group
# tau: number of periods after treatment date at which we estimate the effect of the treatment
# tauprime: number of periods before the treatment date that we use a baseline period (defaults to one)
# t: time indicator (character)
# i: individual unit indicator (character)
# data: dataset containing the outcomes and treatments and time and unit indicators
StaggeredDID22 <- function(tau,y,D,d,dprime,tauprime=1,t,i,data){
  # taking out the irrelevant groups and time periods and generating a useful treatment variable
  data.DID <- data %>%
            filter(!!sym(D)==d | !!sym(D)==dprime) %>% 
            filter(time==d+tau | time==d-tauprime) %>%
            mutate(
              Dit = if_else(!!sym(D)==d & time==d+tau,1,0)
            )
  # running the within estimator (fixest)
  # regression formula
  DID.form <- as.formula(paste(paste(y,paste("Dit",t,sep="+"),sep="~"),i,sep="|"))
  reg.W.fixest <- feols(DID.form, data = data.DID)
  # result vector
  DID.est.W.fixest <- c(d,dprime,tau,tauprime,coef(reg.W.fixest)[[1]],sqrt(vcov(reg.W.fixest)[[1,1]]))
  names(DID.est.W.fixest) <- c("d","dprime","tau","tauprime","DIDest","DIDse")
  return(DID.est.W.fixest)
}

# Run the regression and keep results
# D=99 as benchmark
# list of tau for d=2 and dprime=99 and tauprime=1
tau.2.99 <- c(0,1,2)
DID.2.99.1 <- map_dfr(tau.2.99,StaggeredDID22,y='y',D='Ds',d=2,dprime=99,tauprime=1,t="time",i="id",data=data) 
# D=3 
# list of tau for d=2 and dprime=3 and tauprime=1
tau.2.3 <- c(0)
DID.2.3.1 <- map_dfr(tau.2.3,StaggeredDID22,y='y',D='Ds',d=2,dprime=3,tauprime=1,t="time",i="id",data=data) 
# D=4 
# list of tau for d=2 and dprime=4 and tauprime=1
tau.2.4 <- c(0,1)
DID.2.4.1 <- map_dfr(tau.2.4,StaggeredDID22,y='y',D='Ds',d=2,dprime=4,tauprime=1,t="time",i="id",data=data) 

# regroup results
DID.2.1 <- rbind(DID.2.99.1,DID.2.3.1,DID.2.4.1)

# true effects (in the sample)
ATT.2.0 <- mean(data$y1[data$Ds==2 & data$time==2])-mean(data$y0[data$Ds==2 & data$time==2])
ATT.2.1 <- mean(data$y1[data$Ds==2 & data$time==3])-mean(data$y0[data$Ds==2 & data$time==3])
ATT.2.2 <- mean(data$y1[data$Ds==2 & data$time==4])-mean(data$y0[data$Ds==2 & data$time==4])
```

Let us now plot the results for the DID estimates on group $2$ using $\tau'=1$ as a benchmark pre-treatment period.

```{r PlotDIDStaggeredGroup2,eval=TRUE,warning=FALSE,error=FALSE,message=FALSE,echo=TRUE,fig.cap=c("DID estimates for Group 2 at various time periods after the treament and with various comparison groups and with the reference period $\\tau'=1$"),fig.align='center',out.width='50%',results='hide',fig.pos='htbp'}
# preparing data
DID.2.1 <- DID.2.1 %>%
            mutate(
              dprime=factor(dprime,levels=c("99","4","3","2","1"))
            )

# plot
ggplot(DID.2.1,aes(x=tau,y=DIDest,colour=dprime,linetype=dprime))+
      geom_line() +
    geom_pointrange(aes(ymin=DIDest-1.96*DIDse,ymax=DIDest+1.96*DIDse))+
    ylab("DID estimate") +
    xlab("Time after treatment (tau)") +
    scale_x_continuous(breaks=c(0,1,2)) +
    expand_limits(y=0) +
    scale_colour_discrete(name="Comparison\ngroup")+
    scale_linetype_discrete(name="Comparison\ngroup")+
    theme_bw()
```

Figure \@ref(fig:PlotDIDStaggeredGroup2) shows the $\hat\Delta^{Y}_{DID}(d,d',\tau,\tau')$ estimates for $d=2$ and $\tau'=1$, varying both $\tau$ and $d'$. 
The treatment effects estimated using different reference groups are similar to each other when we can compare them.
Moreover, the treatment effect grows with time, as expected from Figure \@ref(fig:PlotDIDStaggered).
The true effects of the treatment on group 2 are, in our sample: $\hat\Delta^{Y_{0}}_{TT_2}=$ `r round(ATT.2.0,2)`, $\hat\Delta^{Y_{1}}_{TT_2}=$ `r round(ATT.2.1,2)` and $\hat\Delta^{Y_{2}}_{TT_2}=$ `r round(ATT.2.2,2)`.
These are very close to our DID estimates.
For example, $\hat\Delta^{Y}_{DID}(2,99,0,1)=$ `r round(DID.2.1 %>% filter(d==2,dprime==99,tau==0,tauprime==1) %>% pull(DIDest),2)`, while $\hat\Delta^{Y}_{DID}(2,4,0,1)=$ `r round(DID.2.1 %>% filter(d==2,dprime==4,tau==0,tauprime==1) %>% pull(DIDest),2)` and $\hat\Delta^{Y}_{DID}(2,3,0,1)=$ `r round(DID.2.1 %>% filter(d==2,dprime==3,tau==0,tauprime==1) %>% pull(DIDest),2)`, which are all pretty close to $\hat\Delta^{Y_{0}}_{TT_2}=$ `r round(ATT.2.0,2)`.
$\hat\Delta^{Y}_{DID}(2,99,1,1)=$ `r round(DID.2.1 %>% filter(d==2,dprime==99,tau==1,tauprime==1) %>% pull(DIDest),2)`, while $\hat\Delta^{Y}_{DID}(2,4,1,1)=$ `r round(DID.2.1 %>% filter(d==2,dprime==4,tau==1,tauprime==1) %>% pull(DIDest),2)`, which are also all pretty close to $\hat\Delta^{Y_{1}}_{TT_2}=$ `r round(ATT.2.1,2)`.
Finally, $\hat\Delta^{Y}_{DID}(2,99,2,1)=$ `r round(DID.2.1 %>% filter(d==2,dprime==99,tau==2,tauprime==1) %>% pull(DIDest),2)`, while $\hat\Delta^{Y_{2}}_{TT_2}=$ `r round(ATT.2.2,2)`.

In order to aggregate the estimates presented in Figure \@ref(fig:PlotDIDStaggeredGroup2), we could for example use the proportion of each comparison group in the sample and average the treatment effects for each post treatment period $\tau$ with these weights.
We can do the same thing with groups 3 and 4 and see what happens.

```{r DIDStaggered34Agg,eval=TRUE,warning=FALSE,error=FALSE,message=FALSE,echo=TRUE}
# do the DID22 estimates for d=3
# Run the regression and keep results
# D=99 as benchmark
# list of tau for d=3 and dprime=99 and tauprime=1
tau.3.99 <- c(0,1)
DID.3.99.1 <- map_dfr(tau.3.99,StaggeredDID22,y='y',D='Ds',d=3,dprime=99,tauprime=1,t="time",i="id",data=data) 
# D=4 as a benchmark 
# list of tau for d=3 and dprime=4 and tauprime=1
tau.3.4 <- c(0)
DID.3.4.1 <- map_dfr(tau.3.4,StaggeredDID22,y='y',D='Ds',d=3,dprime=4,tauprime=1,t="time",i="id",data=data) 

# regroup results
DID.3.1 <- rbind(DID.3.99.1,DID.3.4.1)

# true effects (in the sample)
ATT.3.0 <- mean(data$y1[data$Ds==3 & data$time==3])-mean(data$y0[data$Ds==3 & data$time==3])
ATT.3.1 <- mean(data$y1[data$Ds==3 & data$time==4])-mean(data$y0[data$Ds==3 & data$time==4])

# do the DID22 estimates for d=4
# Run the regression and keep results
# D=99 as benchmark
# list of tau for d=4 and dprime=99 and tauprime=1
tau.4.99 <- c(0)
DID.4.99.1 <- map_dfr(tau.4.99,StaggeredDID22,y='y',D='Ds',d=4,dprime=99,tauprime=1,t="time",i="id",data=data) 

# true effects (in the sample)
ATT.4.0 <- mean(data$y1[data$Ds==4 & data$time==4])-mean(data$y0[data$Ds==4 & data$time==4])

# regrouping all effects
DID.1 <- rbind(DID.2.1,DID.3.1,DID.4.99.1)

# computing the weights
prop.groups.DID <- data %>%
                    filter(time==1) %>%
                    group_by(Ds) %>%
                    summarize(
                      prop.group = n()/N
                    ) %>%
                    rename(
                      dprime=Ds
                    )%>%
                    mutate(
                      dprime=factor(dprime,levels=c("99","4","3","2","1"))
                    )

# joining the weights to the results
DID.1 <- DID.1 %>%
          left_join(prop.groups.DID,by=c("dprime"))

# generating the weighted averages by tau
DID.tau <- DID.1 %>%
            mutate(
              w.ATT = prop.group*DIDest
            ) %>%
            group_by(tau,d) %>%
            summarize(
              sum.w.ATT = sum(w.ATT),
              sum.w = sum(prop.group)
            ) %>% 
            mutate(
              ATT.tau = sum.w.ATT/sum.w
            ) %>%
            select(d,tau,ATT.tau) %>%
            mutate(
              d=factor(d,levels=c("2","3","4"))
            )
```

Let us now plot the results for the DID estimates in groups $2$, $3$ and $4$ using $\tau'=1$ as a benchmark pre-treatment period and aggregating the estimates using every possible valid control group:

```{r PlotDIDStaggeredGroups,eval=TRUE,warning=FALSE,error=FALSE,message=FALSE,echo=TRUE,fig.cap=c("DID estimates for all groups at various time periods after the treament aggregated across all comparison groups and with the reference period $\\tau'=1$"),fig.align='center',out.width='50%',results='hide',fig.pos='htbp'}
ggplot(DID.tau,aes(x=tau,y=ATT.tau,colour=d,linetype=d))+
    geom_line() +
    geom_point() +
    ylab("DID estimate") +
    xlab("Time after treatment (tau)") +
    scale_x_continuous(breaks=c(0,1,2)) +
    expand_limits(y=0) +
    scale_colour_discrete(name="Treatment\ngroup")+
    scale_linetype_discrete(name="Treatment\ngroup")+
    theme_bw()
```

On Figure \@ref(fig:PlotDIDStaggeredGroups), we can see that all the estimators are comparable for each other at each time period $\tau$, no matter the treatment group.
We thus can aggregate the impacts at each period $\tau$ across all treatment groups.
There are two ways to do that: one is to use all the groups for which we observe the effect of the treatment at period $\tau$.
The drawback of this approach is that group composoition changes with $\tau$.
For example, on Figure \@ref(fig:PlotDIDStaggeredGroups), we can see that the treatment group treated in the last period (for which $D_i=4$) contributes only to the computation of the effect of the treatment at period $\tau=0$.
This is because we cannot observe what happens to this group in later periods with our dataset.
As a consequence, in period $\tau=0$, all three groups--$D_i=2$, $D_i=3$ and $D_i=4$--contribute to the estimation of the effect of the treatment, whereas only groups with $D_i=2$ and $D_i=3$ contribute to the estimation of the effect at $\tau=1$, and only $D_i=2$ contributes to estimating the effect at $\tau=2$. 
If treatment effects were heterogeneous across treatment groups, this change in group composition would confound actual changes in the magnitude of treatment effects.
Since the effect of the treatment is rather homogenous across groups, this group comopsition problem will not matter in our application.
Nevetheless, we are still going to estimate the effect of the treatment at $\tau=0$ and $\tau=1$ maintaining group composition constant ($D_i=2$ and $D_i=3$). 
In our application, both approaches will yield very similar results.
The weigths we are going to use for our aggregation are the proportions of units belonging to each group.

```{r DIDStaggeredAgg,eval=TRUE,warning=FALSE,error=FALSE,message=FALSE,echo=TRUE}
# joining the weights to the results
DID.tau <- DID.tau %>%
          left_join(prop.groups.DID,by=c("d"="dprime"))

# generating the weighted averages by tau (varying group composition)
DID.tau.agg <- DID.tau %>%
            mutate(
              w.ATT = prop.group*ATT.tau
            ) %>%
            group_by(tau) %>%
            summarize(
              sum.w.ATT = sum(w.ATT),
              sum.w = sum(prop.group)
            ) %>% 
            mutate(
              ATT.tau.agg = sum.w.ATT/sum.w
            ) %>%
            select(tau,ATT.tau.agg) %>%
            mutate(
              Composition="Varying"
            )

# generating the weighted averages by tau (constant group composition)
DID.tau.agg.cst <- DID.tau %>%
            filter(d==2 | d==3) %>%
            filter(tau==0 | tau==1) %>%
            mutate(
              w.ATT = prop.group*ATT.tau
            ) %>%
            group_by(tau) %>%
            summarize(
              sum.w.ATT = sum(w.ATT),
              sum.w = sum(prop.group)
            ) %>% 
            mutate(
              ATT.tau.agg = sum.w.ATT/sum.w
            ) %>%
            select(tau,ATT.tau.agg) %>%
            mutate(
              Composition="Constant"
            )

#regrouping estimates
DID.tau.agg.tot <- rbind(DID.tau.agg,DID.tau.agg.cst) %>%
                    mutate(
                      Composition = factor(Composition,levels=c("Constant","Varying"))
                    )

```

Let's pot the resulting estimates.

```{r PlotDIDStaggeredAgg,eval=TRUE,warning=FALSE,error=FALSE,message=FALSE,echo=TRUE,fig.cap=c("DID estimates at various time periods after the treament aggregated across all treatment groups and maintaining treatment group composition constant (reference period $\\tau'=1$)"),fig.align='center',out.width='50%',results='hide',fig.pos='htbp'}
ggplot(DID.tau.agg.tot,aes(x=tau,y=ATT.tau.agg,colour=Composition,linetype=Composition))+
    geom_line() +
    geom_point() +
    ylab("DID estimate") +
    xlab("Time after treatment (tau)") +
    scale_x_continuous(breaks=c(0,1,2)) +
    expand_limits(y=0) +
    scale_colour_discrete(name="Group\ncomposition")+
    scale_linetype_discrete(name="Group\ncomposition")+
    theme_bw()
```

As expected, Figure \@ref(fig:PlotDIDStaggeredAgg) confirms that group composition does not play an important role in treatment effect heterogeneity: there actually is a true heterogeneity along the time dimension: the treatment effect seems to increase linearly over time (as we suspected it would, since we parameterized our model just like it).

Finally, let us aggregate all treatment effects from all periods into one unique estimate. 
It is not an easy feat, especially in our current example which exhibits lots of treatment effect heterogeneity over $\tau$.
Should we simply aggregate all treatment effect estimates using equal weights for each period $\tau$ or, rather, should we try to reflect the actual composition of treated groups and time periods in the sample? 
The choice of the mode of aggregation might make a huge difference to the eventual result, since giving more weights to higher $\tau$ will result in a much higher overall treatment effect.
Let's see what happens with both approaches.

```{r DIDStaggeredATT,eval=TRUE,warning=FALSE,error=FALSE,message=FALSE,echo=TRUE}
# aggregating by weighing equally each time period tau
ATT.equal <- DID.tau.agg.tot %>%
                filter(Composition=="Varying") %>%
                summarize(
                  ATT.equal = mean(ATT.tau.agg)
                ) %>%
                pull(ATT.equal)

# aggregating by weighing as a proportion of time spent by each group in the treatment state 
ATT.varying <- DID.tau %>%
            ungroup() %>%
            mutate(
              w.ATT = prop.group*ATT.tau
            ) %>%
            summarize(
              sum.w.ATT = sum(w.ATT),
              sum.w = sum(prop.group)
            ) %>% 
            mutate(
              ATT.varying = sum.w.ATT/sum.w
            ) %>%
            pull(ATT.varying)
```

The average effect of the treatment, giving equal weight to each time period $\tau\in\{0,1,2\}$, is equal to $\hat\Delta^{Y}_{TT}(e)=$ `r round(ATT.equal,2)`, where $e$ stands for "equal" weights.
The average effect of the treatment, giving weights proportional to group composition and time spent in the treatment is equal to $\hat\Delta^{Y}_{TT}(v)=$ `r round(ATT.varying,2)`, where $v$ stands for "varying" weights.

##### Direct weighting using one reference period and one reference group (Sun and Abraham)

OK, so now, we know how to compute the various DID estimators by hand and how to aggregate them.
Is there a way to obtain directly an aggregated estimate with an R package? 
Yes, actually, plenty of such estimator exist. 
They are listed on [Asjad Naqvi's DID webpage](https://asjadnaqvi.github.io/DiD/docs/02_R/). 
Let's start with the ones implementing the [Sun and Abraham (2021)](https://www.sciencedirect.com/science/article/pii/S030440762030378X) estimator.
[Sun and Abraham (2021)](https://www.sciencedirect.com/science/article/pii/S030440762030378X)'s estimator start with estimating a Two Way Fixed Effect model with a rich dynamic specification:

\begin{align*}
  	Y_{i,t} &  = \mu_i + \delta_t + \sum_{d=2}^T\sum_{\tau\neq-1}\beta_{d,\tau}^{SA}\uns{D_{i}=d \land t=d+\tau}  + \epsilon^{SA}_{i,t},
\end{align*}

on the sample excluding the always treated individuals ($D_i=1$).
In order to be consistent with previous estimators, we are going to start using the `fixest` package to obtain our estimator.
In order to be able to estimate [Sun and Abraham (2021)](https://www.sciencedirect.com/science/article/pii/S030440762030378X)'s estimator with `fixest`, we simply are going to add a `sunab(d,t)` term to the `feols` command, with the first term giving the treatment group and the second term the time fixed effect.
We then can aggregate the estimated terms using `regexp` in order to detect the string patterns.
Let's go:

```{r DIDSAfixest,eval=TRUE,warning=FALSE,error=FALSE,message=FALSE,echo=TRUE}
# regression
reg.fixest.SA.Agg <- feols(y ~ sunab(Ds,time)| id + time, data=filter(data,Ds>1))

# aggregate estimate (this is a command specific to fixest that aggregates various coefficients where an i. specification was used)
# The selection of coefficients to aggregate uses a string detection pattern language
# varying composition
aggregate.SA.varying <- aggregate(reg.fixest.SA.Agg, c("tau" = "time::([[:digit:]]+)"))

# another approach using the i function: not run, but works
# creating a time to treatment variable:
# data <- data %>%
#           mutate(
#             tau=time-Ds
#           ) %>%
#           mutate( 
#             tau = replace(tau,tau<=-90,-99)
#           )

# regression
# reg.fixest.SA.nonAgg <- feols(y ~ i(tau,i.Ds,ref=c(-1,-99))| id + time, data=filter(data,Ds>1))
# aggregate estimate (this is a command specific to fixest that aggregates various coefficients where an i. specification was used)
# The selection of coefficients to aggregate uses a string detection pattern language
# varying composition
# aggregate.SA.nonAgg.varying <- aggregate(reg.fixest.SA.nonAgg, c("tau" = "tau::([[:digit:]]+)"))
```

Let's plot the results:

```{r PlotDIDStaggeredAggSA,eval=TRUE,warning=FALSE,error=FALSE,message=FALSE,echo=TRUE,fig.cap=c("DID estimates at various time periods after the treament using Sun and Abraham's estimator implemented by fixest (reference period $\\tau'=1$)"),fig.align='center',out.width='50%',results='hide',fig.pos='htbp'}
# preparation
colnames(aggregate.SA.varying) <- c("ATT","Se","t","pval")
aggregate.SA.varying <- aggregate.SA.varying %>%
                  as.data.frame(.)  %>%
                  mutate(tau = 0:2) 

# plot
ggplot(aggregate.SA.varying,aes(x=tau,y=ATT))+
    geom_line() +
    geom_pointrange(aes(ymin=ATT-1.96*Se,ymax=ATT+1.96*Se)) +
    ylab("DID estimate") +
    xlab("Time after treatment (tau)") +
    scale_x_continuous(breaks=c(0,1,2)) +
    expand_limits(y=0) +
    scale_colour_discrete(name="Group\ncomposition")+
    scale_linetype_discrete(name="Group\ncomposition")+
    theme_bw()
```

Again, as we have seen before, the change in group composition makes it look like there is a trend break in the treatment effect.
What we would need is to aggregate treatment effects with a constant group composition.
One way to do that would be to use the full disaggregated results of the Sun and Abraham decomposition and to reaggregate them in another way.
In order to access the disaggregated results of the Sun and Abraham regression, we need to use the option `agg=FALSE` in the `coef` and `se` commands.
Let's see how this works.

```{r DIDSAfixestDisAgg,eval=TRUE,warning=FALSE,error=FALSE,message=FALSE,echo=TRUE}
# Disaggregate estimates
disaggregate.SA <- as.data.frame(cbind(coef(reg.fixest.SA.Agg,agg=FALSE),se(reg.fixest.SA.Agg,agg=FALSE)))
colnames(disaggregate.SA) <- c('Coef','Se')
# adding treatment groups and time to treatment
disaggregate.SA <- disaggregate.SA %>%
                    mutate(test =  names(coef(reg.fixest.SA.Agg,agg=FALSE))) %>%
                    mutate(
                      Group = factor(str_sub(test,-1),levels=c('1','2','3','4','Aggregate')),
                      TimeToTreatment = factor(if_else(str_detect(test,"\\-"),str_extract(test,"\\-[[:digit:]]"),str_extract(test,"[[:digit:]]")),levels=c('-3','-2','-1','0','1','2'))
                    ) %>%
                  select(-test)

# adding reference period
Group <- c('2','3','4')
TimeToTreatment <- rep('-1',3)
ref <- as.data.frame(cbind(Group,TimeToTreatment)) %>%
        mutate(
          Coef = 0,
          Se = 0,
          Group = factor(Group,levels=c('1','2','3','4','Aggregate')),
          TimeToTreatment = factor(TimeToTreatment,levels=c('-3','-2','-1','0','1','2'))
          )
disaggregate.SA <- rbind(disaggregate.SA,ref) 

# adding aggregate results
# aggregate estimates
aggregate.SA <- as.data.frame(cbind(coef(reg.fixest.SA.Agg),se(reg.fixest.SA.Agg)))
colnames(aggregate.SA) <- c('Coef','Se')
# adding treatment groups and time to treatment
aggregate.SA <- aggregate.SA %>%
                    mutate(test =  names(coef(reg.fixest.SA.Agg))) %>%
                    mutate(
                      Group = factor(rep("Aggregate",5),levels=c('1','2','3','4','Aggregate')),
                      TimeToTreatment = factor(if_else(str_detect(test,"\\-"),str_extract(test,"\\-[[:digit:]]"),str_extract(test,"[[:digit:]]")),levels=c('-3','-2','-1','0','1','2'))
                    ) %>%
                  select(-test)

# adding reference period
Group <- c("Aggregate")
TimeToTreatment <- rep('-1',1)
ref <- as.data.frame(cbind(Group,TimeToTreatment)) %>%
        mutate(
          Coef = 0,
          Se = 0,
          Group = factor(Group,levels=c('1','2','3','4','Aggregate')),
          TimeToTreatment = factor(TimeToTreatment,levels=c('-3','-2','-1','0','1','2'))
          )
disaggregate.SA <- rbind(disaggregate.SA,aggregate.SA,ref) %>%
                    mutate(TimeToTreatment = as.numeric(as.character(TimeToTreatment)))

```

Let's plot the result:

```{r PlotDIDStaggeredDisAgg,eval=TRUE,warning=FALSE,error=FALSE,message=FALSE,echo=TRUE,fig.cap=c("Disaggregated DID estimates at various time periods after the treament estimated using the Sun and Abraham procedure in fixest (reference period $\\tau'=1$)"),fig.align='center',out.width='50%',results='hide',fig.pos='htbp'}
ggplot(disaggregate.SA,aes(x=TimeToTreatment,y=Coef,colour=Group,linetype=Group))+
    geom_line() +
    geom_pointrange(aes(ymin=Coef-1.96*Se,ymax=Coef+1.96*Se)) +
    ylab("DID estimate") +
    xlab("Time relative to treatment") +
    scale_x_continuous(breaks=c(-3,-2,-1,0,1,2)) +
    expand_limits(y=0) +
    scale_colour_discrete(name="Treatment\ngroup")+
    scale_linetype_discrete(name="Treatment\ngroup")+
    theme_bw()
```

Figure \@ref(fig:PlotDIDStaggeredDisAgg) shows very well how the Sun and Abraham estimator works: it aggregates each group specific treatment effect (relative to the reference period $\tau'=-1$ and to the reference group ($D_i=\infty$)) with period-specific weights which depend on the proportion of each treated group among the treated at this period.
As a result, some dynamic changes in treatment effects might be driven by changes in group composition and not by genuine changes in the effect of the treatment.
This is the case in Figure \@ref(fig:PlotDIDStaggeredDisAgg) between periods 1 and 2 where the acceleration in the growth of the aggregated treatment effect is due to the disappearance of group 3, which has a lower speed of increase of its average treatment effect, at period 2.
As it is always tricky to interpret the aggregated result, I suggest to always plot the disaggregated results on the same graph, as in Figure \@ref(fig:PlotDIDStaggeredDisAgg).

##### Direct weighting using one reference period and one reference group (Callaway and Sant'Anna)

[Callaway and Sant'Anna (2021)](https://www.sciencedirect.com/science/article/pii/S0304407620303948) propose an alternative estimator to the one proposed by Sun and Abraham.
They suggest using a doubly robust matching estimator to condition on observed covariates.
We are only going to encouter these estimators in Section \ref(OM).
In the absence of covariates, Callaway and Sant'Anna's estimator is equivalent to the Sun and Abraham estimator.
Callaway and Sant'Anna have proposed the `did` package to implement their estimator.
The main command is `att_gt`, which computes all the estimates for each treatment group $D_i=g$ and each time period $t$.
Let's see if we can make it work.

```{r DIDCSA,eval=TRUE,warning=FALSE,error=FALSE,message=FALSE,echo=TRUE}
# preparing the data
# The Group variable has to take value 0 for the never treated (instead of infty or 99)
data <- data %>%
          mutate(
            Group = if_else(Ds<99,Ds,0)
          )

# regression
reg.CSA <- att_gt(yname="y",tname="time",idname="id",gname="Group",data=filter(data,Ds!=1),base_period="universal")

# dynamic treatment effects (event-study graph)
reg.CSA.Agg <- aggte(reg.CSA,type="dynamic")   
```

Let's plot the result:

```{r PlotDIDStaggeredDisAggCSA,eval=TRUE,warning=FALSE,error=FALSE,message=FALSE,echo=TRUE,fig.cap=c("Disaggregated DID estimates at various time periods after the treament estimated using the Callaway and Sant'Anna procedure in did (reference period $\\tau'=1$)"),fig.align='center',out.width='50%',results='hide',fig.pos='htbp'}
# preparing the results for the plot  
DID.CSA <- as.data.frame(reg.CSA$group)
colnames(DID.CSA) <- c("Group")
DID.CSA <- DID.CSA %>%
            mutate(
              time = reg.CSA$t,
              Coef = reg.CSA$att,
              Se = reg.CSA$se
            ) %>%
            mutate(
              TimeToTreatment = time-Group,
              Group = factor(Group,levels=c('1','2','3','4','Aggregate')),
            )

# add aggregate effect
DID.CSA.Agg <- as.data.frame(cbind(reg.CSA.Agg$egt,reg.CSA.Agg$att.egt,reg.CSA.Agg$se.egt))
colnames(DID.CSA.Agg) <- c('TimeToTreatment','Coef','Se')
DID.CSA.Agg <- DID.CSA.Agg %>%
                mutate(
                  Group = factor(rep("Aggregate",nrow(DID.CSA.Agg)),levels=c('1','2','3','4','Aggregate'))
                )

# merge all results
DID.CSA <- rbind(select(DID.CSA,-time),DID.CSA.Agg)

ggplot(DID.CSA,aes(x=TimeToTreatment,y=Coef,colour=Group,linetype=Group))+
    geom_line() +
    geom_pointrange(aes(ymin=Coef-1.96*Se,ymax=Coef+1.96*Se)) +
    ylab("DID estimate") +
    xlab("Time relative to treatment") +
    scale_x_continuous(breaks=c(-3,-2,-1,0,1,2)) +
    expand_limits(y=0) +
    scale_colour_discrete(name="Treatment\ngroup")+
    scale_linetype_discrete(name="Treatment\ngroup")+
    theme_bw()
```

Figure \@ref(fig:PlotDIDStaggeredDisAggCSA) shows a result that is very similar to the one obtained in Figure \@ref(fig:PlotDIDStaggeredDisAgg) using Sun and Abraham's approch as implemented in `fixest`. 
The two approaches are indeed equivalent with the options that we have chosen.

##### Imputation methods: Borusyak, Jaravel and Speiss, Gardner


**How to combine estimates, even with only one reference period, when there are several estimates for the same treatment effect ($\tau$)?**
**We should focus on the most efficient estimator: I think that's Borusyak's point**

##### De Chaisemartin and d'Haultfoeuille 

##### Two-Way Fixed Effects estimation: Goodman-Bacon's decomposition

##### Stacked DID 

#### Inference

**Simple estimators use the Delta method with an appropriate weighting matrix**

### Difference In Differences with Instrumental Variables

