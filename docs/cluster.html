<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 9 Clustering | Statistical Tools for Causal Inference</title>
  <meta name="description" content="This is an open source collaborative book." />
  <meta name="generator" content="bookdown 0.26 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 9 Clustering | Statistical Tools for Causal Inference" />
  <meta property="og:type" content="book" />
  
  <meta property="og:description" content="This is an open source collaborative book." />
  <meta name="github-repo" content="chabefer/STCI" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 9 Clustering | Statistical Tools for Causal Inference" />
  
  <meta name="twitter:description" content="This is an open source collaborative book." />
  

<meta name="author" content="Sylvain Chabé-Ferret" />


<meta name="date" content="2023-09-07" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="sec:placebo.html"/>
<link rel="next" href="LaLonde.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>
$$
\newcommand{\uns}[1]{\mathbf{1}[#1]}
\newcommand{\esp}[1]{\mathbf{E}[#1]}
\newcommand{\hatesp}[1]{\hat{\mathbf{E}}[ #1 ]}
\newcommand{\espE}{\mathbf{E}}
\newcommand{\Ind}{\perp\kern-5pt\perp}
\newcommand{\var}[1]{\mathbf{V}[ #1 ]}
\newcommand{\hatvar}[1]{\hat{\mathbf{V}}[ #1 ]}
\newcommand{\cov}[1]{\mathbf{C}[ #1 ]}
\newcommand{\plim}[1]{\text{plim}_{ #1 \rightarrow \infty}}
\newcommand{\plims}{\text{plim}}
\newcommand{\distr}{\stackrel{d}{\rightarrow}}
\newcommand{\partder}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\partdersq}[2]{\frac{\partial^2 #1}{\partial #2^2}}
\DeclareMathOperator{\diag}{diag}
\DeclareMathOperator{\asym}{Asym}
$$


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Statistical Tools for Causal Inference</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Introduction</a></li>
<li class="part"><span><b>I Fundamental Problems of Inference</b></span></li>
<li class="chapter" data-level="" data-path="introduction-the-two-fundamental-problems-of-inference.html"><a href="introduction-the-two-fundamental-problems-of-inference.html"><i class="fa fa-check"></i>Introduction: the Two Fundamental Problems of Inference</a></li>
<li class="chapter" data-level="1" data-path="FPCI.html"><a href="FPCI.html"><i class="fa fa-check"></i><b>1</b> Fundamental Problem of Causal Inference</a>
<ul>
<li class="chapter" data-level="1.1" data-path="FPCI.html"><a href="FPCI.html#rubin-causal-model"><i class="fa fa-check"></i><b>1.1</b> Rubin Causal Model</a>
<ul>
<li class="chapter" data-level="1.1.1" data-path="FPCI.html"><a href="FPCI.html#treatment-allocation-rule"><i class="fa fa-check"></i><b>1.1.1</b> Treatment allocation rule</a></li>
<li class="chapter" data-level="1.1.2" data-path="FPCI.html"><a href="FPCI.html#potential-outcomes"><i class="fa fa-check"></i><b>1.1.2</b> Potential outcomes</a></li>
<li class="chapter" data-level="1.1.3" data-path="FPCI.html"><a href="FPCI.html#switching-equation"><i class="fa fa-check"></i><b>1.1.3</b> Switching equation</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="FPCI.html"><a href="FPCI.html#treatment-effects"><i class="fa fa-check"></i><b>1.2</b> Treatment effects</a>
<ul>
<li class="chapter" data-level="1.2.1" data-path="FPCI.html"><a href="FPCI.html#individual-level-treatment-effects"><i class="fa fa-check"></i><b>1.2.1</b> Individual level treatment effects</a></li>
<li class="chapter" data-level="1.2.2" data-path="FPCI.html"><a href="FPCI.html#average-treatment-effect-on-the-treated"><i class="fa fa-check"></i><b>1.2.2</b> Average treatment effect on the treated</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="FPCI.html"><a href="FPCI.html#fundamental-problem-of-causal-inference"><i class="fa fa-check"></i><b>1.3</b> Fundamental problem of causal inference</a></li>
<li class="chapter" data-level="1.4" data-path="FPCI.html"><a href="FPCI.html#intuitive-estimators-confounding-factors-and-selection-bias"><i class="fa fa-check"></i><b>1.4</b> Intuitive estimators, confounding factors and selection bias</a>
<ul>
<li class="chapter" data-level="1.4.1" data-path="FPCI.html"><a href="FPCI.html#withwithout-comparison-selection-bias-and-cross-sectional-confounders"><i class="fa fa-check"></i><b>1.4.1</b> With/Without comparison, selection bias and cross-sectional confounders</a></li>
<li class="chapter" data-level="1.4.2" data-path="FPCI.html"><a href="FPCI.html#the-beforeafter-comparison-temporal-confounders-and-time-trend-bias"><i class="fa fa-check"></i><b>1.4.2</b> The before/after comparison, temporal confounders and time trend bias</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="FPSI.html"><a href="FPSI.html"><i class="fa fa-check"></i><b>2</b> Fundamental Problem of Statistical Inference</a>
<ul>
<li class="chapter" data-level="2.1" data-path="FPSI.html"><a href="FPSI.html#sec:sampnoise"><i class="fa fa-check"></i><b>2.1</b> What is sampling noise? Definition and illustration</a>
<ul>
<li class="chapter" data-level="2.1.1" data-path="FPSI.html"><a href="FPSI.html#sec:definitionnoise"><i class="fa fa-check"></i><b>2.1.1</b> Sampling noise, a definition</a></li>
<li class="chapter" data-level="2.1.2" data-path="FPSI.html"><a href="FPSI.html#sec:illusnoisepop"><i class="fa fa-check"></i><b>2.1.2</b> Sampling noise for the population treatment effect</a></li>
<li class="chapter" data-level="2.1.3" data-path="FPSI.html"><a href="FPSI.html#sec:illusnoisesamp"><i class="fa fa-check"></i><b>2.1.3</b> Sampling noise for the sample treatment effect</a></li>
<li class="chapter" data-level="2.1.4" data-path="FPSI.html"><a href="FPSI.html#sec:confinterv"><i class="fa fa-check"></i><b>2.1.4</b> Building confidence intervals from estimates of sampling noise</a></li>
<li class="chapter" data-level="2.1.5" data-path="FPSI.html"><a href="FPSI.html#reporting-sampling-noise-a-proposal"><i class="fa fa-check"></i><b>2.1.5</b> Reporting sampling noise: a proposal</a></li>
<li class="chapter" data-level="2.1.6" data-path="FPSI.html"><a href="FPSI.html#sec:effectsize"><i class="fa fa-check"></i><b>2.1.6</b> Using effect sizes to normalize the reporting of treatment effects and their precision</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="FPSI.html"><a href="FPSI.html#sec:estimsampnoise"><i class="fa fa-check"></i><b>2.2</b> Estimating sampling noise</a>
<ul>
<li class="chapter" data-level="2.2.1" data-path="FPSI.html"><a href="FPSI.html#sec:assumptions"><i class="fa fa-check"></i><b>2.2.1</b> Assumptions</a></li>
<li class="chapter" data-level="2.2.2" data-path="FPSI.html"><a href="FPSI.html#sec:cheb"><i class="fa fa-check"></i><b>2.2.2</b> Using Chebyshev’s inequality</a></li>
<li class="chapter" data-level="2.2.3" data-path="FPSI.html"><a href="FPSI.html#sec:CLT"><i class="fa fa-check"></i><b>2.2.3</b> Using the Central Limit Theorem</a></li>
<li class="chapter" data-level="2.2.4" data-path="FPSI.html"><a href="FPSI.html#sec:resamp"><i class="fa fa-check"></i><b>2.2.4</b> Using resampling methods</a></li>
</ul></li>
</ul></li>
<li class="part"><span><b>II Methods of Causal Inference</b></span></li>
<li class="chapter" data-level="3" data-path="RCT.html"><a href="RCT.html"><i class="fa fa-check"></i><b>3</b> Randomized Controlled Trials</a>
<ul>
<li class="chapter" data-level="3.1" data-path="RCT.html"><a href="RCT.html#sec:design1"><i class="fa fa-check"></i><b>3.1</b> Brute Force Design</a>
<ul>
<li class="chapter" data-level="3.1.1" data-path="RCT.html"><a href="RCT.html#identification"><i class="fa fa-check"></i><b>3.1.1</b> Identification</a></li>
<li class="chapter" data-level="3.1.2" data-path="RCT.html"><a href="RCT.html#estimating-ate"><i class="fa fa-check"></i><b>3.1.2</b> Estimating ATE</a></li>
<li class="chapter" data-level="3.1.3" data-path="RCT.html"><a href="RCT.html#estimating-sampling-noise"><i class="fa fa-check"></i><b>3.1.3</b> Estimating Sampling Noise</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="RCT.html"><a href="RCT.html#sec:design2"><i class="fa fa-check"></i><b>3.2</b> Self-Selection design</a>
<ul>
<li class="chapter" data-level="3.2.1" data-path="RCT.html"><a href="RCT.html#identification-1"><i class="fa fa-check"></i><b>3.2.1</b> Identification</a></li>
<li class="chapter" data-level="3.2.2" data-path="RCT.html"><a href="RCT.html#estimating-tt"><i class="fa fa-check"></i><b>3.2.2</b> Estimating TT</a></li>
<li class="chapter" data-level="3.2.3" data-path="RCT.html"><a href="RCT.html#estimating-sampling-noise-1"><i class="fa fa-check"></i><b>3.2.3</b> Estimating Sampling Noise</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="RCT.html"><a href="RCT.html#sec:design3"><i class="fa fa-check"></i><b>3.3</b> Eligibility design</a>
<ul>
<li class="chapter" data-level="3.3.1" data-path="RCT.html"><a href="RCT.html#identification-2"><i class="fa fa-check"></i><b>3.3.1</b> Identification</a></li>
<li class="chapter" data-level="3.3.2" data-path="RCT.html"><a href="RCT.html#estimating-the-ite-and-the-tt"><i class="fa fa-check"></i><b>3.3.2</b> Estimating the ITE and the TT</a></li>
<li class="chapter" data-level="3.3.3" data-path="RCT.html"><a href="RCT.html#estimating-sampling-noise-2"><i class="fa fa-check"></i><b>3.3.3</b> Estimating sampling noise</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="RCT.html"><a href="RCT.html#sec:design4"><i class="fa fa-check"></i><b>3.4</b> Encouragement Design</a>
<ul>
<li class="chapter" data-level="3.4.1" data-path="RCT.html"><a href="RCT.html#identification-3"><i class="fa fa-check"></i><b>3.4.1</b> Identification</a></li>
<li class="chapter" data-level="3.4.2" data-path="RCT.html"><a href="RCT.html#IVRCT"><i class="fa fa-check"></i><b>3.4.2</b> Estimating the Local Average Treatment Effect and the Intention to Treat Effect</a></li>
<li class="chapter" data-level="3.4.3" data-path="RCT.html"><a href="RCT.html#estimating-sampling-noise-3"><i class="fa fa-check"></i><b>3.4.3</b> Estimating sampling noise</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="NE.html"><a href="NE.html"><i class="fa fa-check"></i><b>4</b> Natural Experiments</a>
<ul>
<li class="chapter" data-level="4.1" data-path="NE.html"><a href="NE.html#instrumental-variables"><i class="fa fa-check"></i><b>4.1</b> Instrumental Variables</a>
<ul>
<li class="chapter" data-level="4.1.1" data-path="NE.html"><a href="NE.html#an-example-where-monotonicity-does-not-hold"><i class="fa fa-check"></i><b>4.1.1</b> An example where Monotonicity does not hold</a></li>
<li class="chapter" data-level="4.1.2" data-path="NE.html"><a href="NE.html#identification-4"><i class="fa fa-check"></i><b>4.1.2</b> Identification</a></li>
<li class="chapter" data-level="4.1.3" data-path="NE.html"><a href="NE.html#estimation"><i class="fa fa-check"></i><b>4.1.3</b> Estimation</a></li>
<li class="chapter" data-level="4.1.4" data-path="NE.html"><a href="NE.html#estimation-of-sampling-noise"><i class="fa fa-check"></i><b>4.1.4</b> Estimation of sampling noise</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="NE.html"><a href="NE.html#regression-discontinuity-designs"><i class="fa fa-check"></i><b>4.2</b> Regression Discontinuity Designs</a>
<ul>
<li class="chapter" data-level="4.2.1" data-path="NE.html"><a href="NE.html#sharp-regression-discontinuity-designs"><i class="fa fa-check"></i><b>4.2.1</b> Sharp Regression Discontinuity Designs</a></li>
<li class="chapter" data-level="4.2.2" data-path="NE.html"><a href="NE.html#fuzzy-regression-discontinuity-designs"><i class="fa fa-check"></i><b>4.2.2</b> Fuzzy Regression Discontinuity Designs</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="NE.html"><a href="NE.html#DID"><i class="fa fa-check"></i><b>4.3</b> Difference In Differences</a>
<ul>
<li class="chapter" data-level="4.3.1" data-path="NE.html"><a href="NE.html#sec:DIDbasic"><i class="fa fa-check"></i><b>4.3.1</b> Difference In Differences with two time periods</a></li>
<li class="chapter" data-level="4.3.2" data-path="NE.html"><a href="NE.html#sec:DIDr"><i class="fa fa-check"></i><b>4.3.2</b> Reverse Difference In Differences designs with two time periods</a></li>
<li class="chapter" data-level="4.3.3" data-path="NE.html"><a href="NE.html#difference-in-differences-with-multiple-time-periods"><i class="fa fa-check"></i><b>4.3.3</b> Difference In Differences with multiple time periods</a></li>
<li class="chapter" data-level="4.3.4" data-path="NE.html"><a href="NE.html#difference-in-differences-with-instrumental-variables"><i class="fa fa-check"></i><b>4.3.4</b> Difference In Differences with Instrumental Variables</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="OM.html"><a href="OM.html"><i class="fa fa-check"></i><b>5</b> Observational Methods</a>
<ul>
<li class="chapter" data-level="5.1" data-path="OM.html"><a href="OM.html#parametric-methods"><i class="fa fa-check"></i><b>5.1</b> Parametric methods</a>
<ul>
<li class="chapter" data-level="5.1.1" data-path="OM.html"><a href="OM.html#assuming-espy_i0x_i-is-known"><i class="fa fa-check"></i><b>5.1.1</b> Assuming <span class="math inline">\(\esp{Y_i^0|X_i}\)</span> is known</a></li>
<li class="chapter" data-level="5.1.2" data-path="OM.html"><a href="OM.html#assuming-espy_i1x_i-is-known"><i class="fa fa-check"></i><b>5.1.2</b> Assuming <span class="math inline">\(\esp{Y_i^1|X_i}\)</span> is known</a></li>
<li class="chapter" data-level="5.1.3" data-path="OM.html"><a href="OM.html#BiasOLS"><i class="fa fa-check"></i><b>5.1.3</b> Properties of the OLS estimator under Conditional Independence</a></li>
<li class="chapter" data-level="5.1.4" data-path="OM.html"><a href="OM.html#problems-with-parametric-methods"><i class="fa fa-check"></i><b>5.1.4</b> Problems with parametric methods</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="OM.html"><a href="OM.html#nonparametric-methods"><i class="fa fa-check"></i><b>5.2</b> Nonparametric methods</a>
<ul>
<li class="chapter" data-level="5.2.1" data-path="OM.html"><a href="OM.html#identification-12"><i class="fa fa-check"></i><b>5.2.1</b> Identification</a></li>
<li class="chapter" data-level="5.2.2" data-path="OM.html"><a href="OM.html#estimation-8"><i class="fa fa-check"></i><b>5.2.2</b> Estimation</a></li>
<li class="chapter" data-level="5.2.3" data-path="OM.html"><a href="OM.html#estimating-precision-2"><i class="fa fa-check"></i><b>5.2.3</b> Estimating precision</a></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="OM.html"><a href="OM.html#imputation-methods"><i class="fa fa-check"></i><b>5.3</b> Imputation methods</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="threats.html"><a href="threats.html"><i class="fa fa-check"></i><b>6</b> Threats to the validity of Causal Inference</a>
<ul>
<li class="chapter" data-level="6.1" data-path="threats.html"><a href="threats.html#threats-to-internal-validity"><i class="fa fa-check"></i><b>6.1</b> Threats to internal validity</a>
<ul>
<li class="chapter" data-level="6.1.1" data-path="threats.html"><a href="threats.html#survey-bias"><i class="fa fa-check"></i><b>6.1.1</b> Survey bias</a></li>
<li class="chapter" data-level="6.1.2" data-path="threats.html"><a href="threats.html#experimenter-bias"><i class="fa fa-check"></i><b>6.1.2</b> Experimenter bias</a></li>
<li class="chapter" data-level="6.1.3" data-path="threats.html"><a href="threats.html#substitution-bias"><i class="fa fa-check"></i><b>6.1.3</b> Substitution bias</a></li>
<li class="chapter" data-level="6.1.4" data-path="threats.html"><a href="threats.html#diffusion-bias"><i class="fa fa-check"></i><b>6.1.4</b> Diffusion bias</a></li>
</ul></li>
<li class="chapter" data-level="6.2" data-path="threats.html"><a href="threats.html#threats-to-the-measurement-of-precision"><i class="fa fa-check"></i><b>6.2</b> Threats to the measurement of precision</a>
<ul>
<li class="chapter" data-level="6.2.1" data-path="threats.html"><a href="threats.html#insufficient-precision"><i class="fa fa-check"></i><b>6.2.1</b> Insufficient precision</a></li>
<li class="chapter" data-level="6.2.2" data-path="threats.html"><a href="threats.html#clustering"><i class="fa fa-check"></i><b>6.2.2</b> Clustering</a></li>
</ul></li>
<li class="chapter" data-level="6.3" data-path="threats.html"><a href="threats.html#threats-to-external-validity"><i class="fa fa-check"></i><b>6.3</b> Threats to external validity</a>
<ul>
<li class="chapter" data-level="6.3.1" data-path="threats.html"><a href="threats.html#randomization-bias"><i class="fa fa-check"></i><b>6.3.1</b> Randomization bias</a></li>
<li class="chapter" data-level="6.3.2" data-path="threats.html"><a href="threats.html#equilibrium-effects"><i class="fa fa-check"></i><b>6.3.2</b> Equilibrium effects</a></li>
<li class="chapter" data-level="6.3.3" data-path="threats.html"><a href="threats.html#context-effects"><i class="fa fa-check"></i><b>6.3.3</b> Context effects</a></li>
<li class="chapter" data-level="6.3.4" data-path="threats.html"><a href="threats.html#site-selection-bias"><i class="fa fa-check"></i><b>6.3.4</b> Site selection bias</a></li>
<li class="chapter" data-level="6.3.5" data-path="threats.html"><a href="threats.html#publication-bias"><i class="fa fa-check"></i><b>6.3.5</b> Publication bias</a></li>
<li class="chapter" data-level="6.3.6" data-path="threats.html"><a href="threats.html#ethical-and-political-issues"><i class="fa fa-check"></i><b>6.3.6</b> Ethical and political issues</a></li>
</ul></li>
</ul></li>
<li class="part"><span><b>III Additional Topics</b></span></li>
<li class="chapter" data-level="7" data-path="Power.html"><a href="Power.html"><i class="fa fa-check"></i><b>7</b> Power Analysis</a>
<ul>
<li class="chapter" data-level="7.1" data-path="Power.html"><a href="Power.html#basics-of-traditional-power-analysis-using-test-statistics"><i class="fa fa-check"></i><b>7.1</b> Basics of traditional power analysis using test statistics</a>
<ul>
<li class="chapter" data-level="7.1.1" data-path="Power.html"><a href="Power.html#power"><i class="fa fa-check"></i><b>7.1.1</b> Power</a></li>
<li class="chapter" data-level="7.1.2" data-path="Power.html"><a href="Power.html#minimum-detectable-effect"><i class="fa fa-check"></i><b>7.1.2</b> Minimum Detectable Effect</a></li>
<li class="chapter" data-level="7.1.3" data-path="Power.html"><a href="Power.html#minimum-required-sample-size"><i class="fa fa-check"></i><b>7.1.3</b> Minimum Required Sample Size</a></li>
</ul></li>
<li class="chapter" data-level="7.2" data-path="Power.html"><a href="Power.html#traditional-power-analysis-in-practice"><i class="fa fa-check"></i><b>7.2</b> Traditional power analysis in practice</a>
<ul>
<li class="chapter" data-level="7.2.1" data-path="Power.html"><a href="Power.html#power-analysis-for-randomized-controlled-trials"><i class="fa fa-check"></i><b>7.2.1</b> Power Analysis for Randomized Controlled Trials</a></li>
<li class="chapter" data-level="7.2.2" data-path="Power.html"><a href="Power.html#power-analysis-for-natural-experiments"><i class="fa fa-check"></i><b>7.2.2</b> Power Analysis for Natural Experiments</a></li>
<li class="chapter" data-level="7.2.3" data-path="Power.html"><a href="Power.html#power-analysis-for-observational-methods"><i class="fa fa-check"></i><b>7.2.3</b> Power Analysis for Observational Methods</a></li>
</ul></li>
<li class="chapter" data-level="7.3" data-path="Power.html"><a href="Power.html#limitations-of-and-alternatives-to-traditional-power-analysis"><i class="fa fa-check"></i><b>7.3</b> Limitations of and alternatives to traditional power analysis</a>
<ul>
<li class="chapter" data-level="7.3.1" data-path="Power.html"><a href="Power.html#limitations-of-traditional-power-analysis"><i class="fa fa-check"></i><b>7.3.1</b> Limitations of traditional power analysis</a></li>
<li class="chapter" data-level="7.3.2" data-path="Power.html"><a href="Power.html#an-alternative-to-traditional-power-analysis"><i class="fa fa-check"></i><b>7.3.2</b> An alternative to traditional power analysis</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="8" data-path="sec:placebo.html"><a href="sec:placebo.html"><i class="fa fa-check"></i><b>8</b> Placebo Tests</a></li>
<li class="chapter" data-level="9" data-path="cluster.html"><a href="cluster.html"><i class="fa fa-check"></i><b>9</b> Clustering</a>
<ul>
<li class="chapter" data-level="9.1" data-path="cluster.html"><a href="cluster.html#ClusterRCT"><i class="fa fa-check"></i><b>9.1</b> Clustering in Randomized Controlled Trials</a>
<ul>
<li class="chapter" data-level="9.1.1" data-path="cluster.html"><a href="cluster.html#an-example"><i class="fa fa-check"></i><b>9.1.1</b> An example</a></li>
<li class="chapter" data-level="9.1.2" data-path="cluster.html"><a href="cluster.html#design-effect"><i class="fa fa-check"></i><b>9.1.2</b> Design effect</a></li>
<li class="chapter" data-level="9.1.3" data-path="cluster.html"><a href="cluster.html#estimating-sampling-noise-accounting-for-clustering"><i class="fa fa-check"></i><b>9.1.3</b> Estimating sampling noise accounting for clustering</a></li>
</ul></li>
<li class="chapter" data-level="9.2" data-path="cluster.html"><a href="cluster.html#clustering-in-panel-data"><i class="fa fa-check"></i><b>9.2</b> Clustering in panel data</a>
<ul>
<li class="chapter" data-level="9.2.1" data-path="cluster.html"><a href="cluster.html#an-example-1"><i class="fa fa-check"></i><b>9.2.1</b> An example</a></li>
<li class="chapter" data-level="9.2.2" data-path="cluster.html"><a href="cluster.html#design-effect-in-panel-data"><i class="fa fa-check"></i><b>9.2.2</b> Design effect in panel data</a></li>
<li class="chapter" data-level="9.2.3" data-path="cluster.html"><a href="cluster.html#estimating-sampling-noise-in-panel-data-with-autocorrelated-error-terms"><i class="fa fa-check"></i><b>9.2.3</b> Estimating sampling noise in panel data with autocorrelated error terms</a></li>
</ul></li>
<li class="chapter" data-level="9.3" data-path="cluster.html"><a href="cluster.html#spatial-correlation"><i class="fa fa-check"></i><b>9.3</b> Spatial correlation</a>
<ul>
<li class="chapter" data-level="9.3.1" data-path="cluster.html"><a href="cluster.html#an-example-2"><i class="fa fa-check"></i><b>9.3.1</b> An example</a></li>
<li class="chapter" data-level="9.3.2" data-path="cluster.html"><a href="cluster.html#design-effect-in-spatially-autocorrelated-data"><i class="fa fa-check"></i><b>9.3.2</b> Design effect in spatially autocorrelated data</a></li>
<li class="chapter" data-level="9.3.3" data-path="cluster.html"><a href="cluster.html#estimating-sampling-noise-with-spatially-autocorrelated-data"><i class="fa fa-check"></i><b>9.3.3</b> Estimating sampling noise with spatially autocorrelated data</a></li>
<li class="chapter" data-level="9.3.4" data-path="cluster.html"><a href="cluster.html#testing-for-spatial-autocorrelation"><i class="fa fa-check"></i><b>9.3.4</b> Testing for spatial autocorrelation</a></li>
</ul></li>
<li class="chapter" data-level="9.4" data-path="cluster.html"><a href="cluster.html#clustering-on-a-network"><i class="fa fa-check"></i><b>9.4</b> Clustering on a network</a></li>
<li class="chapter" data-level="9.5" data-path="cluster.html"><a href="cluster.html#multi-way-clustering"><i class="fa fa-check"></i><b>9.5</b> Multi-way clustering</a>
<ul>
<li class="chapter" data-level="9.5.1" data-path="cluster.html"><a href="cluster.html#at-which-level-should-we-cluster"><i class="fa fa-check"></i><b>9.5.1</b> At which level should we cluster?</a></li>
</ul></li>
<li class="chapter" data-level="9.6" data-path="cluster.html"><a href="cluster.html#what-to-do-when-there-are-few-clusters"><i class="fa fa-check"></i><b>9.6</b> What to do when there are few clusters?</a>
<ul>
<li class="chapter" data-level="9.6.1" data-path="cluster.html"><a href="cluster.html#aggregation"><i class="fa fa-check"></i><b>9.6.1</b> Aggregation</a></li>
<li class="chapter" data-level="9.6.2" data-path="cluster.html"><a href="cluster.html#permutation-tests"><i class="fa fa-check"></i><b>9.6.2</b> Permutation tests</a></li>
<li class="chapter" data-level="9.6.3" data-path="cluster.html"><a href="cluster.html#wild-bootstrap"><i class="fa fa-check"></i><b>9.6.3</b> Wild bootstrap</a></li>
<li class="chapter" data-level="9.6.4" data-path="cluster.html"><a href="cluster.html#ibragimov-and-muller-2010-group-based-inference"><i class="fa fa-check"></i><b>9.6.4</b> Ibragimov and Muller (2010) group-based inference</a></li>
</ul></li>
<li class="chapter" data-level="9.7" data-path="cluster.html"><a href="cluster.html#CLTDD"><i class="fa fa-check"></i><b>9.7</b> Central Limit Theorems for Dependent Data</a></li>
<li class="chapter" data-level="9.8" data-path="cluster.html"><a href="cluster.html#DesignBasedClusters"><i class="fa fa-check"></i><b>9.8</b> Sampling-based and design-based approaches to clustering</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="LaLonde.html"><a href="LaLonde.html"><i class="fa fa-check"></i><b>10</b> LaLonde Tests</a></li>
<li class="chapter" data-level="11" data-path="Diffusion.html"><a href="Diffusion.html"><i class="fa fa-check"></i><b>11</b> Diffusion effects</a></li>
<li class="chapter" data-level="12" data-path="Distribution.html"><a href="Distribution.html"><i class="fa fa-check"></i><b>12</b> Distributional effects</a></li>
<li class="chapter" data-level="13" data-path="meta.html"><a href="meta.html"><i class="fa fa-check"></i><b>13</b> Meta-analysis and Publication Bias</a>
<ul>
<li class="chapter" data-level="13.1" data-path="meta.html"><a href="meta.html#meta-analysis"><i class="fa fa-check"></i><b>13.1</b> Meta-analysis</a>
<ul>
<li class="chapter" data-level="13.1.1" data-path="meta.html"><a href="meta.html#basic-setting"><i class="fa fa-check"></i><b>13.1.1</b> Basic setting</a></li>
<li class="chapter" data-level="13.1.2" data-path="meta.html"><a href="meta.html#why-vote-counting-does-not-work"><i class="fa fa-check"></i><b>13.1.2</b> Why vote-counting does not work</a></li>
<li class="chapter" data-level="13.1.3" data-path="meta.html"><a href="meta.html#MetaWA"><i class="fa fa-check"></i><b>13.1.3</b> Meta-analysis when treatment effects are homogeneous: the fixed effects approach</a></li>
<li class="chapter" data-level="13.1.4" data-path="meta.html"><a href="meta.html#meta-analysis-when-treatment-effects-are-heterogeneous-the-random-effects-approach"><i class="fa fa-check"></i><b>13.1.4</b> Meta-analysis when treatment effects are heterogeneous: the random effects approach</a></li>
<li class="chapter" data-level="13.1.5" data-path="meta.html"><a href="meta.html#meta-regression"><i class="fa fa-check"></i><b>13.1.5</b> Meta-regression</a></li>
<li class="chapter" data-level="13.1.6" data-path="meta.html"><a href="meta.html#constantly-updated-meta-analysis"><i class="fa fa-check"></i><b>13.1.6</b> Constantly updated meta-analysis</a></li>
</ul></li>
<li class="chapter" data-level="13.2" data-path="meta.html"><a href="meta.html#publication-bias-and-site-selection-bias"><i class="fa fa-check"></i><b>13.2</b> Publication bias and site selection bias</a>
<ul>
<li class="chapter" data-level="13.2.1" data-path="meta.html"><a href="meta.html#sources-of-publication-bias-and-of-site-selection-bias-and-questionable-research-practices"><i class="fa fa-check"></i><b>13.2.1</b> Sources of publication bias and of site selection bias and Questionable Research Practices</a></li>
<li class="chapter" data-level="13.2.2" data-path="meta.html"><a href="meta.html#detection-of-and-correction-for-publication-bias"><i class="fa fa-check"></i><b>13.2.2</b> Detection of and correction for publication bias</a></li>
<li class="chapter" data-level="13.2.3" data-path="meta.html"><a href="meta.html#getting-rid-of-publication-bias-registered-reports-and-pre-analysis-plans"><i class="fa fa-check"></i><b>13.2.3</b> Getting rid of publication bias: registered reports and pre-analysis plans</a></li>
<li class="chapter" data-level="13.2.4" data-path="meta.html"><a href="meta.html#detection-of-and-correction-for-site-selection-bias"><i class="fa fa-check"></i><b>13.2.4</b> Detection of and correction for site selection bias</a></li>
<li class="chapter" data-level="13.2.5" data-path="meta.html"><a href="meta.html#vote-counting-and-publication-bias"><i class="fa fa-check"></i><b>13.2.5</b> Vote counting and publication bias</a></li>
<li class="chapter" data-level="13.2.6" data-path="meta.html"><a href="meta.html#the-value-of-a-statistically-significant-result"><i class="fa fa-check"></i><b>13.2.6</b> The value of a statistically significant result</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="14" data-path="Bounds.html"><a href="Bounds.html"><i class="fa fa-check"></i><b>14</b> Bounds</a></li>
<li class="chapter" data-level="15" data-path="mediation-analysis.html"><a href="mediation-analysis.html"><i class="fa fa-check"></i><b>15</b> Mediation Analysis</a>
<ul>
<li class="chapter" data-level="15.1" data-path="mediation-analysis.html"><a href="mediation-analysis.html#mediation-analysis-a-framework"><i class="fa fa-check"></i><b>15.1</b> Mediation analysis: a framework</a>
<ul>
<li class="chapter" data-level="15.1.1" data-path="mediation-analysis.html"><a href="mediation-analysis.html#defining-mediated-and-unmediated-treatment-effects"><i class="fa fa-check"></i><b>15.1.1</b> Defining mediated and unmediated treatment effects</a></li>
<li class="chapter" data-level="15.1.2" data-path="mediation-analysis.html"><a href="mediation-analysis.html#decomposing-mediated-and-unmediated-effects"><i class="fa fa-check"></i><b>15.1.2</b> Decomposing mediated and unmediated effects</a></li>
</ul></li>
<li class="chapter" data-level="15.2" data-path="mediation-analysis.html"><a href="mediation-analysis.html#the-fundamental-problem-of-mediation-analysis"><i class="fa fa-check"></i><b>15.2</b> The Fundamental Problem of Mediation Analysis</a>
<ul>
<li class="chapter" data-level="15.2.1" data-path="mediation-analysis.html"><a href="mediation-analysis.html#the-fundamental-problem-of-mediation-analysis-1"><i class="fa fa-check"></i><b>15.2.1</b> The Fundamental Problem of Mediation Analysis</a></li>
<li class="chapter" data-level="15.2.2" data-path="mediation-analysis.html"><a href="mediation-analysis.html#biases-of-intuitive-comparisons"><i class="fa fa-check"></i><b>15.2.2</b> Biases of Intuitive Comparisons</a></li>
</ul></li>
<li class="chapter" data-level="15.3" data-path="mediation-analysis.html"><a href="mediation-analysis.html#mediation-analysis-with-experimental-data"><i class="fa fa-check"></i><b>15.3</b> Mediation analysis with experimental data</a>
<ul>
<li class="chapter" data-level="15.3.1" data-path="mediation-analysis.html"><a href="mediation-analysis.html#mediation-analysis-in-the-parallel-design"><i class="fa fa-check"></i><b>15.3.1</b> Mediation analysis in the Parallel design</a></li>
<li class="chapter" data-level="15.3.2" data-path="mediation-analysis.html"><a href="mediation-analysis.html#mediation-analysis-in-the-sequential-self-selection-design"><i class="fa fa-check"></i><b>15.3.2</b> Mediation analysis in the Sequential Self-Selection design</a></li>
<li class="chapter" data-level="15.3.3" data-path="mediation-analysis.html"><a href="mediation-analysis.html#mediation-analysis-in-the-crossover-design"><i class="fa fa-check"></i><b>15.3.3</b> Mediation analysis in the Crossover design</a></li>
</ul></li>
<li class="chapter" data-level="15.4" data-path="mediation-analysis.html"><a href="mediation-analysis.html#mediation-analysis-under-unconfoundedness"><i class="fa fa-check"></i><b>15.4</b> Mediation analysis under unconfoundedness</a>
<ul>
<li class="chapter" data-level="15.4.1" data-path="mediation-analysis.html"><a href="mediation-analysis.html#non-parametric-identification-under-sequential-ignorability"><i class="fa fa-check"></i><b>15.4.1</b> Non-parametric identification under sequential ignorability</a></li>
<li class="chapter" data-level="15.4.2" data-path="mediation-analysis.html"><a href="mediation-analysis.html#mediation-analysis-under-sequential-ignorability-in-linear-models"><i class="fa fa-check"></i><b>15.4.2</b> Mediation analysis under sequential ignorability in linear models</a></li>
</ul></li>
<li class="chapter" data-level="15.5" data-path="mediation-analysis.html"><a href="mediation-analysis.html#mediation-analysis-with-panel-data"><i class="fa fa-check"></i><b>15.5</b> Mediation analysis with panel data</a></li>
<li class="chapter" data-level="15.6" data-path="mediation-analysis.html"><a href="mediation-analysis.html#mediation-analysis-with-instruments"><i class="fa fa-check"></i><b>15.6</b> Mediation analysis with instruments</a></li>
</ul></li>
<li class="appendix"><span><b>Appendix</b></span></li>
<li class="chapter" data-level="A" data-path="proofs.html"><a href="proofs.html"><i class="fa fa-check"></i><b>A</b> Proofs</a>
<ul>
<li class="chapter" data-level="A.1" data-path="proofs.html"><a href="proofs.html#proofs-of-results-in-chapter-reffpsi"><i class="fa fa-check"></i><b>A.1</b> Proofs of results in Chapter @ref(FPSI)</a>
<ul>
<li class="chapter" data-level="A.1.1" data-path="proofs.html"><a href="proofs.html#proofcheb"><i class="fa fa-check"></i><b>A.1.1</b> Proof of Theorem @ref(thm:uppsampnoise)</a></li>
<li class="chapter" data-level="A.1.2" data-path="proofs.html"><a href="proofs.html#proofCLT"><i class="fa fa-check"></i><b>A.1.2</b> Proof of Theorem @ref(thm:asympnoiseWW)</a></li>
</ul></li>
<li class="chapter" data-level="A.2" data-path="proofs.html"><a href="proofs.html#proofs-of-results-in-chapter-refrct"><i class="fa fa-check"></i><b>A.2</b> Proofs of results in Chapter @ref(RCT)</a>
<ul>
<li class="chapter" data-level="A.2.1" data-path="proofs.html"><a href="proofs.html#proofIdentLATE"><i class="fa fa-check"></i><b>A.2.1</b> Proof of Theorem @ref(thm:IdentLATE)</a></li>
<li class="chapter" data-level="A.2.2" data-path="proofs.html"><a href="proofs.html#proofWaldIV"><i class="fa fa-check"></i><b>A.2.2</b> Proof of Theorem @ref(thm:WaldIV)</a></li>
<li class="chapter" data-level="A.2.3" data-path="proofs.html"><a href="proofs.html#ProofAsymWald"><i class="fa fa-check"></i><b>A.2.3</b> Proof of Theorem @ref(thm:asymWald)</a></li>
</ul></li>
<li class="chapter" data-level="A.3" data-path="proofs.html"><a href="proofs.html#proofs-of-results-in-chapter-refne"><i class="fa fa-check"></i><b>A.3</b> Proofs of results in Chapter @ref(NE)</a>
<ul>
<li class="chapter" data-level="A.3.1" data-path="proofs.html"><a href="proofs.html#proofEstimDID"><i class="fa fa-check"></i><b>A.3.1</b> Proof of Theorem @ref(thm:EstimDID)</a></li>
<li class="chapter" data-level="A.3.2" data-path="proofs.html"><a href="proofs.html#proofasympnoiseDIDCross"><i class="fa fa-check"></i><b>A.3.2</b> Proof of Theorem @ref(thm:asympnoiseDIDCross)</a></li>
<li class="chapter" data-level="A.3.3" data-path="proofs.html"><a href="proofs.html#proofEquivDIDSApop"><i class="fa fa-check"></i><b>A.3.3</b> Proof of Theorem @ref(thm:EquivDIDSApop)</a></li>
<li class="chapter" data-level="A.3.4" data-path="proofs.html"><a href="proofs.html#proofEquivDIDSAsamp"><i class="fa fa-check"></i><b>A.3.4</b> Proof of Theorem @ref(thm:EquivDIDSAsamp)</a></li>
<li class="chapter" data-level="A.3.5" data-path="proofs.html"><a href="proofs.html#proofasympnoiseSACross"><i class="fa fa-check"></i><b>A.3.5</b> Proof of Theorem @ref(thm:asympnoiseSACross)</a></li>
<li class="chapter" data-level="A.3.6" data-path="proofs.html"><a href="proofs.html#proofasympnoiseSATTCross"><i class="fa fa-check"></i><b>A.3.6</b> Proof of Theorem @ref(thm:asympnoiseSATTCross)</a></li>
<li class="chapter" data-level="A.3.7" data-path="proofs.html"><a href="proofs.html#proofasympnoiseSAPanel"><i class="fa fa-check"></i><b>A.3.7</b> Proof of Theorem @ref(thm:asympnoiseSAPanel)</a></li>
<li class="chapter" data-level="A.3.8" data-path="proofs.html"><a href="proofs.html#proofasympnoiseSATTPanel"><i class="fa fa-check"></i><b>A.3.8</b> Proof of Theorem @ref(thm:asympnoiseSATTPanel)</a></li>
</ul></li>
<li class="chapter" data-level="A.4" data-path="proofs.html"><a href="proofs.html#proofs-of-results-in-chapter-refom"><i class="fa fa-check"></i><b>A.4</b> Proofs of results in Chapter @ref(OM)</a>
<ul>
<li class="chapter" data-level="A.4.1" data-path="proofs.html"><a href="proofs.html#proofAsympWWOLS10"><i class="fa fa-check"></i><b>A.4.1</b> Proof of Theorem @ref(thm:AsympWWOLS10)</a></li>
</ul></li>
<li class="chapter" data-level="A.5" data-path="proofs.html"><a href="proofs.html#proofs-of-results-in-chapter-refcluster"><i class="fa fa-check"></i><b>A.5</b> Proofs of results in Chapter @ref(cluster)</a>
<ul>
<li class="chapter" data-level="A.5.1" data-path="proofs.html"><a href="proofs.html#proofVarWWClus"><i class="fa fa-check"></i><b>A.5.1</b> Proof of Theorem @ref(thm:VarWWClus)</a></li>
<li class="chapter" data-level="A.5.2" data-path="proofs.html"><a href="proofs.html#proofasympnoiseSATTPanelAR1"><i class="fa fa-check"></i><b>A.5.2</b> Proof of Theorem @ref(thm:asympnoiseSATTPanelAR1)</a></li>
<li class="chapter" data-level="A.5.3" data-path="proofs.html"><a href="proofs.html#proofVarWWSpatial"><i class="fa fa-check"></i><b>A.5.3</b> Proof of Theorem @ref(thm:VarWWSpatial)</a></li>
</ul></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Statistical Tools for Causal Inference</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="cluster" class="section level1 hasAnchor" number="9">
<h1><span class="header-section-number">Chapter 9</span> Clustering<a href="cluster.html#cluster" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>Until now, we have assumed throughout the book that different units, say <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>, with <span class="math inline">\(i\neq j\)</span>, never interact in any way.
One way we have encoded that is by implicitly assuming that the treatment of individual <span class="math inline">\(i\)</span> has no impact on the outcomes of individual <span class="math inline">\(j\)</span>.
We will clarify this assumption in Chapter <a href="Diffusion.html#Diffusion">11</a>, and study ways to relax it.
Another way we have assumed an absence of interactions is by assuming that all potential outcomes and treatment indicators are independently and identically distributed across observations.
We have encoded this restriction at various points, first with Assumption <a href="FPSI.html#hyp:iid">2.2</a> in the context of estimating the sampling noise in Randomized Controlled Trials, and then with Assumptions <a href="NE.html#hyp:iidDID">4.15</a> and <a href="NE.html#hyp:iidDIDCross">4.17</a> in DID settings.
This assumption enabled us to leverage the Central Limit Theorem, the most powerful tool we can use to derive asymptotic approximations to our estimators.</p>
<p>The <em>i.i.d.</em> assumption is nevertheless extremely restrictive.
It excludes various cases that we are likely to encouter in real life scenarios.
For example, this assumption will be wrong if we allocate the treatment at the level of a group of units, such as a village or a firm for example.
Groups of units are generally called <strong>clusters</strong>.
In that case, the treatment indicator will not be i.i.d. across observations, since knowing the treatment status of a unit in a given cluster can help us predict the treatment status of its neighbors in the same cluster, so Assumption <a href="FPSI.html#hyp:iid">2.2</a> would be violated.
The i.i.d. assumption will also be wrong in panel data with repeated observations of the same units if the outcomes are correlated over time for reasons other than having a fixed effect in common.
For example, any case in which shocks to outcomes around the fixed effect are somewhat persistent over time, we will have correlation between the observations of the same unit over time, and between the changes in outcomes of the same unit over time.
This last issue would violate Assumption <a href="NE.html#hyp:iidDID">4.15</a>.
There are many instances where the shocks to outcomes are likely correlated over time, such as productivity shocks, earnings, education, health, savings, etc, that is most of the outcomes we are generally interested in.
Finally, the i.i.d. assumption will also be violated in DID settings in repeated cross sections if the treatment is allocated at a more aggregate level than that of the individual unit.
For example, if we study the consequences of laws that vary at the levels of U.S. counties or States, such as minimum wage laws for example, and we have observations on firm’s TFP and employment level, or on individuals’ earnings, then we have correlations between the treatment status of units belonging to the same cluster, and probably the outcomes are correlated as well between the units in the same cluster.</p>
<p>In this chapter, we are going to examine what happens to our traditional estimators when relaxing the i.i.d. assumption, and which new estimators we can use, and what types of diagnostic tests we can make use of in order to assess the severity of the issue.
Clustering, as this issue is generally called, has been the topic of a <strong>very</strong> large literature in econometrics, whose results are sometimes vague, sometimes hard to comprehend or to reconcile, etc.
What we are going to do is to try to carve a path through this literature, trying to enlighten its main motivations, its main tools and its main results.
We are first going to study the case of clustering in the context of Randomized Controlled Trials.
We will then move on to the case of temporal autocorrelation in panel data and we will end with the case of panel data with clustering across time and between observations in each cross section.</p>
<div id="ClusterRCT" class="section level2 hasAnchor" number="9.1">
<h2><span class="header-section-number">9.1</span> Clustering in Randomized Controlled Trials<a href="cluster.html#ClusterRCT" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>What I propose is to first start to see what the problem of clustering does to sampling noise, and how much our default estimator of sampling noise assuming no clustering is biased.
I will then introduce the notion of design effect, which is a way to quantify the effect of clustering on sampling noise estimates.
Finally, I will propose ways to provide estimates of sampling noise that account for clustering.</p>
<div id="an-example" class="section level3 hasAnchor" number="9.1.1">
<h3><span class="header-section-number">9.1.1</span> An example<a href="cluster.html#an-example" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Let us first see how that happens in our example before deriving the reason for why we have such a problem and the possible solutions.
For that, we are going to simulate data with clusters (such as villages) and we are going to have two features of he data generating process that happen at the cluster level:</p>
<ol style="list-style-type: decimal">
<li>The treatment is going to be randomized at the cluster level.
We thus have a clustered randomized controlled trial, where randomization is at the level of clusters regrouping several individual units of observation.
For example, think of a classroom where we randomize a new treatment and we observe outcomes at the student level (grades, health status, participation, etc), or think of a cvaccination camoaign randomized at the village level.</li>
<li>The outcome is going to be autocorrelated within clusters.
For example, think of the common determinants of school success (such as the teacher, the parents, the overall conditions at the school) or of the health status in a village (climate, sanitation, pressure by parasites, etc) at the cluster level.
These common determinants make the outcomes of two people taken at random in a given cluster more similar than those of two people taken at random in the whole population.
The share of the variance in outcomes explained by the variance across clusters is called the intra-cluster correlation coefficient (ICC) and is going to play a key role in what follows.</li>
</ol>
<div class="example">
<p><span id="exm:unnamed-chunk-359" class="example"><strong>Example 9.1  </strong></span>Let’s see how we model all of that in our example.
We choose to generate the outcomes of individual <span class="math inline">\(i\)</span> in cluster <span class="math inline">\(c\)</span> in period <span class="math inline">\(t\)</span> as follows:</p>
</div>
<p><span class="math display">\[\begin{align*}    
  y^0_{i,c,t} &amp; = \mu_{i,c} + U_{i,t} \\
  \mu_{i,c} &amp; = \mu^C_c + \mu^U_i \\
  U_{i,t} &amp; = \rho U_{i,t-1} + \epsilon_{i,t}, 
\end{align*}\]</span></p>
<p>where <span class="math inline">\(U_{i,0}\)</span>, <span class="math inline">\(\epsilon_{i,t}\)</span>, <span class="math inline">\(\mu^U_i\)</span> and <span class="math inline">\(\mu_c\)</span> are i.i.d. shocks independent of each other.
I introduce a panel data structure because it will be useful for the simulations in the next section.</p>
<p><span class="math inline">\(\mu_c\)</span> is the error term varying at the cluster level.
We call it a cluster fixed effect.
The intra-cluster correlation coefficient is equal to the ratio between the variance in outcomes between clusters and the total variance in outcomes:</p>
<p><span class="math display">\[\begin{align*}
  ICC_t &amp; = \frac{\sigma^2_{\mu_c}}{\sigma^2_{\mu^c}+\sigma^2_{\mu^U}+\sigma^2_{U_t}}.
\end{align*}\]</span></p>
<p>Let’s generate some data and see what an increase in ICC does to our estimates of the treatment effect in a Brute Force design.
As usual, we are going to use the With/Without estimator to compute the treatment effect.
Let us first set parameter values:</p>
<div class="sourceCode" id="cb355"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb355-1"><a href="cluster.html#cb355-1" aria-hidden="true" tabindex="-1"></a>param <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">8</span>,.<span class="dv">5</span>,.<span class="dv">28</span>,<span class="dv">1500</span>,<span class="fl">0.9</span>,<span class="fl">0.01</span>,<span class="fl">0.05</span>,<span class="fl">0.05</span>,<span class="fl">0.05</span>,<span class="fl">0.1</span>)</span>
<span id="cb355-2"><a href="cluster.html#cb355-2" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(param) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;barmu&quot;</span>,<span class="st">&quot;sigma2mu&quot;</span>,<span class="st">&quot;sigma2U&quot;</span>,<span class="st">&quot;barY&quot;</span>,<span class="st">&quot;rho&quot;</span>,<span class="st">&quot;theta&quot;</span>,<span class="st">&quot;sigma2epsilon&quot;</span>,<span class="st">&quot;sigma2eta&quot;</span>,<span class="st">&quot;delta&quot;</span>,<span class="st">&quot;baralpha&quot;</span>)</span></code></pre></div>
<p>Let us then simulate one dataset:</p>
<div class="sourceCode" id="cb356"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb356-1"><a href="cluster.html#cb356-1" aria-hidden="true" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="dv">1000</span></span>
<span id="cb356-2"><a href="cluster.html#cb356-2" aria-hidden="true" tabindex="-1"></a>ICC.mu <span class="ot">&lt;-</span> <span class="fl">0.2</span></span>
<span id="cb356-3"><a href="cluster.html#cb356-3" aria-hidden="true" tabindex="-1"></a>Nclusters <span class="ot">&lt;-</span> <span class="dv">100</span></span>
<span id="cb356-4"><a href="cluster.html#cb356-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb356-5"><a href="cluster.html#cb356-5" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1234</span>)</span>
<span id="cb356-6"><a href="cluster.html#cb356-6" aria-hidden="true" tabindex="-1"></a><span class="co"># I am going to draw a cluster fixed effect</span></span>
<span id="cb356-7"><a href="cluster.html#cb356-7" aria-hidden="true" tabindex="-1"></a>muC <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(Nclusters,<span class="dv">0</span>,<span class="fu">sqrt</span>(param[<span class="st">&quot;sigma2mu&quot;</span>]<span class="sc">*</span>ICC.mu))</span>
<span id="cb356-8"><a href="cluster.html#cb356-8" aria-hidden="true" tabindex="-1"></a>muC <span class="ot">&lt;-</span> <span class="fu">rep</span>(muC,<span class="at">each=</span>N<span class="sc">/</span>Nclusters)</span>
<span id="cb356-9"><a href="cluster.html#cb356-9" aria-hidden="true" tabindex="-1"></a><span class="co"># I draw an individual fixed effect with the remaining variance</span></span>
<span id="cb356-10"><a href="cluster.html#cb356-10" aria-hidden="true" tabindex="-1"></a>muU <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(N,<span class="dv">0</span>,<span class="fu">sqrt</span>(param[<span class="st">&quot;sigma2mu&quot;</span>]<span class="sc">*</span>(<span class="dv">1</span><span class="sc">-</span>ICC.mu)))</span>
<span id="cb356-11"><a href="cluster.html#cb356-11" aria-hidden="true" tabindex="-1"></a>mu <span class="ot">&lt;-</span> param[<span class="st">&quot;barmu&quot;</span>] <span class="sc">+</span> muC <span class="sc">+</span> muU </span>
<span id="cb356-12"><a href="cluster.html#cb356-12" aria-hidden="true" tabindex="-1"></a>UBB <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(N,<span class="dv">0</span>,<span class="fu">sqrt</span>(param[<span class="st">&quot;sigma2U&quot;</span>]))</span>
<span id="cb356-13"><a href="cluster.html#cb356-13" aria-hidden="true" tabindex="-1"></a>yBB <span class="ot">&lt;-</span> mu <span class="sc">+</span> UBB </span>
<span id="cb356-14"><a href="cluster.html#cb356-14" aria-hidden="true" tabindex="-1"></a>YBB <span class="ot">&lt;-</span> <span class="fu">exp</span>(yBB)</span>
<span id="cb356-15"><a href="cluster.html#cb356-15" aria-hidden="true" tabindex="-1"></a>epsilonB <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(N,<span class="dv">0</span>,<span class="fu">sqrt</span>(param[<span class="st">&quot;sigma2epsilon&quot;</span>]))</span>
<span id="cb356-16"><a href="cluster.html#cb356-16" aria-hidden="true" tabindex="-1"></a>U0B <span class="ot">&lt;-</span> param[<span class="st">&quot;rho&quot;</span>]<span class="sc">*</span>UBB <span class="sc">+</span> epsilonB</span>
<span id="cb356-17"><a href="cluster.html#cb356-17" aria-hidden="true" tabindex="-1"></a>y0B <span class="ot">&lt;-</span> mu <span class="sc">+</span>  U0B </span>
<span id="cb356-18"><a href="cluster.html#cb356-18" aria-hidden="true" tabindex="-1"></a>epsilonA <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(N,<span class="dv">0</span>,<span class="fu">sqrt</span>(param[<span class="st">&quot;sigma2epsilon&quot;</span>]))</span>
<span id="cb356-19"><a href="cluster.html#cb356-19" aria-hidden="true" tabindex="-1"></a>U0A <span class="ot">&lt;-</span> param[<span class="st">&quot;rho&quot;</span>]<span class="sc">*</span>U0B <span class="sc">+</span> epsilonA</span>
<span id="cb356-20"><a href="cluster.html#cb356-20" aria-hidden="true" tabindex="-1"></a>y0A <span class="ot">&lt;-</span> mu <span class="sc">+</span>  U0A <span class="sc">+</span> param[<span class="st">&quot;delta&quot;</span>]</span>
<span id="cb356-21"><a href="cluster.html#cb356-21" aria-hidden="true" tabindex="-1"></a>eta<span class="ot">&lt;-</span> <span class="fu">rnorm</span>(N,<span class="dv">0</span>,<span class="fu">sqrt</span>(param[<span class="st">&quot;sigma2eta&quot;</span>]))</span>
<span id="cb356-22"><a href="cluster.html#cb356-22" aria-hidden="true" tabindex="-1"></a>alpha <span class="ot">&lt;-</span> param[<span class="st">&quot;baralpha&quot;</span>]<span class="sc">+</span>  param[<span class="st">&quot;theta&quot;</span>]<span class="sc">*</span>mu <span class="sc">+</span> eta</span>
<span id="cb356-23"><a href="cluster.html#cb356-23" aria-hidden="true" tabindex="-1"></a>y1B <span class="ot">&lt;-</span> y0B<span class="sc">+</span>alpha</span>
<span id="cb356-24"><a href="cluster.html#cb356-24" aria-hidden="true" tabindex="-1"></a>y1A <span class="ot">&lt;-</span> y0A<span class="sc">+</span>alpha</span>
<span id="cb356-25"><a href="cluster.html#cb356-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb356-26"><a href="cluster.html#cb356-26" aria-hidden="true" tabindex="-1"></a><span class="co"># randomized allocation at the cluster level</span></span>
<span id="cb356-27"><a href="cluster.html#cb356-27" aria-hidden="true" tabindex="-1"></a>Rs <span class="ot">&lt;-</span> <span class="fu">runif</span>(Nclusters)</span>
<span id="cb356-28"><a href="cluster.html#cb356-28" aria-hidden="true" tabindex="-1"></a><span class="co"># cluster level treatment vector</span></span>
<span id="cb356-29"><a href="cluster.html#cb356-29" aria-hidden="true" tabindex="-1"></a>Rc <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(Rs<span class="sc">&lt;=</span>.<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">0</span>)</span>
<span id="cb356-30"><a href="cluster.html#cb356-30" aria-hidden="true" tabindex="-1"></a><span class="co"># individual level treatment vector</span></span>
<span id="cb356-31"><a href="cluster.html#cb356-31" aria-hidden="true" tabindex="-1"></a>R <span class="ot">&lt;-</span> <span class="fu">rep</span>(Rc,<span class="at">each=</span>N<span class="sc">/</span>Nclusters)</span>
<span id="cb356-32"><a href="cluster.html#cb356-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb356-33"><a href="cluster.html#cb356-33" aria-hidden="true" tabindex="-1"></a><span class="co"># outcomes</span></span>
<span id="cb356-34"><a href="cluster.html#cb356-34" aria-hidden="true" tabindex="-1"></a>yB <span class="ot">&lt;-</span> y0B</span>
<span id="cb356-35"><a href="cluster.html#cb356-35" aria-hidden="true" tabindex="-1"></a>yA <span class="ot">&lt;-</span> y1A<span class="sc">*</span>R<span class="sc">+</span>y0A<span class="sc">*</span>(<span class="dv">1</span><span class="sc">-</span>R)</span>
<span id="cb356-36"><a href="cluster.html#cb356-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb356-37"><a href="cluster.html#cb356-37" aria-hidden="true" tabindex="-1"></a><span class="co"># clusters</span></span>
<span id="cb356-38"><a href="cluster.html#cb356-38" aria-hidden="true" tabindex="-1"></a>cluster <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span>Nclusters</span>
<span id="cb356-39"><a href="cluster.html#cb356-39" aria-hidden="true" tabindex="-1"></a>cluster <span class="ot">&lt;-</span> <span class="fu">rep</span>(cluster,<span class="at">each=</span>N<span class="sc">/</span>Nclusters)</span></code></pre></div>
<p>Let us finally run a set of Monte Carlo simulations, varying ICC:</p>
<div class="sourceCode" id="cb357"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb357-1"><a href="cluster.html#cb357-1" aria-hidden="true" tabindex="-1"></a>monte.carlo.BF.ICC <span class="ot">&lt;-</span> <span class="cf">function</span>(s,N,Nclusters,ICC.mu,param){</span>
<span id="cb357-2"><a href="cluster.html#cb357-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set.seed</span>(s)</span>
<span id="cb357-3"><a href="cluster.html#cb357-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># I am going to draw a cluster fixed effect</span></span>
<span id="cb357-4"><a href="cluster.html#cb357-4" aria-hidden="true" tabindex="-1"></a>  muC <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(Nclusters,<span class="dv">0</span>,<span class="fu">sqrt</span>(param[<span class="st">&quot;sigma2mu&quot;</span>]<span class="sc">*</span>ICC.mu))</span>
<span id="cb357-5"><a href="cluster.html#cb357-5" aria-hidden="true" tabindex="-1"></a>  muC <span class="ot">&lt;-</span> <span class="fu">rep</span>(muC,<span class="at">each=</span>N<span class="sc">/</span>Nclusters)</span>
<span id="cb357-6"><a href="cluster.html#cb357-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># I draw an individual fixed effect with the remaining variance</span></span>
<span id="cb357-7"><a href="cluster.html#cb357-7" aria-hidden="true" tabindex="-1"></a>  muU <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(N,<span class="dv">0</span>,<span class="fu">sqrt</span>(param[<span class="st">&quot;sigma2mu&quot;</span>]<span class="sc">*</span>(<span class="dv">1</span><span class="sc">-</span>ICC.mu)))</span>
<span id="cb357-8"><a href="cluster.html#cb357-8" aria-hidden="true" tabindex="-1"></a>  mu <span class="ot">&lt;-</span> param[<span class="st">&quot;barmu&quot;</span>] <span class="sc">+</span> muC <span class="sc">+</span> muU </span>
<span id="cb357-9"><a href="cluster.html#cb357-9" aria-hidden="true" tabindex="-1"></a>  UBB <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(N,<span class="dv">0</span>,<span class="fu">sqrt</span>(param[<span class="st">&quot;sigma2U&quot;</span>]))</span>
<span id="cb357-10"><a href="cluster.html#cb357-10" aria-hidden="true" tabindex="-1"></a>  yBB <span class="ot">&lt;-</span> mu <span class="sc">+</span> UBB </span>
<span id="cb357-11"><a href="cluster.html#cb357-11" aria-hidden="true" tabindex="-1"></a>  YBB <span class="ot">&lt;-</span> <span class="fu">exp</span>(yBB)</span>
<span id="cb357-12"><a href="cluster.html#cb357-12" aria-hidden="true" tabindex="-1"></a>  epsilonB <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(N,<span class="dv">0</span>,<span class="fu">sqrt</span>(param[<span class="st">&quot;sigma2epsilon&quot;</span>]))</span>
<span id="cb357-13"><a href="cluster.html#cb357-13" aria-hidden="true" tabindex="-1"></a>  U0B <span class="ot">&lt;-</span> param[<span class="st">&quot;rho&quot;</span>]<span class="sc">*</span>UBB <span class="sc">+</span> epsilonB</span>
<span id="cb357-14"><a href="cluster.html#cb357-14" aria-hidden="true" tabindex="-1"></a>  y0B <span class="ot">&lt;-</span> mu <span class="sc">+</span>  U0B </span>
<span id="cb357-15"><a href="cluster.html#cb357-15" aria-hidden="true" tabindex="-1"></a>  epsilonA <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(N,<span class="dv">0</span>,<span class="fu">sqrt</span>(param[<span class="st">&quot;sigma2epsilon&quot;</span>]))</span>
<span id="cb357-16"><a href="cluster.html#cb357-16" aria-hidden="true" tabindex="-1"></a>  U0A <span class="ot">&lt;-</span> param[<span class="st">&quot;rho&quot;</span>]<span class="sc">*</span>U0B <span class="sc">+</span> epsilonA</span>
<span id="cb357-17"><a href="cluster.html#cb357-17" aria-hidden="true" tabindex="-1"></a>  y0A <span class="ot">&lt;-</span> mu <span class="sc">+</span>  U0A <span class="sc">+</span> param[<span class="st">&quot;delta&quot;</span>]</span>
<span id="cb357-18"><a href="cluster.html#cb357-18" aria-hidden="true" tabindex="-1"></a>  eta<span class="ot">&lt;-</span> <span class="fu">rnorm</span>(N,<span class="dv">0</span>,<span class="fu">sqrt</span>(param[<span class="st">&quot;sigma2eta&quot;</span>]))</span>
<span id="cb357-19"><a href="cluster.html#cb357-19" aria-hidden="true" tabindex="-1"></a>  alpha <span class="ot">&lt;-</span> param[<span class="st">&quot;baralpha&quot;</span>]<span class="sc">+</span>  param[<span class="st">&quot;theta&quot;</span>]<span class="sc">*</span>mu <span class="sc">+</span> eta</span>
<span id="cb357-20"><a href="cluster.html#cb357-20" aria-hidden="true" tabindex="-1"></a>  y1B <span class="ot">&lt;-</span> y0B<span class="sc">+</span>alpha</span>
<span id="cb357-21"><a href="cluster.html#cb357-21" aria-hidden="true" tabindex="-1"></a>  y1A <span class="ot">&lt;-</span> y0A<span class="sc">+</span>alpha</span>
<span id="cb357-22"><a href="cluster.html#cb357-22" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb357-23"><a href="cluster.html#cb357-23" aria-hidden="true" tabindex="-1"></a>  <span class="co"># randomized allocation at the cluster level</span></span>
<span id="cb357-24"><a href="cluster.html#cb357-24" aria-hidden="true" tabindex="-1"></a>  Rs <span class="ot">&lt;-</span> <span class="fu">runif</span>(Nclusters)</span>
<span id="cb357-25"><a href="cluster.html#cb357-25" aria-hidden="true" tabindex="-1"></a>  <span class="co"># cluster level treatment vector</span></span>
<span id="cb357-26"><a href="cluster.html#cb357-26" aria-hidden="true" tabindex="-1"></a>  Rc <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(Rs<span class="sc">&lt;=</span>.<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">0</span>)</span>
<span id="cb357-27"><a href="cluster.html#cb357-27" aria-hidden="true" tabindex="-1"></a>  <span class="co"># individual level treatment vector</span></span>
<span id="cb357-28"><a href="cluster.html#cb357-28" aria-hidden="true" tabindex="-1"></a>  R <span class="ot">&lt;-</span> <span class="fu">rep</span>(Rc,<span class="at">each=</span>N<span class="sc">/</span>Nclusters)</span>
<span id="cb357-29"><a href="cluster.html#cb357-29" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb357-30"><a href="cluster.html#cb357-30" aria-hidden="true" tabindex="-1"></a>  <span class="co"># outcomes</span></span>
<span id="cb357-31"><a href="cluster.html#cb357-31" aria-hidden="true" tabindex="-1"></a>  yB <span class="ot">&lt;-</span> y0B</span>
<span id="cb357-32"><a href="cluster.html#cb357-32" aria-hidden="true" tabindex="-1"></a>  yA <span class="ot">&lt;-</span> y1A<span class="sc">*</span>R<span class="sc">+</span>y0A<span class="sc">*</span>(<span class="dv">1</span><span class="sc">-</span>R)</span>
<span id="cb357-33"><a href="cluster.html#cb357-33" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb357-34"><a href="cluster.html#cb357-34" aria-hidden="true" tabindex="-1"></a>  <span class="co"># regression</span></span>
<span id="cb357-35"><a href="cluster.html#cb357-35" aria-hidden="true" tabindex="-1"></a>  ols.ww.BF <span class="ot">&lt;-</span> <span class="fu">lm</span>(yA <span class="sc">~</span> R)</span>
<span id="cb357-36"><a href="cluster.html#cb357-36" aria-hidden="true" tabindex="-1"></a>  ols.ww.BF.yB <span class="ot">&lt;-</span> <span class="fu">lm</span>(yA <span class="sc">~</span> R <span class="sc">+</span> yB)</span>
<span id="cb357-37"><a href="cluster.html#cb357-37" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb357-38"><a href="cluster.html#cb357-38" aria-hidden="true" tabindex="-1"></a>  <span class="co"># True ICC</span></span>
<span id="cb357-39"><a href="cluster.html#cb357-39" aria-hidden="true" tabindex="-1"></a>  data <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(<span class="fu">cbind</span>(yB,R))</span>
<span id="cb357-40"><a href="cluster.html#cb357-40" aria-hidden="true" tabindex="-1"></a>  cluster <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span>Nclusters</span>
<span id="cb357-41"><a href="cluster.html#cb357-41" aria-hidden="true" tabindex="-1"></a>  cluster <span class="ot">&lt;-</span> <span class="fu">rep</span>(cluster,<span class="at">each=</span>N<span class="sc">/</span>Nclusters)</span>
<span id="cb357-42"><a href="cluster.html#cb357-42" aria-hidden="true" tabindex="-1"></a>  data<span class="sc">$</span>cluster <span class="ot">&lt;-</span> cluster</span>
<span id="cb357-43"><a href="cluster.html#cb357-43" aria-hidden="true" tabindex="-1"></a>  data <span class="ot">&lt;-</span> <span class="fu">group_by</span>(data,cluster)</span>
<span id="cb357-44"><a href="cluster.html#cb357-44" aria-hidden="true" tabindex="-1"></a>  data <span class="ot">&lt;-</span> <span class="fu">merge</span>(data,<span class="fu">summarise</span>(data,<span class="at">yB.mean=</span><span class="fu">mean</span>(yB)))</span>
<span id="cb357-45"><a href="cluster.html#cb357-45" aria-hidden="true" tabindex="-1"></a>  ICC <span class="ot">&lt;-</span> <span class="fu">var</span>(data<span class="sc">$</span>yB.mean)<span class="sc">/</span><span class="fu">var</span>(yB)</span>
<span id="cb357-46"><a href="cluster.html#cb357-46" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb357-47"><a href="cluster.html#cb357-47" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">c</span>(ols.ww.BF<span class="sc">$</span>coef[[<span class="dv">2</span>]],ols.ww.BF.yB<span class="sc">$</span>coef[[<span class="dv">2</span>]],ICC))</span>
<span id="cb357-48"><a href="cluster.html#cb357-48" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb357-49"><a href="cluster.html#cb357-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb357-50"><a href="cluster.html#cb357-50" aria-hidden="true" tabindex="-1"></a>sf.simuls.BF.ICC <span class="ot">&lt;-</span> <span class="cf">function</span>(ICC.mu,N,Nclusters,Nsim,param){</span>
<span id="cb357-51"><a href="cluster.html#cb357-51" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sfInit</span>(<span class="at">parallel=</span><span class="cn">TRUE</span>,<span class="at">cpus=</span><span class="dv">8</span>)</span>
<span id="cb357-52"><a href="cluster.html#cb357-52" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sfLibrary</span>(dplyr)</span>
<span id="cb357-53"><a href="cluster.html#cb357-53" aria-hidden="true" tabindex="-1"></a>  sim <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">unlist</span>(<span class="fu">sfLapply</span>(<span class="dv">1</span><span class="sc">:</span>Nsim,monte.carlo.BF.ICC,<span class="at">N=</span>N,<span class="at">Nclusters=</span>Nclusters,<span class="at">ICC.mu=</span>ICC.mu,<span class="at">param=</span>param)),<span class="at">nrow=</span>Nsim,<span class="at">ncol=</span><span class="dv">3</span>,<span class="at">byrow=</span><span class="cn">TRUE</span>)</span>
<span id="cb357-54"><a href="cluster.html#cb357-54" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sfStop</span>()</span>
<span id="cb357-55"><a href="cluster.html#cb357-55" aria-hidden="true" tabindex="-1"></a>  <span class="fu">colnames</span>(sim) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&#39;BF&#39;</span>,<span class="st">&#39;BF.yB&#39;</span>,<span class="st">&#39;ICC&#39;</span>)</span>
<span id="cb357-56"><a href="cluster.html#cb357-56" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(sim)</span>
<span id="cb357-57"><a href="cluster.html#cb357-57" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb357-58"><a href="cluster.html#cb357-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb357-59"><a href="cluster.html#cb357-59" aria-hidden="true" tabindex="-1"></a>Nsim <span class="ot">&lt;-</span> <span class="dv">1000</span></span>
<span id="cb357-60"><a href="cluster.html#cb357-60" aria-hidden="true" tabindex="-1"></a><span class="co">#Nsim &lt;- 50</span></span>
<span id="cb357-61"><a href="cluster.html#cb357-61" aria-hidden="true" tabindex="-1"></a>ICC.val <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="fl">0.05</span>,<span class="fl">0.2</span>,<span class="fl">0.5</span>,<span class="fl">0.8</span>,<span class="dv">1</span>)</span>
<span id="cb357-62"><a href="cluster.html#cb357-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb357-63"><a href="cluster.html#cb357-63" aria-hidden="true" tabindex="-1"></a>simuls.BF.ICC <span class="ot">&lt;-</span> <span class="fu">lapply</span>(ICC.val,sf.simuls.BF.ICC,<span class="at">N=</span>N,<span class="at">Nclusters=</span>Nclusters,<span class="at">Nsim=</span>Nsim,<span class="at">param=</span>param)</span>
<span id="cb357-64"><a href="cluster.html#cb357-64" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(simuls.BF.ICC) <span class="ot">&lt;-</span> ICC.val</span></code></pre></div>
<p>Let us now present the results of the simulations:</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:MonteCarloBFICCHist"></span>
<img src="STCI_files/figure-html/MonteCarloBFICCHist-1.png" alt="Distribution of the $WW$ estimator in a Brute Force Design for various levels of ICC" width="65%" />
<p class="caption">
Figure 9.1: Distribution of the <span class="math inline">\(WW\)</span> estimator in a Brute Force Design for various levels of ICC
</p>
</div>
<p>Figure <a href="cluster.html#fig:MonteCarloBFICCHist">9.1</a> suggests that increasing the ICC increases sampling noise.
Let’s compute sampling noise formally:</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:precisionBFICC"></span>
<img src="STCI_files/figure-html/precisionBFICC-1.png" alt="Effect of ICC on the 99\% sampling noise of the WW estimator in a Brute Force design" width="65%" />
<p class="caption">
Figure 9.2: Effect of ICC on the 99% sampling noise of the WW estimator in a Brute Force design
</p>
</div>
<p>Figure <a href="cluster.html#fig:precisionBFICC">9.2</a> confirms that increasing the ICC increases sampling noise in a major way.
With a small ICC, sampling noise is equal to 0.28, while it is equal to 0.69 with the largest ICC.
The difference is more than sizable.</p>
<p>Increasing the ICC is equivalent to losing sample size.
The intuition for this result is that, with autocorrelated data, the Central Limit Theorem applies at a much slower pace.
The part of the error term that is common to all observations in a given cluster only vanishes as we add more clusters, not as we add more observations per cluster.
As a result, this part of sampling noise decreases with the square root of the number of clusters, not with the square root of the number of observations.</p>
<p>The second result to emerge from Figure <a href="cluster.html#fig:precisionBFICC">9.2</a> is that ignoring clustering would severely underestimate sampling noise.
The lower level of sampling noise on Figure <a href="cluster.html#fig:precisionBFICC">9.2</a> is roughly equal to the level of sampling noise that an estimator ignoring clustering would deliver (the estimator detailed in Theorem <a href="FPSI.html#thm:asympnoiseWW">2.5</a>).
Let’s compute the naive estimator of sampling noise based on Theorem <a href="FPSI.html#thm:asympnoiseWW">2.5</a>:</p>
<div class="sourceCode" id="cb358"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb358-1"><a href="cluster.html#cb358-1" aria-hidden="true" tabindex="-1"></a><span class="co"># OLS regression in the Brute Force data</span></span>
<span id="cb358-2"><a href="cluster.html#cb358-2" aria-hidden="true" tabindex="-1"></a>ols.ww <span class="ot">&lt;-</span> <span class="fu">lm</span>(yA<span class="sc">~</span>R)</span></code></pre></div>
<p>The naive estimate of sampling noise is thus 0.3.</p>
</div>
<div id="design-effect" class="section level3 hasAnchor" number="9.1.2">
<h3><span class="header-section-number">9.1.2</span> Design effect<a href="cluster.html#design-effect" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>A very useful way to understand what clustering does to sampling noise is to derive the variance of the With/Without estimator in the presence of clustering of a simple nature: when all the outcomes within a cluster are correlated in the same way and correlation between outcomes is zero outside of the clusters and all clusters have the same size.
This derivation enables us to introduce the notion of design effect, which is a way to quantify the effect of clustering on sampling noise estimates as a function of the ICC.
In order to make this derivation, we need to formally specify the covariance matrix of our error terms.</p>
<p>Let us assume that we have access to observations about <span class="math inline">\(N\)</span> units, allocated in <span class="math inline">\(n\)</span> clusters of equal size <span class="math inline">\(m\)</span>.
Among the <span class="math inline">\(n\)</span> clusters, <span class="math inline">\(n_1\)</span> are treated and <span class="math inline">\(n_0\)</span> are in the control group.
Let <span class="math inline">\(R_{i}\)</span> denote the randomized allocation variable for each unit <span class="math inline">\(i\)</span>, which takes value one when unit <span class="math inline">\(i\)</span> is located in a cluster <span class="math inline">\(c\)</span> that has been (randomly) allocated to the treatment and value zero otherwise.
Let <span class="math inline">\(R^C_{c}\)</span> denote the randomized allocation variable for each cluster <span class="math inline">\(c\)</span>, which takes value one when cluster <span class="math inline">\(c\)</span> has been (randomly) allocated to the treatment and value zero otherwise.
Let <span class="math inline">\(\mathbf{R}_c\)</span> be the vector of randomized allocations at the cluster level: it has length equal to <span class="math inline">\(n\)</span>, and each value is equal to <span class="math inline">\(R^C_{c}\)</span>.
Let us denote <span class="math inline">\(U_i^1=Y_i^1-\esp{Y_i^1|R_{i}=1}\)</span> and <span class="math inline">\(U_i^0=Y_i^0-\esp{Y_i^0|R_{i}=0}\)</span> and <span class="math inline">\(U_i=R_{i}U_i^1+(1-R_{i})U_i^0\)</span>.
Let <span class="math inline">\(U\)</span> be the vector of all <span class="math inline">\(U_i\)</span> error terms.
Let <span class="math inline">\(\sigma^2_1=\var{U_i^1}\)</span> and <span class="math inline">\(\sigma^2_0=\var{U_i^0}\)</span>.
Finally, let <span class="math inline">\(\Omega_1\)</span> and <span class="math inline">\(\Omega_0\)</span> be <span class="math inline">\(m\times m\)</span> matrices with a diagonal of one and off-diagonal terms all equal to <span class="math inline">\(\rho_1\)</span> and <span class="math inline">\(\rho_0\)</span> respectively, with <span class="math inline">\(\rho_1\)</span> and <span class="math inline">\(\rho_0\)</span> the Intra-Cluster Correlation Coefficient among the treated and untreated observation respectively.
We are now equipped to relax Assumption <a href="FPSI.html#hyp:iid">2.2</a>:</p>
<div class="hypothesis">
<p><span id="hyp:ClusteredErrors" class="hypothesis"><strong>Hypothesis 9.1  (Clustered Design) </strong></span>We assume that the error terms are clustered:</p>
<p><span class="math display">\[\begin{align*}
  \esp{UU&#39;} &amp; = \sigma^2_1\diag{\mathbf{R}_c}\otimes\Omega_1+\sigma^2_0(I-\diag{\mathbf{R}_c})\otimes\Omega_0.
\end{align*}\]</span></p>
</div>
<div class="remark">
<p><span id="unlabeled-div-207" class="remark"><em>Remark</em>. </span>Assumption <a href="cluster.html#hyp:ClusteredErrors">9.1</a> imposes that the covariance structure between potential outcomes is block diagonal.
That is that there is the same correlation between outcomes for observations in the same cluster, and there is no correlation between outcomes for observations that do not belong to the same cluster.</p>
</div>
<div class="theorem">
<p><span id="thm:VarWWClus" class="theorem"><strong>Theorem 9.1  (Variance of the With/Without estimator under Clustering) </strong></span>Under Assumptions <a href="FPCI.html#def:noselb">1.7</a>, <a href="FPSI.html#hyp:fullrank">2.1</a> and <a href="cluster.html#hyp:ClusteredErrors">9.1</a>,</p>
<p><span class="math display">\[\begin{align*}
\var{{\hat{\Delta^Y_{WW}}}} &amp; = \frac{1}{N}\left(\frac{\sigma^2_0}{1-\Pr(R_i=1)}(1+(m-1)\rho_0)+\frac{\sigma^2_1}{\Pr(R_i=1)}(1+(m-1)\rho_1)\right).
\end{align*}\]</span></p>
</div>
<div class="proof">
<p><span id="unlabeled-div-208" class="proof"><em>Proof</em>. </span>See in Appendix <a href="proofs.html#proofVarWWClus">A.5.1</a>.</p>
</div>
<p>We can also prove the following corollary:</p>
<div class="corollary">
<p><span id="cor:DesignEffect" class="corollary"><strong>Corollary 9.1  (Design Effect) </strong></span>Under Assumptions <a href="FPCI.html#def:noselb">1.7</a>, <a href="FPSI.html#hyp:fullrank">2.1</a> and <a href="cluster.html#hyp:ClusteredErrors">9.1</a>, and with <span class="math inline">\(\rho_0=\rho_1=\rho\)</span>, we have:</p>
<p><span class="math display">\[\begin{align*}
\var{{\hat{\Delta^Y_{WW}}}} &amp; = \frac{1}{N}(1+(m-1)\rho)\left(\frac{\sigma^2_0}{1-\Pr(D_i=1)}+\frac{\sigma^2_1}{\Pr(D_i=1)}\right),
\end{align*}\]</span></p>
<p>with <span class="math inline">\((1+(m-1)\rho)\)</span> the <strong>design effect</strong>.</p>
</div>
<div class="proof">
<p><span id="unlabeled-div-209" class="proof"><em>Proof</em>. </span>The proof is straightforward using Theorem <a href="cluster.html#thm:VarWWClus">9.1</a>.</p>
</div>
<div class="remark">
<p><span id="unlabeled-div-210" class="remark"><em>Remark</em>. </span>Note that the formula for the variance of the <span class="math inline">\(WW\)</span> estimator in Corollary <a href="cluster.html#cor:DesignEffect">9.1</a> is equal to the formula for the variance of the same estimator under Assumption <a href="FPSI.html#hyp:iid">2.2</a> of i.i.d. error terms derived in Lemma <a href="proofs.html#lem:asymWW">A.5</a> multiplied by the design effect.
As soon as <span class="math inline">\(m&gt;1\)</span>, the design effect is strictly superior to one, meaning that the variance of the <span class="math inline">\(WW\)</span> estimator in a clustered design is superior to the variance of the <span class="math inline">\(WW\)</span> estimator in a designed where randomization is done at the unit level.
The larger the Intra Cluster Correlation Coefficient <span class="math inline">\(\rho\)</span> and the higehr the number of units per cluster <span class="math inline">\(m\)</span>, the larger the design effect.</p>
</div>
<div class="remark">
<p><span id="unlabeled-div-211" class="remark"><em>Remark</em>. </span>One very useful way to think about the design effect is to think about <strong>effective sample size</strong> <span class="math inline">\(N^*=\frac{N}{1+(m-1)\rho}\)</span> as being the sample size that would yield the same precision as our clustered experiment but with an experiment randomized at the unit level.
In that sense, the design effect measures by how much clustering decreases our <strong>effective</strong> sample size.</p>
</div>
<div class="example">
<p><span id="exm:unnamed-chunk-365" class="example"><strong>Example 9.2  </strong></span>It is possible to visualize the extent of the design effect is to plot the effective sample size as a function of the real sample size, for various values of <span class="math inline">\(\rho\)</span> and <span class="math inline">\(m\)</span>.
For that, we simply need to generate a function to compute the effective sample size.</p>
</div>
<div class="sourceCode" id="cb359"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb359-1"><a href="cluster.html#cb359-1" aria-hidden="true" tabindex="-1"></a>DesignEffect <span class="ot">&lt;-</span> <span class="cf">function</span>(rho,m){</span>
<span id="cb359-2"><a href="cluster.html#cb359-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="dv">1</span><span class="sc">+</span>(m<span class="dv">-1</span>)<span class="sc">*</span>rho)</span>
<span id="cb359-3"><a href="cluster.html#cb359-3" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb359-4"><a href="cluster.html#cb359-4" aria-hidden="true" tabindex="-1"></a>EffSampleSize <span class="ot">&lt;-</span> <span class="cf">function</span>(N,...){</span>
<span id="cb359-5"><a href="cluster.html#cb359-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(N<span class="sc">/</span><span class="fu">DesignEffect</span>(...))</span>
<span id="cb359-6"><a href="cluster.html#cb359-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Let us now plot the result:</p>
<div class="sourceCode" id="cb360"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb360-1"><a href="cluster.html#cb360-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>()<span class="sc">+</span></span>
<span id="cb360-2"><a href="cluster.html#cb360-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlim</span>(<span class="dv">0</span>,<span class="dv">10000</span>) <span class="sc">+</span></span>
<span id="cb360-3"><a href="cluster.html#cb360-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ylim</span>(<span class="dv">0</span>,<span class="dv">10000</span>) <span class="sc">+</span></span>
<span id="cb360-4"><a href="cluster.html#cb360-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_function</span>(<span class="fu">aes</span>(<span class="at">linetype=</span><span class="st">&quot;m=2 and rho=0.1&quot;</span>,<span class="at">color=</span><span class="st">&quot;m=2 and rho=0.1&quot;</span>),<span class="at">fun=</span>EffSampleSize,<span class="at">args=</span><span class="fu">list</span>(<span class="at">rho=</span><span class="fl">0.1</span>,<span class="at">m=</span><span class="dv">2</span>)) <span class="sc">+</span></span>
<span id="cb360-5"><a href="cluster.html#cb360-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_function</span>(<span class="fu">aes</span>(<span class="at">linetype=</span><span class="st">&quot;m=5 and rho=0.1&quot;</span>,<span class="at">color=</span><span class="st">&quot;m=5 and rho=0.1&quot;</span>),<span class="at">fun=</span>EffSampleSize,<span class="at">args=</span><span class="fu">list</span>(<span class="at">rho=</span><span class="fl">0.1</span>,<span class="at">m=</span><span class="dv">5</span>)) <span class="sc">+</span></span>
<span id="cb360-6"><a href="cluster.html#cb360-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_function</span>(<span class="fu">aes</span>(<span class="at">linetype=</span><span class="st">&quot;m=10 and rho=0.1&quot;</span>,<span class="at">color=</span><span class="st">&quot;m=10 and rho=0.1&quot;</span>),<span class="at">fun=</span>EffSampleSize,<span class="at">args=</span><span class="fu">list</span>(<span class="at">rho=</span><span class="fl">0.1</span>,<span class="at">m=</span><span class="dv">10</span>)) <span class="sc">+</span></span>
<span id="cb360-7"><a href="cluster.html#cb360-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_function</span>(<span class="fu">aes</span>(<span class="at">linetype=</span><span class="st">&quot;m=2 and rho=0.5&quot;</span>,<span class="at">color=</span><span class="st">&quot;m=2 and rho=0.5&quot;</span>),<span class="at">fun=</span>EffSampleSize,<span class="at">args=</span><span class="fu">list</span>(<span class="at">rho=</span><span class="fl">0.5</span>,<span class="at">m=</span><span class="dv">2</span>)) <span class="sc">+</span></span>
<span id="cb360-8"><a href="cluster.html#cb360-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_function</span>(<span class="fu">aes</span>(<span class="at">linetype=</span><span class="st">&quot;m=5 and rho=0.5&quot;</span>,<span class="at">color=</span><span class="st">&quot;m=5 and rho=0.5&quot;</span>),<span class="at">fun=</span>EffSampleSize,<span class="at">args=</span><span class="fu">list</span>(<span class="at">rho=</span><span class="fl">0.5</span>,<span class="at">m=</span><span class="dv">5</span>)) <span class="sc">+</span></span>
<span id="cb360-9"><a href="cluster.html#cb360-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_function</span>(<span class="fu">aes</span>(<span class="at">linetype=</span><span class="st">&quot;m=10 and rho=0.5&quot;</span>,<span class="at">color=</span><span class="st">&quot;m=10 and rho=0.5&quot;</span>),<span class="at">fun=</span>EffSampleSize,<span class="at">args=</span><span class="fu">list</span>(<span class="at">rho=</span><span class="fl">0.5</span>,<span class="at">m=</span><span class="dv">10</span>)) <span class="sc">+</span></span>
<span id="cb360-10"><a href="cluster.html#cb360-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_function</span>(<span class="fu">aes</span>(<span class="at">linetype=</span><span class="st">&quot;m=2 and rho=1&quot;</span>,<span class="at">color=</span><span class="st">&quot;m=2 and rho=1&quot;</span>),<span class="at">fun=</span>EffSampleSize,<span class="at">args=</span><span class="fu">list</span>(<span class="at">rho=</span><span class="dv">1</span>,<span class="at">m=</span><span class="dv">2</span>)) <span class="sc">+</span></span>
<span id="cb360-11"><a href="cluster.html#cb360-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_function</span>(<span class="fu">aes</span>(<span class="at">linetype=</span><span class="st">&quot;m=5 and rho=1&quot;</span>,<span class="at">color=</span><span class="st">&quot;m=5 and rho=1&quot;</span>),<span class="at">fun=</span>EffSampleSize,<span class="at">args=</span><span class="fu">list</span>(<span class="at">rho=</span><span class="dv">1</span>,<span class="at">m=</span><span class="dv">5</span>)) <span class="sc">+</span></span>
<span id="cb360-12"><a href="cluster.html#cb360-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_function</span>(<span class="fu">aes</span>(<span class="at">linetype=</span><span class="st">&quot;m=10 and rho=1&quot;</span>,<span class="at">color=</span><span class="st">&quot;m=10 and rho=1&quot;</span>),<span class="at">fun=</span>EffSampleSize,<span class="at">args=</span><span class="fu">list</span>(<span class="at">rho=</span><span class="dv">1</span>,<span class="at">m=</span><span class="dv">10</span>)) <span class="sc">+</span></span>
<span id="cb360-13"><a href="cluster.html#cb360-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_abline</span>(<span class="at">slope=</span><span class="dv">1</span>,<span class="at">intercept=</span><span class="dv">0</span>,<span class="at">linetype=</span><span class="st">&quot;dotted&quot;</span>,<span class="at">color=</span><span class="st">&#39;black&#39;</span>)<span class="sc">+</span></span>
<span id="cb360-14"><a href="cluster.html#cb360-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_color_discrete</span>(<span class="at">name=</span><span class="st">&quot;&quot;</span>) <span class="sc">+</span></span>
<span id="cb360-15"><a href="cluster.html#cb360-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_linetype_discrete</span>(<span class="at">name=</span><span class="st">&quot;&quot;</span>) <span class="sc">+</span></span>
<span id="cb360-16"><a href="cluster.html#cb360-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ylab</span>(<span class="st">&quot;Effective sample size&quot;</span>) <span class="sc">+</span></span>
<span id="cb360-17"><a href="cluster.html#cb360-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">&quot;Actual sample size&quot;</span>) <span class="sc">+</span></span>
<span id="cb360-18"><a href="cluster.html#cb360-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span></code></pre></div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:EffSampleSizePlot"></span>
<img src="STCI_files/figure-html/EffSampleSizePlot-1.png" alt="Effective sample size in a clustered design" width="65%" />
<p class="caption">
Figure 9.3: Effective sample size in a clustered design
</p>
</div>
<p>Figure <a href="cluster.html#fig:EffSampleSizePlot">9.3</a> shows that effective sample size can decrease enormously because of clustering.
For example, with clusters of size <span class="math inline">\(m=10\)</span>, and the Intra Cluster Correlation Coefficient <span class="math inline">\(\rho=0.5\)</span>, a sample size of <span class="math inline">\(N=10000\)</span> observations is equivalent to an unclustered RCT ran on a sample of <span class="math inline">\(N^*=\)</span> 1818, which is equivalent to dividing the true sample size by 5.5.</p>
<p><strong>Discuss clustering in the power analysis chapter</strong></p>
</div>
<div id="estimating-sampling-noise-accounting-for-clustering" class="section level3 hasAnchor" number="9.1.3">
<h3><span class="header-section-number">9.1.3</span> Estimating sampling noise accounting for clustering<a href="cluster.html#estimating-sampling-noise-accounting-for-clustering" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>We have shown that clustering increases sampling noise around our estimates and worse, that our basic estimates of sampling noise based on the i.i.d. assumption underestimate the true amount of sampling noise, sometimes severely.
Devising ways to estimate sampling noise that offer a correct estimate of the true extent of sampling noise in the presence of clustering is thus a very important endeavor, if we are to gauge correctly the precision of our treatment effect estimates.
Let us see several ways to do that.</p>
<div class="remark">
<p><span id="unlabeled-div-212" class="remark"><em>Remark</em>. </span>There exists several super cool resources which detail the topics of estimating standard errors under clustering.
I really like the one by <a href="https://doi.org/10.3368/jhr.50.2.317">Cameron and Miller (2015)</a>.
The one by <a href="https://doi.org/10.1016/j.jeconom.2022.04.001">McKinnon, Nielsen and Webb (2023)</a> is also nice, even if more technical.</p>
</div>
<div id="using-the-plug-in-formula" class="section level4 hasAnchor" number="9.1.3.1">
<h4><span class="header-section-number">9.1.3.1</span> Using the plug-in formula<a href="cluster.html#using-the-plug-in-formula" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>One direct and simple way to account for clustering is to use the formula in Theorem <a href="cluster.html#thm:VarWWClus">9.1</a> or the simpler formula in Corollary <a href="cluster.html#cor:DesignEffect">9.1</a>.
The Intra Cluster Correlation Coefficient can be computed as the ratio of the variance of the mean of the outcomes at the cluster level divided by the total variance of the outcomes in the sample.
Once we have an estimate of the variance of the treatment effect, we can build sampling noise <span class="math inline">\(2\epsilon\)</span> by multiplying the resulting standard error by <span class="math inline">\(2\Phi^{-1}\left(\frac{\delta+1}{2}\right)\)</span>.</p>
<div class="remark">
<p><span id="unlabeled-div-213" class="remark"><em>Remark</em>. </span>Note that this approach implicitly assumes that the Central Limit Theorem holds with clustered data.
Actually, in the clustered case, as long as we allow the number of clusters to go to infinity, we can safely use the classical CLT.
We will also see in Section <a href="cluster.html#CLTDD">9.7</a> that versions of the CLT exist for more general case where there is dependency between data points.</p>
</div>
<div class="remark">
<p><span id="unlabeled-div-214" class="remark"><em>Remark</em>. </span>One uncertainty with the approach relying on CLT based on increasing the number of clusters is that we are unsure whether the normalizing constant in the CLT is <span class="math inline">\(N\)</span>, the total sample size, or <span class="math inline">\(n\)</span>, the number of clusters.
This will be rigorously clarified in Sections <a href="cluster.html#DesignBasedClusters">9.8</a> and <a href="cluster.html#CLTDD">9.7</a>.</p>
</div>
<div class="example">
<p><span id="exm:unnamed-chunk-369" class="example"><strong>Example 9.3  </strong></span>In practice, to apply the formula in Theorem <a href="cluster.html#thm:VarWWClus">9.1</a>, we simply need to compute the total variance of outcomes in the treated and control groups, and to estimate the Intra Cluster Correlation Coefficients of outcomes among the treated and the controls respectively, <span class="math inline">\(\rho_1\)</span> and <span class="math inline">\(\rho_0\)</span>.
The Intra Cluster Correlation Coefficient can be computed as the ratio of the variance of the mean of the outcomes at the cluster level divided by the total variance of the outcomes in the sample.
Let’s go.</p>
</div>
<div class="sourceCode" id="cb361"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb361-1"><a href="cluster.html#cb361-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Function for the plug in variance estimator</span></span>
<span id="cb361-2"><a href="cluster.html#cb361-2" aria-hidden="true" tabindex="-1"></a>VarClusterPlugIn <span class="ot">&lt;-</span> <span class="cf">function</span>(sigma1,sigma0,ICC1,ICC0,p,m,N){</span>
<span id="cb361-3"><a href="cluster.html#cb361-3" aria-hidden="true" tabindex="-1"></a>  dEffect0 <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">+</span>(m<span class="dv">-1</span>)<span class="sc">*</span>ICC0</span>
<span id="cb361-4"><a href="cluster.html#cb361-4" aria-hidden="true" tabindex="-1"></a>  dEffect1 <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">+</span>(m<span class="dv">-1</span>)<span class="sc">*</span>ICC1</span>
<span id="cb361-5"><a href="cluster.html#cb361-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>((dEffect0<span class="sc">*</span>sigma0<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>p)<span class="sc">+</span>dEffect1<span class="sc">*</span>sigma1<span class="sc">/</span>p)<span class="sc">/</span>N)</span>
<span id="cb361-6"><a href="cluster.html#cb361-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb361-7"><a href="cluster.html#cb361-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb361-8"><a href="cluster.html#cb361-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Preparing data</span></span>
<span id="cb361-9"><a href="cluster.html#cb361-9" aria-hidden="true" tabindex="-1"></a>dataCluster <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">Cluster=</span>cluster,<span class="at">yA=</span>yA,<span class="at">yB=</span>yB,<span class="at">R=</span>R)</span>
<span id="cb361-10"><a href="cluster.html#cb361-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Computing ICC</span></span>
<span id="cb361-11"><a href="cluster.html#cb361-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Cluster-level variance</span></span>
<span id="cb361-12"><a href="cluster.html#cb361-12" aria-hidden="true" tabindex="-1"></a>VaryAClus <span class="ot">&lt;-</span> dataCluster <span class="sc">%&gt;%</span></span>
<span id="cb361-13"><a href="cluster.html#cb361-13" aria-hidden="true" tabindex="-1"></a>                <span class="fu">group_by</span>(R,Cluster) <span class="sc">%&gt;%</span></span>
<span id="cb361-14"><a href="cluster.html#cb361-14" aria-hidden="true" tabindex="-1"></a>                <span class="fu">summarize</span>(</span>
<span id="cb361-15"><a href="cluster.html#cb361-15" aria-hidden="true" tabindex="-1"></a>                  <span class="at">MeanyAClus =</span> <span class="fu">mean</span>(yA)</span>
<span id="cb361-16"><a href="cluster.html#cb361-16" aria-hidden="true" tabindex="-1"></a>                ) <span class="sc">%&gt;%</span></span>
<span id="cb361-17"><a href="cluster.html#cb361-17" aria-hidden="true" tabindex="-1"></a>                <span class="fu">ungroup</span>(.) <span class="sc">%&gt;%</span></span>
<span id="cb361-18"><a href="cluster.html#cb361-18" aria-hidden="true" tabindex="-1"></a>                <span class="fu">group_by</span>(R) <span class="sc">%&gt;%</span></span>
<span id="cb361-19"><a href="cluster.html#cb361-19" aria-hidden="true" tabindex="-1"></a>                <span class="fu">summarize</span>(</span>
<span id="cb361-20"><a href="cluster.html#cb361-20" aria-hidden="true" tabindex="-1"></a>                  <span class="at">VaryAClus =</span> <span class="fu">var</span>(MeanyAClus)</span>
<span id="cb361-21"><a href="cluster.html#cb361-21" aria-hidden="true" tabindex="-1"></a>                ) </span>
<span id="cb361-22"><a href="cluster.html#cb361-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Total variance</span></span>
<span id="cb361-23"><a href="cluster.html#cb361-23" aria-hidden="true" tabindex="-1"></a>VaryA <span class="ot">&lt;-</span> dataCluster <span class="sc">%&gt;%</span></span>
<span id="cb361-24"><a href="cluster.html#cb361-24" aria-hidden="true" tabindex="-1"></a>          <span class="fu">group_by</span>(R) <span class="sc">%&gt;%</span></span>
<span id="cb361-25"><a href="cluster.html#cb361-25" aria-hidden="true" tabindex="-1"></a>          <span class="fu">summarize</span>(</span>
<span id="cb361-26"><a href="cluster.html#cb361-26" aria-hidden="true" tabindex="-1"></a>            <span class="at">VaryATot =</span> <span class="fu">var</span>(yA)</span>
<span id="cb361-27"><a href="cluster.html#cb361-27" aria-hidden="true" tabindex="-1"></a>          )</span>
<span id="cb361-28"><a href="cluster.html#cb361-28" aria-hidden="true" tabindex="-1"></a><span class="co"># ICC</span></span>
<span id="cb361-29"><a href="cluster.html#cb361-29" aria-hidden="true" tabindex="-1"></a>ICC <span class="ot">&lt;-</span> VaryA <span class="sc">%&gt;%</span></span>
<span id="cb361-30"><a href="cluster.html#cb361-30" aria-hidden="true" tabindex="-1"></a>        <span class="fu">left_join</span>(VaryAClus,<span class="at">by=</span><span class="st">&#39;R&#39;</span>) <span class="sc">%&gt;%</span></span>
<span id="cb361-31"><a href="cluster.html#cb361-31" aria-hidden="true" tabindex="-1"></a>        <span class="fu">mutate</span>(</span>
<span id="cb361-32"><a href="cluster.html#cb361-32" aria-hidden="true" tabindex="-1"></a>          <span class="at">ICC =</span>  VaryAClus<span class="sc">/</span>VaryATot</span>
<span id="cb361-33"><a href="cluster.html#cb361-33" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb361-34"><a href="cluster.html#cb361-34" aria-hidden="true" tabindex="-1"></a><span class="co"># p </span></span>
<span id="cb361-35"><a href="cluster.html#cb361-35" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fu">mean</span>(dataCluster<span class="sc">$</span>R)</span>
<span id="cb361-36"><a href="cluster.html#cb361-36" aria-hidden="true" tabindex="-1"></a><span class="co"># Variance estimate</span></span>
<span id="cb361-37"><a href="cluster.html#cb361-37" aria-hidden="true" tabindex="-1"></a>VarClusteredWW <span class="ot">&lt;-</span> <span class="fu">VarClusterPlugIn</span>(<span class="at">sigma1=</span>ICC <span class="sc">%&gt;%</span> <span class="fu">filter</span>(R<span class="sc">==</span><span class="dv">1</span>) <span class="sc">%&gt;%</span> <span class="fu">pull</span>(VaryATot),</span>
<span id="cb361-38"><a href="cluster.html#cb361-38" aria-hidden="true" tabindex="-1"></a>                                   <span class="at">sigma0=</span>ICC <span class="sc">%&gt;%</span> <span class="fu">filter</span>(R<span class="sc">==</span><span class="dv">0</span>) <span class="sc">%&gt;%</span> <span class="fu">pull</span>(VaryATot),</span>
<span id="cb361-39"><a href="cluster.html#cb361-39" aria-hidden="true" tabindex="-1"></a>                                   <span class="at">ICC1=</span>ICC <span class="sc">%&gt;%</span> <span class="fu">filter</span>(R<span class="sc">==</span><span class="dv">1</span>) <span class="sc">%&gt;%</span> <span class="fu">pull</span>(ICC),</span>
<span id="cb361-40"><a href="cluster.html#cb361-40" aria-hidden="true" tabindex="-1"></a>                                   <span class="at">ICC0=</span>ICC <span class="sc">%&gt;%</span> <span class="fu">filter</span>(R<span class="sc">==</span><span class="dv">0</span>) <span class="sc">%&gt;%</span> <span class="fu">pull</span>(ICC),</span>
<span id="cb361-41"><a href="cluster.html#cb361-41" aria-hidden="true" tabindex="-1"></a>                                   <span class="at">p=</span>p,</span>
<span id="cb361-42"><a href="cluster.html#cb361-42" aria-hidden="true" tabindex="-1"></a>                                   <span class="at">m=</span>N<span class="sc">/</span>Nclusters,</span>
<span id="cb361-43"><a href="cluster.html#cb361-43" aria-hidden="true" tabindex="-1"></a>                                   <span class="at">N=</span>N)</span></code></pre></div>
<p>Our estimate of sampling noise accounting for clustering using the plug-in estimator is equal to 0.53.
The true level of sampling noise estimated from the simulations is 0.43.
Remember that the naive estimate of sampling noise which ignores clustering is 0.3.</p>
</div>
<div id="using-cluster-robust-standard-errors" class="section level4 hasAnchor" number="9.1.3.2">
<h4><span class="header-section-number">9.1.3.2</span> Using cluster-robust standard errors<a href="cluster.html#using-cluster-robust-standard-errors" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>The most widely used approach for accounting for clustering when estimating treatment effects is using cluster-robust standard errors.
We start with the formula for the variance of the OLS estimator, that we have derived in the proof of Theorem <a href="cluster.html#thm:VarWWClus">9.1</a>: <span class="math inline">\(\var{\hat{\Theta}_{OLS}|X}=(X&#39;X)^{-1}X&#39;\esp{UU&#39;|X}X(X&#39;X)^{-1}\)</span>.
The basic idea of clustered robust standard errors is to build an empirical estimate of the covariance matrix of the residuals <span class="math inline">\(\esp{UU&#39;|X}\)</span> using the estimated residuals <span class="math inline">\(\hat{U}_i\)</span>.
We might want to use the full <span class="math inline">\(\mathbf{\hat{U}}\mathbf{\hat{U}}&#39;\)</span> matrix, with <span class="math inline">\(\mathbf{\hat{U}}\)</span> the vector of all estimated residuals, but that would not work, because, by construction, the OLS estimator produces residuals which are orthogonal to the covariates, so that <span class="math inline">\(X&#39;\esp{UU&#39;|X}X\)</span> is a null matrix.</p>
<p>Instead, cluster-robust standard errors are estimated by assuming first that the matrix <span class="math inline">\(\esp{UU&#39;|X}\)</span> is block diagonal, meaning that observations are only correlated within clusters.
Let <span class="math inline">\(\mathbf{\hat{U}}_c\)</span> be the vector of empirical residuals of observations residing in cluster <span class="math inline">\(c\)</span>.
Let’s write <span class="math inline">\(\hat{\Omega}_c=\mathbf{\hat{U}}_c\mathbf{\hat{U}}_c&#39;\)</span> and <span class="math inline">\(\hat{\Omega}=\diag(\left\{\hat{\Omega}_c\right\}_{c=1}^n)\)</span>.
We can now use <span class="math inline">\(\hatvar{\hat{\Theta}_{OLS,Clustered}}=(X&#39;X)^{-1}X&#39;\hat{\Omega}X(X&#39;X)^{-1}\)</span> as our cluster-robust estimate of the covariance matrix of the OLS estimator, with <span class="math inline">\(\Theta=(\alpha,\beta)\)</span> the parameter vector in the equation <span class="math inline">\(Y_i=\alpha+\beta R_i+U_i\)</span>, where <span class="math inline">\(\beta=\Delta^Y_{WW}\)</span>, as Lemma <a href="proofs.html#lem:WWOLS">A.3</a> shows.</p>
<p>In practice, some authors and statistical software might add a degrees of freedom correction to these estimates as a way to curb small sample bias.
One common correction factor is <span class="math inline">\(\frac{n}{n-1}\frac{N-1}{N-k}\)</span> with <span class="math inline">\(K\)</span> the number of covariates.
Another classical correction is <span class="math inline">\(\frac{n}{n-1}\)</span>.</p>
<div class="example">
<p><span id="exm:unnamed-chunk-370" class="example"><strong>Example 9.4  </strong></span>Let’s see how these approaches work in our example.
The most straightforward way to implement the cluster-robust variance estimator in <code>R</code> is to use the <code>vcovCL</code> command from the <code>sandwich</code> package.
The <code>type</code> option of <code>vcovCL</code> can take values <code>HC0</code>, where the only correction is <span class="math inline">\(\frac{n}{n-1}\)</span>, and <code>HC1</code>, where the correction is <span class="math inline">\(\frac{n}{n-1}\frac{N-1}{N-k}\)</span>.
Another approach is to use the <code>feols</code> function of the <code>fixest</code> package with the <code>cluster</code> option.</p>
</div>
<div class="sourceCode" id="cb362"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb362-1"><a href="cluster.html#cb362-1" aria-hidden="true" tabindex="-1"></a><span class="co"># regression</span></span>
<span id="cb362-2"><a href="cluster.html#cb362-2" aria-hidden="true" tabindex="-1"></a>RegBFCLuster <span class="ot">&lt;-</span> <span class="fu">lm</span>(yA <span class="sc">~</span> R, <span class="at">data=</span>dataCluster)</span>
<span id="cb362-3"><a href="cluster.html#cb362-3" aria-hidden="true" tabindex="-1"></a><span class="co"># cluster-robust standard error</span></span>
<span id="cb362-4"><a href="cluster.html#cb362-4" aria-hidden="true" tabindex="-1"></a>VCovClusterHC1 <span class="ot">&lt;-</span> <span class="fu">vcovCL</span>(RegBFCLuster,<span class="at">cluster=</span><span class="sc">~</span>cluster,<span class="at">type=</span><span class="st">&quot;HC1&quot;</span>,<span class="at">sandwich=</span><span class="cn">TRUE</span>)</span>
<span id="cb362-5"><a href="cluster.html#cb362-5" aria-hidden="true" tabindex="-1"></a>VCovClusterHC0 <span class="ot">&lt;-</span> <span class="fu">vcovCL</span>(RegBFCLuster,<span class="at">cluster=</span><span class="sc">~</span>cluster,<span class="at">type=</span><span class="st">&quot;HC0&quot;</span>,<span class="at">sandwich=</span><span class="cn">TRUE</span>)</span>
<span id="cb362-6"><a href="cluster.html#cb362-6" aria-hidden="true" tabindex="-1"></a><span class="co"># using fixest</span></span>
<span id="cb362-7"><a href="cluster.html#cb362-7" aria-hidden="true" tabindex="-1"></a>RegBFCLusterFixest <span class="ot">&lt;-</span> <span class="fu">feols</span>(yA <span class="sc">~</span> R <span class="sc">|</span> <span class="dv">1</span>, <span class="at">data=</span>dataCluster, <span class="at">cluster=</span><span class="st">&quot;Cluster&quot;</span>)</span></code></pre></div>
<p>With the <code>HC1</code> correction, our estimate of sampling noise accounting for clustering using the plug-in estimator is equal to 0.46, and to 0.46 with the <code>HC0</code> correction and to 0.46 with <code>fixest</code>.
The true level of sampling noise estimated from the simulations is 0.43.
Remember that the naive estimate of sampling noise which ignores clustering is 0.3.</p>
</div>
<div id="using-feasible-generalized-least-squares" class="section level4 hasAnchor" number="9.1.3.3">
<h4><span class="header-section-number">9.1.3.3</span> Using Feasible Generalized Least Squares<a href="cluster.html#using-feasible-generalized-least-squares" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>As <a href="https://doi.org/10.3368/jhr.50.2.317">Cameron and Miller (2015)</a> remark, when error terms are autocorrelated, the OLS estimator is not the most efficient one, and a Generalized Least Squares (GLS) estimator could perform better.
The problem is to find the Feasible Generalized Least Squares estimator that makes real this potential gain in precision.
In order to derive it, we have first to specify a model for <span class="math inline">\(\Omega_{GLS}=\esp{UU&#39;|X}\)</span>.
One such model is the one in Assumption <a href="cluster.html#hyp:ClusteredErrors">9.1</a>.
Under such a model, we know that the GLS estimator of the parameter vector <span class="math inline">\(\Theta=(\alpha,\beta)\)</span> in the equation <span class="math inline">\(Y_i=\alpha+\beta R_i+U_i\)</span> is <span class="math inline">\(\hat{\Theta}_{GLS}=(X&#39;\Omega_{GLS}^{-1}X)^{-1}X&#39;\Omega_{GLS}^{-1}Y\)</span>.
With a consistent estimator for <span class="math inline">\(\Omega\)</span>, <em>e.g.</em> <span class="math inline">\(\hat{\Omega}_{FGLS}\)</span>, we have <span class="math inline">\(\hat{\Theta}_{FGLS}=(X&#39;\hat{\Omega}_{FGLS}^{-1}X)^{-1}X&#39;\hat{\Omega}_{FGLS}^{-1}Y\)</span> with the associated estimated variance: <span class="math inline">\(\hatvar{\hat{\Theta}_{FGLS}}=(X&#39;\hat{\Omega}_{FGLS}^{-1}X)^{-1}\)</span>.
<a href="https://doi.org/10.3368/jhr.50.2.317">Cameron and Miller (2015)</a> also suggest that we can build a cluster robust estimate of the variance of the FGLS estimator as follows: <span class="math inline">\(\hatvar{\hat{\Theta}_{FGLS,Clustered}}=(X&#39;\hat{\Omega}_{FGLS}^{-1}X)^{-1}X&#39;\hat{\Omega}_{FGLS}^{-1}\hat{\Omega}\hat{\Omega}_{FGLS}^{-1}X(X&#39;\hat{\Omega}_{FGLS}^{-1}X)^{-1}\)</span>, with <span class="math inline">\(\hat{\Omega}=\diag(\left\{\hat{\Omega}_c\right\}_{c=1}^n)\)</span>, <span class="math inline">\(\hat{\Omega}_c=\mathbf{\hat{U}}_c\mathbf{\hat{U}}_c&#39;\)</span> and <span class="math inline">\(\mathbf{\hat{U}}_c\)</span> be the vector of empirical residuals of observations residing in cluster <span class="math inline">\(c\)</span>, as in the previous section, but obtained with the FGLS model now.</p>
<div class="remark">
<p><span id="unlabeled-div-215" class="remark"><em>Remark</em>. </span>As <a href="https://doi.org/10.3368/jhr.50.2.317">Cameron and Miller (2015)</a> remark, the approach of building a cluster-robust estimator for the variance of the FGLS estimator has been popularized in biostatistics by <a href="https://doi.org/10.1093/biomet/73.1.13">Liang and Zeger (1986)</a>.</p>
</div>
<div class="example">
<p><span id="exm:unnamed-chunk-372" class="example"><strong>Example 9.5  </strong></span>Let’s see how the FGLS approach works in our example.
Following Assumption <a href="cluster.html#hyp:ClusteredErrors">9.1</a>, we know that <span class="math inline">\(\hat{\Omega}_{FGLS}=\hat{\sigma}^2_1\diag{\mathbf{R}_c}\otimes\hat{\Omega}_1+\hat{\sigma}^2_0(I-\diag{\mathbf{R}_c})\otimes\hat{\Omega}_0\)</span>, with <span class="math inline">\(\hat{\sigma}^2_1\)</span> the estimated variance of outcomes in the treated group, <span class="math inline">\(\hat{\sigma}^2_0\)</span>, the estimated varianc of outcomes in the control group and <span class="math inline">\(\hat{\Omega}_1\)</span> and <span class="math inline">\(\hat{\Omega}_0\)</span> matrices with a diagonal of one and off-diagonal elements equal to <span class="math inline">\(\hat{\rho}_1\)</span> and <span class="math inline">\(\hat{\rho}_0\)</span>, respectively, the Intra Cluster Correlation Coefficient of outcomes in the treated and untreated groups respectively.
We know how to estimate all these parameters so we can build <span class="math inline">\(\hat{\Omega}_{FGLS}\)</span>.
Let’s do it.</p>
</div>
<div class="sourceCode" id="cb363"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb363-1"><a href="cluster.html#cb363-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Omega matrix at the cluster level</span></span>
<span id="cb363-2"><a href="cluster.html#cb363-2" aria-hidden="true" tabindex="-1"></a>Omega1 <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="at">data=</span>ICC <span class="sc">%&gt;%</span> <span class="fu">filter</span>(R<span class="sc">==</span><span class="dv">1</span>) <span class="sc">%&gt;%</span> <span class="fu">pull</span>(ICC),<span class="at">nrow=</span>N<span class="sc">/</span>Nclusters,<span class="at">ncol=</span>N<span class="sc">/</span>Nclusters) <span class="sc">+</span> <span class="fu">diag</span>(<span class="dv">1</span><span class="sc">-</span>ICC <span class="sc">%&gt;%</span> <span class="fu">filter</span>(R<span class="sc">==</span><span class="dv">1</span>) <span class="sc">%&gt;%</span> <span class="fu">pull</span>(ICC),<span class="at">nrow=</span>N<span class="sc">/</span>Nclusters,<span class="at">ncol=</span>N<span class="sc">/</span>Nclusters)</span>
<span id="cb363-3"><a href="cluster.html#cb363-3" aria-hidden="true" tabindex="-1"></a>Omega0 <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="at">data=</span>ICC <span class="sc">%&gt;%</span> <span class="fu">filter</span>(R<span class="sc">==</span><span class="dv">0</span>) <span class="sc">%&gt;%</span> <span class="fu">pull</span>(ICC),<span class="at">nrow=</span>N<span class="sc">/</span>Nclusters,<span class="at">ncol=</span>N<span class="sc">/</span>Nclusters) <span class="sc">+</span> <span class="fu">diag</span>(<span class="dv">1</span><span class="sc">-</span>ICC <span class="sc">%&gt;%</span> <span class="fu">filter</span>(R<span class="sc">==</span><span class="dv">0</span>) <span class="sc">%&gt;%</span> <span class="fu">pull</span>(ICC),<span class="at">nrow=</span>N<span class="sc">/</span>Nclusters,<span class="at">ncol=</span>N<span class="sc">/</span>Nclusters)</span>
<span id="cb363-4"><a href="cluster.html#cb363-4" aria-hidden="true" tabindex="-1"></a><span class="co"># sigma1 and sigma0</span></span>
<span id="cb363-5"><a href="cluster.html#cb363-5" aria-hidden="true" tabindex="-1"></a>sigma21 <span class="ot">&lt;-</span> ICC <span class="sc">%&gt;%</span> <span class="fu">filter</span>(R<span class="sc">==</span><span class="dv">1</span>) <span class="sc">%&gt;%</span> <span class="fu">pull</span>(VaryATot)</span>
<span id="cb363-6"><a href="cluster.html#cb363-6" aria-hidden="true" tabindex="-1"></a>sigma20 <span class="ot">&lt;-</span> ICC <span class="sc">%&gt;%</span> <span class="fu">filter</span>(R<span class="sc">==</span><span class="dv">0</span>) <span class="sc">%&gt;%</span> <span class="fu">pull</span>(VaryATot)</span>
<span id="cb363-7"><a href="cluster.html#cb363-7" aria-hidden="true" tabindex="-1"></a><span class="co"># OmegaFGLS matrix at teh sample level</span></span>
<span id="cb363-8"><a href="cluster.html#cb363-8" aria-hidden="true" tabindex="-1"></a>OmegaFGLS <span class="ot">&lt;-</span> sigma21<span class="sc">*</span><span class="fu">diag</span>(Rc)<span class="sc">%x%</span>Omega1 <span class="sc">+</span>sigma20<span class="sc">*</span>(<span class="fu">diag</span>(<span class="dv">1</span>,<span class="at">nrow=</span>Nclusters,<span class="at">ncol=</span>Nclusters)<span class="sc">-</span><span class="fu">diag</span>(Rc))<span class="sc">%x%</span>Omega0</span>
<span id="cb363-9"><a href="cluster.html#cb363-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Inverting Omega</span></span>
<span id="cb363-10"><a href="cluster.html#cb363-10" aria-hidden="true" tabindex="-1"></a>InvOmegaFGLS <span class="ot">&lt;-</span> <span class="fu">solve</span>(OmegaFGLS)</span>
<span id="cb363-11"><a href="cluster.html#cb363-11" aria-hidden="true" tabindex="-1"></a><span class="co"># matrix of covariates</span></span>
<span id="cb363-12"><a href="cluster.html#cb363-12" aria-hidden="true" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">cbind</span>(<span class="dv">1</span>,R)</span>
<span id="cb363-13"><a href="cluster.html#cb363-13" aria-hidden="true" tabindex="-1"></a><span class="co"># FGLS estimator</span></span>
<span id="cb363-14"><a href="cluster.html#cb363-14" aria-hidden="true" tabindex="-1"></a>RegFGLS <span class="ot">&lt;-</span> <span class="fu">solve</span>((<span class="fu">t</span>(X)<span class="sc">%*%</span>InvOmegaFGLS<span class="sc">%*%</span>X))<span class="sc">%*%</span>(<span class="fu">t</span>(X)<span class="sc">%*%</span>InvOmegaFGLS<span class="sc">%*%</span>yA)</span>
<span id="cb363-15"><a href="cluster.html#cb363-15" aria-hidden="true" tabindex="-1"></a><span class="co"># FGLS estimate of WW</span></span>
<span id="cb363-16"><a href="cluster.html#cb363-16" aria-hidden="true" tabindex="-1"></a>WWyFGLS <span class="ot">&lt;-</span> RegFGLS[<span class="dv">2</span>,<span class="dv">1</span>]</span>
<span id="cb363-17"><a href="cluster.html#cb363-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Basic variance estimate of the FGLS estimator</span></span>
<span id="cb363-18"><a href="cluster.html#cb363-18" aria-hidden="true" tabindex="-1"></a>VcovRegFGLS <span class="ot">&lt;-</span> <span class="fu">solve</span>((<span class="fu">t</span>(X)<span class="sc">%*%</span>InvOmegaFGLS<span class="sc">%*%</span>X))</span>
<span id="cb363-19"><a href="cluster.html#cb363-19" aria-hidden="true" tabindex="-1"></a><span class="co"># estimated basic standard error of WWyFGLS</span></span>
<span id="cb363-20"><a href="cluster.html#cb363-20" aria-hidden="true" tabindex="-1"></a>SeWWyFGLS <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(VcovRegFGLS[<span class="dv">2</span>,<span class="dv">2</span>])</span></code></pre></div>
<p>The FGLS estimator of the treatment effect is equal to 0.24 <span class="math inline">\(\pm\)</span> 0.2 with <span class="math inline">\(\delta=0.95\)</span>.
This means that the basic FGLS estimate of sampling noise is equal to 0.53.
The true level of sampling noise estimated from the simulations is 0.43.</p>
<p>Let us now try to estimate the cluster robust variance of the FGLS estimator.
This requires to compute the matrix <span class="math inline">\(\hat{\Omega}_c=\mathbf{\hat{U}}_c\mathbf{\hat{U}}_c&#39;\)</span> for each cluster.
For that, we are going to extract the block diagonal matrix <span class="math inline">\(\hat{\Omega}=\mathbf{\hat{U}}\mathbf{\hat{U}}&#39;\)</span> using the package <code>diagonal</code>.</p>
<div class="sourceCode" id="cb364"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb364-1"><a href="cluster.html#cb364-1" aria-hidden="true" tabindex="-1"></a><span class="co"># computing FGLS residuals</span></span>
<span id="cb364-2"><a href="cluster.html#cb364-2" aria-hidden="true" tabindex="-1"></a>ResidFGLS <span class="ot">&lt;-</span> yA<span class="sc">-</span>X<span class="sc">%*%</span>RegFGLS</span>
<span id="cb364-3"><a href="cluster.html#cb364-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Product of residuals matrix</span></span>
<span id="cb364-4"><a href="cluster.html#cb364-4" aria-hidden="true" tabindex="-1"></a>HatOmega <span class="ot">&lt;-</span> ResidFGLS<span class="sc">%*%</span><span class="fu">t</span>(ResidFGLS)</span>
<span id="cb364-5"><a href="cluster.html#cb364-5" aria-hidden="true" tabindex="-1"></a><span class="co"># block diagonal equal to zero</span></span>
<span id="cb364-6"><a href="cluster.html#cb364-6" aria-hidden="true" tabindex="-1"></a>diagonals<span class="sc">::</span><span class="fu">fatdiag</span>(HatOmega,<span class="at">size=</span>N<span class="sc">/</span>Nclusters) <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb364-7"><a href="cluster.html#cb364-7" aria-hidden="true" tabindex="-1"></a><span class="co"># take the UU&#39; matrix and take of the OFF diagonal elements</span></span>
<span id="cb364-8"><a href="cluster.html#cb364-8" aria-hidden="true" tabindex="-1"></a>HatOmega <span class="ot">&lt;-</span> ResidFGLS<span class="sc">%*%</span><span class="fu">t</span>(ResidFGLS)<span class="sc">-</span>HatOmega</span>
<span id="cb364-9"><a href="cluster.html#cb364-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb364-10"><a href="cluster.html#cb364-10" aria-hidden="true" tabindex="-1"></a><span class="co"># compute the Cluster robust FGLS variance matrix estimator</span></span>
<span id="cb364-11"><a href="cluster.html#cb364-11" aria-hidden="true" tabindex="-1"></a>VcovRegFGLSCluster <span class="ot">&lt;-</span> VcovRegFGLS<span class="sc">%*%</span><span class="fu">t</span>(X)<span class="sc">%*%</span>InvOmegaFGLS<span class="sc">%*%</span>HatOmega<span class="sc">%*%</span>InvOmegaFGLS<span class="sc">%*%</span>X<span class="sc">%*%</span>VcovRegFGLS</span>
<span id="cb364-12"><a href="cluster.html#cb364-12" aria-hidden="true" tabindex="-1"></a><span class="co"># estimated clustered standard error of WWyFGLS</span></span>
<span id="cb364-13"><a href="cluster.html#cb364-13" aria-hidden="true" tabindex="-1"></a>SeWWyFGLSCluster <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(VcovRegFGLSCluster[<span class="dv">2</span>,<span class="dv">2</span>])</span></code></pre></div>
<p>This means that the cluster-robust FGLS estimate of sampling noise is equal to 0.46.
The true level of sampling noise estimated from the simulations is 0.43.</p>
</div>
<div id="using-the-bootstrap" class="section level4 hasAnchor" number="9.1.3.4">
<h4><span class="header-section-number">9.1.3.4</span> Using the Bootstrap<a href="cluster.html#using-the-bootstrap" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>The bootstrap is a data-intensive non-parametric way to obtain cluster-robust estimates of sampling noise.
Here, we are going to use the non-parametric bootstrap, but other bootstrap methods exist.
<a href="https://doi.org/10.3368/jhr.50.2.317">Cameron and Miller (2015)</a> cover some of them.</p>
<div class="remark">
<p><span id="unlabeled-div-216" class="remark"><em>Remark</em>. </span>A key distinction when we use the bootstrap is whether it can offer <strong>asymptotic refinements</strong> or not.</p>
</div>
<p>The way we implement the non-parametric (or pair) bootstrap is as follows:</p>
<ol style="list-style-type: decimal">
<li>We build a sample of <span class="math inline">\(N_c\)</span> clusters by sampling with replacement from the original sample,</li>
<li>For each sample <span class="math inline">\(b\)</span>, we estimate a treatment effect <span class="math inline">\(\hat{\Delta}^y_{WW}(b)\)</span>,</li>
<li>After computing <span class="math inline">\(B\)</span> such estimates, we compute the bootstrap-cluster-robust variance estimator as follows:</li>
</ol>
<p><span class="math display">\[\begin{align*}
  \hatvar{\hat{\Delta}^y_{WW}}^{Bootstrap}_{Clustered} &amp; = \frac{1}{B-1}\sum_{b=1}^B\left(\hat{\Delta}^y_{WW}(b)-\frac{1}{B}\sum_{b=1}^B\hat{\Delta}^y_{WW}(b)\right)^2.
\end{align*}\]</span></p>
<div class="example">
<p><span id="exm:unnamed-chunk-374" class="example"><strong>Example 9.6  </strong></span>Let’s see how this works in our example.
We first need to generate a dataset with outcomes, treatment and cluster indicators.
Then we need to draw repeatedly new vectors of clusters identifiers, with replacement, and compute the WW estimator for each.</p>
</div>
<div class="sourceCode" id="cb365"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb365-1"><a href="cluster.html#cb365-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Regroup data and cluster id</span></span>
<span id="cb365-2"><a href="cluster.html#cb365-2" aria-hidden="true" tabindex="-1"></a><span class="co"># already done in dataCluster</span></span>
<span id="cb365-3"><a href="cluster.html#cb365-3" aria-hidden="true" tabindex="-1"></a><span class="co"># write a function to draw a new vector of clusters and return the WW estimator</span></span>
<span id="cb365-4"><a href="cluster.html#cb365-4" aria-hidden="true" tabindex="-1"></a><span class="co"># seed: the seed for the PRNG</span></span>
<span id="cb365-5"><a href="cluster.html#cb365-5" aria-hidden="true" tabindex="-1"></a><span class="co"># data: the dataset</span></span>
<span id="cb365-6"><a href="cluster.html#cb365-6" aria-hidden="true" tabindex="-1"></a><span class="co"># cluster: the name of the cluster variable (with cluster variable indexed from 1 to Nc)</span></span>
<span id="cb365-7"><a href="cluster.html#cb365-7" aria-hidden="true" tabindex="-1"></a><span class="co"># y: the name of the outcome variable</span></span>
<span id="cb365-8"><a href="cluster.html#cb365-8" aria-hidden="true" tabindex="-1"></a><span class="co"># D: the name of the treatment variable</span></span>
<span id="cb365-9"><a href="cluster.html#cb365-9" aria-hidden="true" tabindex="-1"></a>NPBootCluster <span class="ot">&lt;-</span> <span class="cf">function</span>(seed,data,cluster,y,D){</span>
<span id="cb365-10"><a href="cluster.html#cb365-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># set seed</span></span>
<span id="cb365-11"><a href="cluster.html#cb365-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set.seed</span>(seed)</span>
<span id="cb365-12"><a href="cluster.html#cb365-12" aria-hidden="true" tabindex="-1"></a>  <span class="co"># compute number of clusters</span></span>
<span id="cb365-13"><a href="cluster.html#cb365-13" aria-hidden="true" tabindex="-1"></a>  NClusters <span class="ot">&lt;-</span> data <span class="sc">%&gt;%</span></span>
<span id="cb365-14"><a href="cluster.html#cb365-14" aria-hidden="true" tabindex="-1"></a>                <span class="fu">group_by</span>(<span class="sc">!!</span><span class="fu">sym</span>(cluster)) <span class="sc">%&gt;%</span></span>
<span id="cb365-15"><a href="cluster.html#cb365-15" aria-hidden="true" tabindex="-1"></a>                <span class="fu">summarize</span>(<span class="at">count=</span><span class="fu">n</span>()) <span class="sc">%&gt;%</span></span>
<span id="cb365-16"><a href="cluster.html#cb365-16" aria-hidden="true" tabindex="-1"></a>                <span class="fu">summarize</span>(<span class="at">NClusters=</span><span class="fu">n</span>())</span>
<span id="cb365-17"><a href="cluster.html#cb365-17" aria-hidden="true" tabindex="-1"></a>  <span class="co"># draw a sample with replacement </span></span>
<span id="cb365-18"><a href="cluster.html#cb365-18" aria-hidden="true" tabindex="-1"></a>  SampleClusters <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">BootClusters =</span><span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span>(NClusters[[<span class="dv">1</span>]]),<span class="at">size=</span>NClusters[[<span class="dv">1</span>]],<span class="at">replace=</span><span class="cn">TRUE</span>)) <span class="sc">%&gt;%</span></span>
<span id="cb365-19"><a href="cluster.html#cb365-19" aria-hidden="true" tabindex="-1"></a>                      <span class="fu">left_join</span>(data,<span class="at">by=</span><span class="fu">c</span>(<span class="st">&#39;BootClusters&#39;</span><span class="ot">=</span>cluster))</span>
<span id="cb365-20"><a href="cluster.html#cb365-20" aria-hidden="true" tabindex="-1"></a>  <span class="co"># run regression</span></span>
<span id="cb365-21"><a href="cluster.html#cb365-21" aria-hidden="true" tabindex="-1"></a>  RegCluster <span class="ot">&lt;-</span> <span class="fu">lm</span>(<span class="fu">as.formula</span>(<span class="fu">paste</span>(y,D,<span class="at">sep=</span><span class="st">&#39;~&#39;</span>)),<span class="at">data=</span>SampleClusters)</span>
<span id="cb365-22"><a href="cluster.html#cb365-22" aria-hidden="true" tabindex="-1"></a>  <span class="co"># WW estimate</span></span>
<span id="cb365-23"><a href="cluster.html#cb365-23" aria-hidden="true" tabindex="-1"></a>  WW <span class="ot">&lt;-</span> <span class="fu">coef</span>(RegCluster)[[<span class="dv">2</span>]]</span>
<span id="cb365-24"><a href="cluster.html#cb365-24" aria-hidden="true" tabindex="-1"></a>  <span class="co"># return</span></span>
<span id="cb365-25"><a href="cluster.html#cb365-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(WW)</span>
<span id="cb365-26"><a href="cluster.html#cb365-26" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb365-27"><a href="cluster.html#cb365-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb365-28"><a href="cluster.html#cb365-28" aria-hidden="true" tabindex="-1"></a><span class="co"># testing</span></span>
<span id="cb365-29"><a href="cluster.html#cb365-29" aria-hidden="true" tabindex="-1"></a>test <span class="ot">&lt;-</span> <span class="fu">NPBootCluster</span>(<span class="at">seed=</span><span class="dv">1</span>,<span class="at">data=</span>dataCluster,<span class="at">cluster=</span><span class="st">&#39;Cluster&#39;</span>,<span class="at">y=</span><span class="st">&#39;yA&#39;</span>,<span class="at">D=</span><span class="st">&#39;R&#39;</span>)</span>
<span id="cb365-30"><a href="cluster.html#cb365-30" aria-hidden="true" tabindex="-1"></a><span class="co"># programming to run in parallel</span></span>
<span id="cb365-31"><a href="cluster.html#cb365-31" aria-hidden="true" tabindex="-1"></a>sf.NP.Boot.Cluster <span class="ot">&lt;-</span> <span class="cf">function</span>(Nsim,...){</span>
<span id="cb365-32"><a href="cluster.html#cb365-32" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sfInit</span>(<span class="at">parallel=</span><span class="cn">TRUE</span>,<span class="at">cpus=</span><span class="dv">8</span>)</span>
<span id="cb365-33"><a href="cluster.html#cb365-33" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sfLibrary</span>(dplyr)</span>
<span id="cb365-34"><a href="cluster.html#cb365-34" aria-hidden="true" tabindex="-1"></a>  sim <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">unlist</span>(<span class="fu">sfLapply</span>(<span class="dv">1</span><span class="sc">:</span>Nsim,NPBootCluster,<span class="at">data=</span>dataCluster,<span class="at">cluster=</span><span class="st">&#39;Cluster&#39;</span>,<span class="at">y=</span><span class="st">&#39;yA&#39;</span>,<span class="at">D=</span><span class="st">&#39;R&#39;</span>)),<span class="at">nrow=</span>Nsim,<span class="at">ncol=</span><span class="dv">1</span>,<span class="at">byrow=</span><span class="cn">TRUE</span>)</span>
<span id="cb365-35"><a href="cluster.html#cb365-35" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sfStop</span>()</span>
<span id="cb365-36"><a href="cluster.html#cb365-36" aria-hidden="true" tabindex="-1"></a>  <span class="fu">colnames</span>(sim) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&#39;WW&#39;</span>)</span>
<span id="cb365-37"><a href="cluster.html#cb365-37" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(sim)</span>
<span id="cb365-38"><a href="cluster.html#cb365-38" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb365-39"><a href="cluster.html#cb365-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Number of simulations </span></span>
<span id="cb365-40"><a href="cluster.html#cb365-40" aria-hidden="true" tabindex="-1"></a><span class="co">#Nsim &lt;- 10</span></span>
<span id="cb365-41"><a href="cluster.html#cb365-41" aria-hidden="true" tabindex="-1"></a>Nsim <span class="ot">&lt;-</span> <span class="dv">400</span></span>
<span id="cb365-42"><a href="cluster.html#cb365-42" aria-hidden="true" tabindex="-1"></a><span class="co"># running in parallel</span></span>
<span id="cb365-43"><a href="cluster.html#cb365-43" aria-hidden="true" tabindex="-1"></a>simuls.NP.Boot.Cluster <span class="ot">&lt;-</span> <span class="fu">sf.NP.Boot.Cluster</span>(<span class="at">Nsim=</span>Nsim,<span class="at">data=</span>dataCluster,<span class="at">cluster=</span><span class="st">&#39;Cluster&#39;</span>,<span class="at">y=</span><span class="st">&#39;yA&#39;</span>,<span class="at">D=</span><span class="st">&#39;R&#39;</span>)</span></code></pre></div>
<pre><code>## R Version:  R version 4.1.1 (2021-08-10) 
## 
## Library dplyr loaded.</code></pre>
<div class="sourceCode" id="cb367"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb367-1"><a href="cluster.html#cb367-1" aria-hidden="true" tabindex="-1"></a><span class="co"># estimating variance</span></span>
<span id="cb367-2"><a href="cluster.html#cb367-2" aria-hidden="true" tabindex="-1"></a>VarClusteredWWNPBoot <span class="ot">&lt;-</span> <span class="fu">var</span>(simuls.NP.Boot.Cluster)</span></code></pre></div>
<p>The cluster-robust non-parametric bootstrap estimate of sampling noise is equal to 0.48.
The true level of sampling noise estimated from the simulations is 0.43.</p>
</div>
<div id="using-randomization-inference" class="section level4 hasAnchor" number="9.1.3.5">
<h4><span class="header-section-number">9.1.3.5</span> Using Randomization inference<a href="cluster.html#using-randomization-inference" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Randomization inference is a different way to obtain estimates of the true level of sampling noise using resampling estimates.
One intuitive way of running randomization inference would be to draw new vectors of treatment status at the cluster level and estimate the variability of treatment effect estimates.
One problem with that approach is that it does not take into account the fact that treated and control differ by the amount of the treatment effect and that is going to add some additional noise in the estimate.
A more rigorous approach follows the suggestion in <a href="https://doi.org/10.1017/CBO9781139025751.006">Imbens and Rubin (2015), Section 5.7</a> and proceed as follows:</p>
<ol style="list-style-type: decimal">
<li>Assume a size for the treatment effect (let’s call it <span class="math inline">\(\tau\)</span>)</li>
<li>Compute each potential outcome for each treated (<span class="math inline">\(\tilde{Y}_i^0=Y_i-\tau\)</span> and <span class="math inline">\(\tilde{Y}_i^1=Y_i\)</span>) and each untreated (<span class="math inline">\(\tilde{Y}_i^1=Y_i+\tau\)</span> and <span class="math inline">\(\tilde{Y}_i^0=Y_i\)</span>) unit in the original sample</li>
<li>Draw a new treatment allocation <span class="math inline">\(\tilde{R}^1_i\)</span></li>
<li>Compute the realized outcomes <span class="math inline">\(\tilde{Y}_i=\tilde{Y}_i^1\tilde{R}^1_i+\tilde{Y}_i^0(1-\tilde{R}^1_i)\)</span></li>
<li>Compute the <span class="math inline">\(WW\)</span> estimate <span class="math inline">\(\tilde{\Delta}^Y_{WW_1}\)</span> using the new treatment allocation <span class="math inline">\(\tilde{R}^1_i\)</span> and the realized outcomes <span class="math inline">\(\tilde{Y}_i\)</span></li>
<li>Repeat the operation <span class="math inline">\(\tilde{N}\)</span> times, to obtain <span class="math inline">\(\left\{\tilde{\Delta}^Y_{WW_k}\right\}_{k=1}^{\tilde{N}}\)</span></li>
<li>Compute the empirical p-value <span class="math inline">\(\tilde{p}(\tau)\)</span> as the proportion of sample draws where <span class="math inline">\(\left|\tilde{\Delta}^Y_{WW_k}-\tau\right|\leq\left|\hat{\Delta}^Y_{WW}-\tau\right|\)</span>, where <span class="math inline">\(\hat{\Delta}^Y_{WW}\)</span> is the treatment effect estimate in the original sample.</li>
<li>Repeat for various values of <span class="math inline">\(\tau\)</span> on a set of points <span class="math inline">\(\tau_1,\dots,\tau_{K}\)</span>.</li>
<li>Find the values <span class="math inline">\(\tau^u_{\alpha}\)</span> and <span class="math inline">\(\tau^l_{\alpha}\)</span> that are such that <span class="math inline">\(\tilde{p}(\tau^u_{\alpha})\approx\alpha\approx\tilde{p}(\tau^l_{\alpha})\)</span> and <span class="math inline">\(\tau^l_{\alpha}&lt;\hat{\Delta}^Y_{WW}&lt;\tau^u_{\alpha}\)</span>.
<span class="math inline">\(\left[\tau^l_{\alpha},\tau^u_{\alpha}\right]\)</span> is the <span class="math inline">\(1-\alpha\)</span> cluster robust randomizaiton inference-based confidence interval for <span class="math inline">\(\hat{\Delta}^Y_{WW}\)</span>.</li>
</ol>
<div class="example">
<p><span id="exm:unnamed-chunk-375" class="example"><strong>Example 9.7  </strong></span>Let’s see how that works in our example.</p>
</div>
<div class="sourceCode" id="cb368"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb368-1"><a href="cluster.html#cb368-1" aria-hidden="true" tabindex="-1"></a><span class="co"># function computing one randomization inference draw for one value of tau</span></span>
<span id="cb368-2"><a href="cluster.html#cb368-2" aria-hidden="true" tabindex="-1"></a><span class="co"># s: the seed for the PRNG</span></span>
<span id="cb368-3"><a href="cluster.html#cb368-3" aria-hidden="true" tabindex="-1"></a><span class="co"># data: the dataset</span></span>
<span id="cb368-4"><a href="cluster.html#cb368-4" aria-hidden="true" tabindex="-1"></a><span class="co"># cluster: the name of the cluster variable (with cluster variable indexed from 1 to Nc)</span></span>
<span id="cb368-5"><a href="cluster.html#cb368-5" aria-hidden="true" tabindex="-1"></a><span class="co"># y: the name of the outcome variable</span></span>
<span id="cb368-6"><a href="cluster.html#cb368-6" aria-hidden="true" tabindex="-1"></a><span class="co"># D: the name of the treatment variable</span></span>
<span id="cb368-7"><a href="cluster.html#cb368-7" aria-hidden="true" tabindex="-1"></a>ClusteredRI <span class="ot">&lt;-</span> <span class="cf">function</span>(s,tau,data,cluster,y,D){</span>
<span id="cb368-8"><a href="cluster.html#cb368-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Compute potential outcomes</span></span>
<span id="cb368-9"><a href="cluster.html#cb368-9" aria-hidden="true" tabindex="-1"></a>  data <span class="ot">&lt;-</span> data <span class="sc">%&gt;%</span></span>
<span id="cb368-10"><a href="cluster.html#cb368-10" aria-hidden="true" tabindex="-1"></a>            <span class="fu">mutate</span>(</span>
<span id="cb368-11"><a href="cluster.html#cb368-11" aria-hidden="true" tabindex="-1"></a>              <span class="at">y0 =</span> <span class="fu">case_when</span>(</span>
<span id="cb368-12"><a href="cluster.html#cb368-12" aria-hidden="true" tabindex="-1"></a>                <span class="sc">!!</span><span class="fu">sym</span>(D)<span class="sc">==</span><span class="dv">1</span> <span class="sc">~</span> <span class="sc">!!</span><span class="fu">sym</span>(y)<span class="sc">-</span>tau,</span>
<span id="cb368-13"><a href="cluster.html#cb368-13" aria-hidden="true" tabindex="-1"></a>                <span class="sc">!!</span><span class="fu">sym</span>(D)<span class="sc">==</span><span class="dv">0</span> <span class="sc">~</span> <span class="sc">!!</span><span class="fu">sym</span>(y),</span>
<span id="cb368-14"><a href="cluster.html#cb368-14" aria-hidden="true" tabindex="-1"></a>                <span class="cn">TRUE</span> <span class="sc">~</span> <span class="dv">99</span></span>
<span id="cb368-15"><a href="cluster.html#cb368-15" aria-hidden="true" tabindex="-1"></a>              ),</span>
<span id="cb368-16"><a href="cluster.html#cb368-16" aria-hidden="true" tabindex="-1"></a>              <span class="at">y1 =</span> <span class="fu">case_when</span>(</span>
<span id="cb368-17"><a href="cluster.html#cb368-17" aria-hidden="true" tabindex="-1"></a>                <span class="sc">!!</span><span class="fu">sym</span>(D)<span class="sc">==</span><span class="dv">1</span> <span class="sc">~</span> <span class="sc">!!</span><span class="fu">sym</span>(y),</span>
<span id="cb368-18"><a href="cluster.html#cb368-18" aria-hidden="true" tabindex="-1"></a>                <span class="sc">!!</span><span class="fu">sym</span>(D)<span class="sc">==</span><span class="dv">0</span> <span class="sc">~</span> <span class="sc">!!</span><span class="fu">sym</span>(y)<span class="sc">+</span>tau,</span>
<span id="cb368-19"><a href="cluster.html#cb368-19" aria-hidden="true" tabindex="-1"></a>                <span class="cn">TRUE</span> <span class="sc">~</span> <span class="dv">99</span></span>
<span id="cb368-20"><a href="cluster.html#cb368-20" aria-hidden="true" tabindex="-1"></a>              )</span>
<span id="cb368-21"><a href="cluster.html#cb368-21" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb368-22"><a href="cluster.html#cb368-22" aria-hidden="true" tabindex="-1"></a>  <span class="co"># drawing alternative treatment vector at cluster level</span></span>
<span id="cb368-23"><a href="cluster.html#cb368-23" aria-hidden="true" tabindex="-1"></a>  <span class="co"># compute number of clusters</span></span>
<span id="cb368-24"><a href="cluster.html#cb368-24" aria-hidden="true" tabindex="-1"></a>  NClusters <span class="ot">&lt;-</span> data <span class="sc">%&gt;%</span></span>
<span id="cb368-25"><a href="cluster.html#cb368-25" aria-hidden="true" tabindex="-1"></a>                <span class="fu">group_by</span>(<span class="sc">!!</span><span class="fu">sym</span>(cluster)) <span class="sc">%&gt;%</span></span>
<span id="cb368-26"><a href="cluster.html#cb368-26" aria-hidden="true" tabindex="-1"></a>                <span class="fu">summarize</span>(<span class="at">count=</span><span class="fu">n</span>()) <span class="sc">%&gt;%</span></span>
<span id="cb368-27"><a href="cluster.html#cb368-27" aria-hidden="true" tabindex="-1"></a>                <span class="fu">ungroup</span>(.) <span class="sc">%&gt;%</span></span>
<span id="cb368-28"><a href="cluster.html#cb368-28" aria-hidden="true" tabindex="-1"></a>                <span class="fu">summarize</span>(<span class="at">NClusters=</span><span class="fu">n</span>())</span>
<span id="cb368-29"><a href="cluster.html#cb368-29" aria-hidden="true" tabindex="-1"></a>  <span class="co"># set seed</span></span>
<span id="cb368-30"><a href="cluster.html#cb368-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set.seed</span>(s)</span>
<span id="cb368-31"><a href="cluster.html#cb368-31" aria-hidden="true" tabindex="-1"></a>  <span class="co"># randomized allocation at the cluster level</span></span>
<span id="cb368-32"><a href="cluster.html#cb368-32" aria-hidden="true" tabindex="-1"></a>  Rs <span class="ot">&lt;-</span> <span class="fu">runif</span>(NClusters[[<span class="dv">1</span>]])</span>
<span id="cb368-33"><a href="cluster.html#cb368-33" aria-hidden="true" tabindex="-1"></a>  <span class="co"># cluster level treatment vector</span></span>
<span id="cb368-34"><a href="cluster.html#cb368-34" aria-hidden="true" tabindex="-1"></a>  Rc <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(Rs<span class="sc">&lt;=</span>.<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">0</span>)</span>
<span id="cb368-35"><a href="cluster.html#cb368-35" aria-hidden="true" tabindex="-1"></a>  <span class="co"># dataframe of treated joined to original data</span></span>
<span id="cb368-36"><a href="cluster.html#cb368-36" aria-hidden="true" tabindex="-1"></a>  RIdata <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">ClusterId=</span><span class="dv">1</span><span class="sc">:</span>NClusters[[<span class="dv">1</span>]],<span class="at">Rc=</span>Rc) <span class="sc">%&gt;%</span></span>
<span id="cb368-37"><a href="cluster.html#cb368-37" aria-hidden="true" tabindex="-1"></a>            <span class="fu">left_join</span>(data,<span class="at">by=</span><span class="fu">c</span>(<span class="st">&quot;ClusterId&quot;</span><span class="ot">=</span>cluster)) <span class="sc">%&gt;%</span></span>
<span id="cb368-38"><a href="cluster.html#cb368-38" aria-hidden="true" tabindex="-1"></a>            <span class="co">#generating RI observed outcomes</span></span>
<span id="cb368-39"><a href="cluster.html#cb368-39" aria-hidden="true" tabindex="-1"></a>            <span class="fu">mutate</span>(</span>
<span id="cb368-40"><a href="cluster.html#cb368-40" aria-hidden="true" tabindex="-1"></a>              <span class="at">yc =</span> y0<span class="sc">*</span>(<span class="dv">1</span><span class="sc">-</span>Rc)<span class="sc">+</span>y1<span class="sc">*</span>Rc</span>
<span id="cb368-41"><a href="cluster.html#cb368-41" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb368-42"><a href="cluster.html#cb368-42" aria-hidden="true" tabindex="-1"></a>  <span class="co"># estimating the RI WW treatment effect</span></span>
<span id="cb368-43"><a href="cluster.html#cb368-43" aria-hidden="true" tabindex="-1"></a>  RegWWRI <span class="ot">&lt;-</span> <span class="fu">lm</span>(yc<span class="sc">~</span>Rc,<span class="at">data=</span>RIdata)</span>
<span id="cb368-44"><a href="cluster.html#cb368-44" aria-hidden="true" tabindex="-1"></a>  <span class="co"># returning estimate</span></span>
<span id="cb368-45"><a href="cluster.html#cb368-45" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">coef</span>(RegWWRI)[[<span class="dv">2</span>]])</span>
<span id="cb368-46"><a href="cluster.html#cb368-46" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb368-47"><a href="cluster.html#cb368-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb368-48"><a href="cluster.html#cb368-48" aria-hidden="true" tabindex="-1"></a><span class="co"># testing</span></span>
<span id="cb368-49"><a href="cluster.html#cb368-49" aria-hidden="true" tabindex="-1"></a>testRI <span class="ot">&lt;-</span> <span class="fu">ClusteredRI</span>(<span class="at">s=</span><span class="dv">1</span>,<span class="at">tau=</span><span class="dv">0</span>,<span class="at">data=</span>dataCluster,<span class="at">cluster=</span><span class="st">&#39;Cluster&#39;</span>,<span class="at">y=</span><span class="st">&#39;yA&#39;</span>,<span class="at">D=</span><span class="st">&#39;R&#39;</span>)</span>
<span id="cb368-50"><a href="cluster.html#cb368-50" aria-hidden="true" tabindex="-1"></a><span class="co"># testing sapply</span></span>
<span id="cb368-51"><a href="cluster.html#cb368-51" aria-hidden="true" tabindex="-1"></a>Nsim <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="cb368-52"><a href="cluster.html#cb368-52" aria-hidden="true" tabindex="-1"></a>testRIapply <span class="ot">&lt;-</span> <span class="fu">sapply</span>(<span class="dv">1</span><span class="sc">:</span>Nsim,ClusteredRI,<span class="at">tau=</span><span class="dv">0</span>,<span class="at">data=</span>dataCluster,<span class="at">cluster=</span><span class="st">&#39;Cluster&#39;</span>,<span class="at">y=</span><span class="st">&#39;yA&#39;</span>,<span class="at">D=</span><span class="st">&#39;R&#39;</span>)</span>
<span id="cb368-53"><a href="cluster.html#cb368-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb368-54"><a href="cluster.html#cb368-54" aria-hidden="true" tabindex="-1"></a><span class="co"># parallelize for one value of tau</span></span>
<span id="cb368-55"><a href="cluster.html#cb368-55" aria-hidden="true" tabindex="-1"></a><span class="co"># programming to run in parallel</span></span>
<span id="cb368-56"><a href="cluster.html#cb368-56" aria-hidden="true" tabindex="-1"></a>sf.RI.Cluster <span class="ot">&lt;-</span> <span class="cf">function</span>(Nsim,tau,data,cluster,y,D){</span>
<span id="cb368-57"><a href="cluster.html#cb368-57" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sfInit</span>(<span class="at">parallel=</span><span class="cn">TRUE</span>,<span class="at">cpus=</span><span class="dv">8</span>)</span>
<span id="cb368-58"><a href="cluster.html#cb368-58" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sfLibrary</span>(dplyr)</span>
<span id="cb368-59"><a href="cluster.html#cb368-59" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sfExport</span>(<span class="st">&#39;dataCluster&#39;</span>)</span>
<span id="cb368-60"><a href="cluster.html#cb368-60" aria-hidden="true" tabindex="-1"></a>  sim <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">unlist</span>(<span class="fu">sfLapply</span>(<span class="dv">1</span><span class="sc">:</span>Nsim,ClusteredRI,<span class="at">tau=</span>tau,<span class="at">data=</span>data,<span class="at">cluster=</span>cluster,<span class="at">y=</span>y,<span class="at">D=</span>D)),<span class="at">nrow=</span>Nsim,<span class="at">ncol=</span><span class="dv">1</span>,<span class="at">byrow=</span><span class="cn">TRUE</span>)</span>
<span id="cb368-61"><a href="cluster.html#cb368-61" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sfStop</span>()</span>
<span id="cb368-62"><a href="cluster.html#cb368-62" aria-hidden="true" tabindex="-1"></a>  <span class="fu">colnames</span>(sim) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&#39;WW&#39;</span>)</span>
<span id="cb368-63"><a href="cluster.html#cb368-63" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(sim)</span>
<span id="cb368-64"><a href="cluster.html#cb368-64" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb368-65"><a href="cluster.html#cb368-65" aria-hidden="true" tabindex="-1"></a><span class="co"># testing</span></span>
<span id="cb368-66"><a href="cluster.html#cb368-66" aria-hidden="true" tabindex="-1"></a>sf.test.RI <span class="ot">&lt;-</span> <span class="fu">sf.RI.Cluster</span>(<span class="at">Nsim=</span>Nsim,<span class="at">tau=</span><span class="dv">0</span>,<span class="at">data=</span>dataCluster,<span class="at">cluster=</span><span class="st">&#39;Cluster&#39;</span>,<span class="at">y=</span><span class="st">&#39;yA&#39;</span>,<span class="at">D=</span><span class="st">&#39;R&#39;</span>)</span>
<span id="cb368-67"><a href="cluster.html#cb368-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb368-68"><a href="cluster.html#cb368-68" aria-hidden="true" tabindex="-1"></a><span class="co"># lapply over values of tau on a grid</span></span>
<span id="cb368-69"><a href="cluster.html#cb368-69" aria-hidden="true" tabindex="-1"></a><span class="co"># function that takes tau as an input and spits out the empirical p-value</span></span>
<span id="cb368-70"><a href="cluster.html#cb368-70" aria-hidden="true" tabindex="-1"></a><span class="co"># tau: hypothesized value of treatment effect</span></span>
<span id="cb368-71"><a href="cluster.html#cb368-71" aria-hidden="true" tabindex="-1"></a><span class="co"># WWhat: estimated vamlue of treatment effect in the original sample</span></span>
<span id="cb368-72"><a href="cluster.html#cb368-72" aria-hidden="true" tabindex="-1"></a>ParallelClusteredRI <span class="ot">&lt;-</span> <span class="cf">function</span>(tau,WWhat,...){</span>
<span id="cb368-73"><a href="cluster.html#cb368-73" aria-hidden="true" tabindex="-1"></a>  <span class="co"># computing the RI distribution of WW estimates for given tau</span></span>
<span id="cb368-74"><a href="cluster.html#cb368-74" aria-hidden="true" tabindex="-1"></a>  sf.WW.RI <span class="ot">&lt;-</span> <span class="fu">sf.RI.Cluster</span>(<span class="at">tau=</span>tau,...)</span>
<span id="cb368-75"><a href="cluster.html#cb368-75" aria-hidden="true" tabindex="-1"></a>  <span class="co"># estimate enpirical cdf of |WWRI-tau|</span></span>
<span id="cb368-76"><a href="cluster.html#cb368-76" aria-hidden="true" tabindex="-1"></a>  F.WW.RI.tau <span class="ot">&lt;-</span> <span class="fu">ecdf</span>(<span class="fu">abs</span>(sf.WW.RI<span class="sc">-</span>tau))</span>
<span id="cb368-77"><a href="cluster.html#cb368-77" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Compute the p-value</span></span>
<span id="cb368-78"><a href="cluster.html#cb368-78" aria-hidden="true" tabindex="-1"></a>  pvalue <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">-</span><span class="fu">F.WW.RI.tau</span>(<span class="fu">abs</span>(WWhat<span class="sc">-</span>tau))</span>
<span id="cb368-79"><a href="cluster.html#cb368-79" aria-hidden="true" tabindex="-1"></a>  <span class="co"># return the p-value</span></span>
<span id="cb368-80"><a href="cluster.html#cb368-80" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(pvalue)</span>
<span id="cb368-81"><a href="cluster.html#cb368-81" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb368-82"><a href="cluster.html#cb368-82" aria-hidden="true" tabindex="-1"></a><span class="co"># testing</span></span>
<span id="cb368-83"><a href="cluster.html#cb368-83" aria-hidden="true" tabindex="-1"></a>testRItau <span class="ot">&lt;-</span> <span class="fu">ParallelClusteredRI</span>(<span class="at">tau=</span><span class="dv">0</span>,<span class="at">WWhat=</span><span class="fl">0.2</span>,<span class="at">Nsim=</span>Nsim,<span class="at">data=</span>dataCluster,<span class="at">cluster=</span><span class="st">&#39;Cluster&#39;</span>,<span class="at">y=</span><span class="st">&#39;yA&#39;</span>,<span class="at">D=</span><span class="st">&#39;R&#39;</span>)</span>
<span id="cb368-84"><a href="cluster.html#cb368-84" aria-hidden="true" tabindex="-1"></a><span class="co"># run on a grid of tau&#39;s</span></span>
<span id="cb368-85"><a href="cluster.html#cb368-85" aria-hidden="true" tabindex="-1"></a>tau.grid <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="at">from=</span><span class="sc">-</span><span class="fl">0.15</span>,<span class="at">to=</span><span class="fl">0.55</span>,<span class="at">by=</span><span class="fl">0.01</span>)</span>
<span id="cb368-86"><a href="cluster.html#cb368-86" aria-hidden="true" tabindex="-1"></a>Nsim <span class="ot">&lt;-</span> <span class="dv">1000</span></span>
<span id="cb368-87"><a href="cluster.html#cb368-87" aria-hidden="true" tabindex="-1"></a>simuls.RI.tau <span class="ot">&lt;-</span> <span class="fu">sapply</span>(tau.grid,ParallelClusteredRI,<span class="at">WWhat=</span><span class="fl">0.2</span>,<span class="at">Nsim=</span>Nsim,<span class="at">data=</span>dataCluster,<span class="at">cluster=</span><span class="st">&#39;Cluster&#39;</span>,<span class="at">y=</span><span class="st">&#39;yA&#39;</span>,<span class="at">D=</span><span class="st">&#39;R&#39;</span>)</span>
<span id="cb368-88"><a href="cluster.html#cb368-88" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(simuls.RI.tau) <span class="ot">&lt;-</span> tau.grid</span>
<span id="cb368-89"><a href="cluster.html#cb368-89" aria-hidden="true" tabindex="-1"></a><span class="co"># putting results in data frame</span></span>
<span id="cb368-90"><a href="cluster.html#cb368-90" aria-hidden="true" tabindex="-1"></a>RI.pvalues.tau <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">pvalue=</span>simuls.RI.tau,<span class="at">tau=</span>tau.grid)</span></code></pre></div>
<p>Let us visualize the resulting estimates of the p-values as a function of <span class="math inline">\(\tau\)</span>:</p>
<div class="sourceCode" id="cb369"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb369-1"><a href="cluster.html#cb369-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(RI.pvalues.tau,<span class="fu">aes</span>(<span class="at">x=</span>tau,<span class="at">y=</span>pvalue))<span class="sc">+</span></span>
<span id="cb369-2"><a href="cluster.html#cb369-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb369-3"><a href="cluster.html#cb369-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>() <span class="sc">+</span></span>
<span id="cb369-4"><a href="cluster.html#cb369-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_hline</span>(<span class="at">yintercept =</span> <span class="fl">0.05</span>,<span class="at">linetype=</span><span class="st">&#39;dotted&#39;</span>,<span class="at">color=</span><span class="st">&#39;red&#39;</span>)<span class="sc">+</span></span>
<span id="cb369-5"><a href="cluster.html#cb369-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ylim</span>(<span class="dv">0</span>,<span class="dv">1</span>) <span class="sc">+</span></span>
<span id="cb369-6"><a href="cluster.html#cb369-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ylab</span>(<span class="st">&quot;p-value&quot;</span>) <span class="sc">+</span></span>
<span id="cb369-7"><a href="cluster.html#cb369-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="fu">expression</span>(tau)) <span class="sc">+</span></span>
<span id="cb369-8"><a href="cluster.html#cb369-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span></code></pre></div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:RICLusterPlot"></span>
<img src="STCI_files/figure-html/RICLusterPlot-1.png" alt="Randomization inference p-values as a function of $\tau$" width="65%" />
<p class="caption">
Figure 9.4: Randomization inference p-values as a function of <span class="math inline">\(\tau\)</span>
</p>
</div>
<p>Let us now compute the confidence interval and estimate of sampling noise:</p>
<div class="sourceCode" id="cb370"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb370-1"><a href="cluster.html#cb370-1" aria-hidden="true" tabindex="-1"></a><span class="co"># computing RI-based confidence interval and sampling noise estimate</span></span>
<span id="cb370-2"><a href="cluster.html#cb370-2" aria-hidden="true" tabindex="-1"></a><span class="co"># function that takes a dataframe of pvalues and a grid and spits out both ends of confidence interval and level delta and sampling noise</span></span>
<span id="cb370-3"><a href="cluster.html#cb370-3" aria-hidden="true" tabindex="-1"></a><span class="co"># delta: level of the confidence interval (95% or 99% for example)</span></span>
<span id="cb370-4"><a href="cluster.html#cb370-4" aria-hidden="true" tabindex="-1"></a><span class="co"># data: a data frame with a variable for tau and a variable for pvalues</span></span>
<span id="cb370-5"><a href="cluster.html#cb370-5" aria-hidden="true" tabindex="-1"></a><span class="co"># tau: name of the tau variable</span></span>
<span id="cb370-6"><a href="cluster.html#cb370-6" aria-hidden="true" tabindex="-1"></a><span class="co"># pval: name of the pvalue variable</span></span>
<span id="cb370-7"><a href="cluster.html#cb370-7" aria-hidden="true" tabindex="-1"></a>RI.CI <span class="ot">&lt;-</span> <span class="cf">function</span>(delta,data,tau,pval){</span>
<span id="cb370-8"><a href="cluster.html#cb370-8" aria-hidden="true" tabindex="-1"></a>  data <span class="ot">&lt;-</span> data <span class="sc">%&gt;%</span></span>
<span id="cb370-9"><a href="cluster.html#cb370-9" aria-hidden="true" tabindex="-1"></a>            <span class="fu">mutate</span>(</span>
<span id="cb370-10"><a href="cluster.html#cb370-10" aria-hidden="true" tabindex="-1"></a>              <span class="co"># finding observations with pvalue lower than delta</span></span>
<span id="cb370-11"><a href="cluster.html#cb370-11" aria-hidden="true" tabindex="-1"></a>              <span class="at">below.pval =</span> <span class="fu">case_when</span>(</span>
<span id="cb370-12"><a href="cluster.html#cb370-12" aria-hidden="true" tabindex="-1"></a>                <span class="sc">!!</span><span class="fu">sym</span>(pval) <span class="sc">&lt;=</span> <span class="dv">1</span><span class="sc">-</span>delta <span class="sc">~</span> <span class="dv">1</span>,</span>
<span id="cb370-13"><a href="cluster.html#cb370-13" aria-hidden="true" tabindex="-1"></a>                <span class="sc">!!</span><span class="fu">sym</span>(pval) <span class="sc">&gt;</span> <span class="dv">1</span><span class="sc">-</span>delta <span class="sc">~</span> <span class="dv">0</span>,</span>
<span id="cb370-14"><a href="cluster.html#cb370-14" aria-hidden="true" tabindex="-1"></a>                <span class="cn">TRUE</span> <span class="sc">~</span><span class="dv">99</span></span>
<span id="cb370-15"><a href="cluster.html#cb370-15" aria-hidden="true" tabindex="-1"></a>              ),</span>
<span id="cb370-16"><a href="cluster.html#cb370-16" aria-hidden="true" tabindex="-1"></a>              <span class="co"># finding observations below the tau with maximum pvalue</span></span>
<span id="cb370-17"><a href="cluster.html#cb370-17" aria-hidden="true" tabindex="-1"></a>              <span class="at">max.pval =</span> <span class="fu">max</span>(<span class="sc">!!</span><span class="fu">sym</span>(pval)),</span>
<span id="cb370-18"><a href="cluster.html#cb370-18" aria-hidden="true" tabindex="-1"></a>              <span class="at">max.pval.tau =</span> <span class="fu">case_when</span>(</span>
<span id="cb370-19"><a href="cluster.html#cb370-19" aria-hidden="true" tabindex="-1"></a>                <span class="sc">!!</span><span class="fu">sym</span>(pval) <span class="sc">==</span> max.pval <span class="sc">~</span> <span class="sc">!!</span><span class="fu">sym</span>(tau),</span>
<span id="cb370-20"><a href="cluster.html#cb370-20" aria-hidden="true" tabindex="-1"></a>                <span class="cn">TRUE</span> <span class="sc">~</span> <span class="sc">-</span><span class="cn">Inf</span></span>
<span id="cb370-21"><a href="cluster.html#cb370-21" aria-hidden="true" tabindex="-1"></a>              ),</span>
<span id="cb370-22"><a href="cluster.html#cb370-22" aria-hidden="true" tabindex="-1"></a>              <span class="at">max.pval.tau =</span> <span class="fu">max</span>(max.pval.tau),</span>
<span id="cb370-23"><a href="cluster.html#cb370-23" aria-hidden="true" tabindex="-1"></a>              <span class="at">below.max.paval.tau =</span> <span class="fu">case_when</span>(</span>
<span id="cb370-24"><a href="cluster.html#cb370-24" aria-hidden="true" tabindex="-1"></a>                tau<span class="sc">&lt;</span>max.pval.tau <span class="sc">~</span> <span class="dv">1</span>,</span>
<span id="cb370-25"><a href="cluster.html#cb370-25" aria-hidden="true" tabindex="-1"></a>                tau<span class="sc">&gt;=</span>max.pval.tau <span class="sc">~</span> <span class="dv">0</span>,</span>
<span id="cb370-26"><a href="cluster.html#cb370-26" aria-hidden="true" tabindex="-1"></a>                <span class="cn">TRUE</span> <span class="sc">~</span> <span class="cn">Inf</span></span>
<span id="cb370-27"><a href="cluster.html#cb370-27" aria-hidden="true" tabindex="-1"></a>              )</span>
<span id="cb370-28"><a href="cluster.html#cb370-28" aria-hidden="true" tabindex="-1"></a>            ) <span class="sc">%&gt;%</span></span>
<span id="cb370-29"><a href="cluster.html#cb370-29" aria-hidden="true" tabindex="-1"></a>            <span class="co"># keeping only observations that are below pval of delta%</span></span>
<span id="cb370-30"><a href="cluster.html#cb370-30" aria-hidden="true" tabindex="-1"></a>            <span class="fu">filter</span>(below.pval<span class="sc">==</span><span class="dv">1</span>) <span class="sc">%&gt;%</span></span>
<span id="cb370-31"><a href="cluster.html#cb370-31" aria-hidden="true" tabindex="-1"></a>            <span class="co"># grouping by whether tau is above or below the tau with maximum pvalue</span></span>
<span id="cb370-32"><a href="cluster.html#cb370-32" aria-hidden="true" tabindex="-1"></a>            <span class="fu">group_by</span>(below.max.paval.tau)</span>
<span id="cb370-33"><a href="cluster.html#cb370-33" aria-hidden="true" tabindex="-1"></a>  <span class="co"># finding max and min values that are extremes of delta% CI</span></span>
<span id="cb370-34"><a href="cluster.html#cb370-34" aria-hidden="true" tabindex="-1"></a>  minCI <span class="ot">&lt;-</span> data <span class="sc">%&gt;%</span></span>
<span id="cb370-35"><a href="cluster.html#cb370-35" aria-hidden="true" tabindex="-1"></a>            <span class="fu">filter</span>(below.max.paval.tau<span class="sc">==</span><span class="dv">1</span>) <span class="sc">%&gt;%</span></span>
<span id="cb370-36"><a href="cluster.html#cb370-36" aria-hidden="true" tabindex="-1"></a>            <span class="fu">ungroup</span>(.) <span class="sc">%&gt;%</span></span>
<span id="cb370-37"><a href="cluster.html#cb370-37" aria-hidden="true" tabindex="-1"></a>            <span class="fu">summarize</span>(</span>
<span id="cb370-38"><a href="cluster.html#cb370-38" aria-hidden="true" tabindex="-1"></a>              <span class="at">minCI =</span> <span class="fu">max</span>(<span class="sc">!!</span><span class="fu">sym</span>(tau))</span>
<span id="cb370-39"><a href="cluster.html#cb370-39" aria-hidden="true" tabindex="-1"></a>            ) <span class="sc">%&gt;%</span></span>
<span id="cb370-40"><a href="cluster.html#cb370-40" aria-hidden="true" tabindex="-1"></a>            <span class="fu">pull</span>(minCI)</span>
<span id="cb370-41"><a href="cluster.html#cb370-41" aria-hidden="true" tabindex="-1"></a>  maxCI <span class="ot">&lt;-</span> data <span class="sc">%&gt;%</span></span>
<span id="cb370-42"><a href="cluster.html#cb370-42" aria-hidden="true" tabindex="-1"></a>            <span class="fu">filter</span>(below.max.paval.tau<span class="sc">==</span><span class="dv">0</span>) <span class="sc">%&gt;%</span></span>
<span id="cb370-43"><a href="cluster.html#cb370-43" aria-hidden="true" tabindex="-1"></a>            <span class="fu">ungroup</span>(.) <span class="sc">%&gt;%</span></span>
<span id="cb370-44"><a href="cluster.html#cb370-44" aria-hidden="true" tabindex="-1"></a>            <span class="fu">summarize</span>(</span>
<span id="cb370-45"><a href="cluster.html#cb370-45" aria-hidden="true" tabindex="-1"></a>              <span class="at">maxCI =</span> <span class="fu">min</span>(<span class="sc">!!</span><span class="fu">sym</span>(tau))</span>
<span id="cb370-46"><a href="cluster.html#cb370-46" aria-hidden="true" tabindex="-1"></a>            ) <span class="sc">%&gt;%</span></span>
<span id="cb370-47"><a href="cluster.html#cb370-47" aria-hidden="true" tabindex="-1"></a>            <span class="fu">pull</span>(maxCI)</span>
<span id="cb370-48"><a href="cluster.html#cb370-48" aria-hidden="true" tabindex="-1"></a>  <span class="co"># results</span></span>
<span id="cb370-49"><a href="cluster.html#cb370-49" aria-hidden="true" tabindex="-1"></a>  results <span class="ot">&lt;-</span> <span class="fu">list</span>(minCI,maxCI,maxCI<span class="sc">-</span>minCI)</span>
<span id="cb370-50"><a href="cluster.html#cb370-50" aria-hidden="true" tabindex="-1"></a>  <span class="fu">names</span>(results) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;LowCI&quot;</span>,<span class="st">&quot;HighCI&quot;</span>,<span class="st">&quot;SamplingNoise&quot;</span>)</span>
<span id="cb370-51"><a href="cluster.html#cb370-51" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(results)</span>
<span id="cb370-52"><a href="cluster.html#cb370-52" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb370-53"><a href="cluster.html#cb370-53" aria-hidden="true" tabindex="-1"></a><span class="co"># test</span></span>
<span id="cb370-54"><a href="cluster.html#cb370-54" aria-hidden="true" tabindex="-1"></a>testRICI95 <span class="ot">&lt;-</span> <span class="fu">RI.CI</span>(<span class="at">delta=</span><span class="fl">0.95</span>,<span class="at">data=</span>RI.pvalues.tau,<span class="at">tau=</span><span class="st">&#39;tau&#39;</span>,<span class="at">pval=</span><span class="st">&#39;pvalue&#39;</span>)</span>
<span id="cb370-55"><a href="cluster.html#cb370-55" aria-hidden="true" tabindex="-1"></a>testRICI99 <span class="ot">&lt;-</span> <span class="fu">RI.CI</span>(<span class="at">delta=</span><span class="fl">0.99</span>,<span class="at">data=</span>RI.pvalues.tau,<span class="at">tau=</span><span class="st">&#39;tau&#39;</span>,<span class="at">pval=</span><span class="st">&#39;pvalue&#39;</span>)</span></code></pre></div>
<p>As a result of our procedure, the randomization inference based 95% confidence interval for the <span class="math inline">\(WW\)</span> estimator is <span class="math inline">\(\left[\right.\)</span> 0 , 0.39 <span class="math inline">\(\left.\right]\)</span> and the 99% sampling noise is equal to 0.5.<br />
The true level of sampling noise estimated from the simulations is 0.43.</p>
<div class="remark">
<p><span id="unlabeled-div-217" class="remark"><em>Remark</em>. </span>Another, simpler, option for implementing randomization inference would have been simply to reallocate the treatment vector among clusters and keep the original values of the outcomes instead of generating the outcomes under the null for each value of <span class="math inline">\(\tau\)</span>.
This is the simple approach we have used in Chapter <a href="FPSI.html#FPSI">2</a>.
The properties of this approach have not been studied to my knowledge, but it would be interest!ing to know under which conditions it is approximately correct.
Let’s check what would have happened if we had used this simpler approach to randomization inference.</p>
</div>
<div class="sourceCode" id="cb371"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb371-1"><a href="cluster.html#cb371-1" aria-hidden="true" tabindex="-1"></a><span class="co"># function computing one simplified randomization inference draw</span></span>
<span id="cb371-2"><a href="cluster.html#cb371-2" aria-hidden="true" tabindex="-1"></a><span class="co"># s: the seed for the PRNG</span></span>
<span id="cb371-3"><a href="cluster.html#cb371-3" aria-hidden="true" tabindex="-1"></a><span class="co"># data: the dataset</span></span>
<span id="cb371-4"><a href="cluster.html#cb371-4" aria-hidden="true" tabindex="-1"></a><span class="co"># cluster: the name of the cluster variable (with cluster variable indexed from 1 to Nc)</span></span>
<span id="cb371-5"><a href="cluster.html#cb371-5" aria-hidden="true" tabindex="-1"></a><span class="co"># y: the name of the outcome variable</span></span>
<span id="cb371-6"><a href="cluster.html#cb371-6" aria-hidden="true" tabindex="-1"></a><span class="co"># D: the name of the treatment variable</span></span>
<span id="cb371-7"><a href="cluster.html#cb371-7" aria-hidden="true" tabindex="-1"></a>ClusteredRISimple <span class="ot">&lt;-</span> <span class="cf">function</span>(s,data,cluster,y){</span>
<span id="cb371-8"><a href="cluster.html#cb371-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># drawing alternative treatment vector at cluster level</span></span>
<span id="cb371-9"><a href="cluster.html#cb371-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># compute number of clusters</span></span>
<span id="cb371-10"><a href="cluster.html#cb371-10" aria-hidden="true" tabindex="-1"></a>  NClusters <span class="ot">&lt;-</span> data <span class="sc">%&gt;%</span></span>
<span id="cb371-11"><a href="cluster.html#cb371-11" aria-hidden="true" tabindex="-1"></a>                <span class="fu">group_by</span>(<span class="sc">!!</span><span class="fu">sym</span>(cluster)) <span class="sc">%&gt;%</span></span>
<span id="cb371-12"><a href="cluster.html#cb371-12" aria-hidden="true" tabindex="-1"></a>                <span class="fu">summarize</span>(<span class="at">count=</span><span class="fu">n</span>()) <span class="sc">%&gt;%</span></span>
<span id="cb371-13"><a href="cluster.html#cb371-13" aria-hidden="true" tabindex="-1"></a>                <span class="fu">ungroup</span>(.) <span class="sc">%&gt;%</span></span>
<span id="cb371-14"><a href="cluster.html#cb371-14" aria-hidden="true" tabindex="-1"></a>                <span class="fu">summarize</span>(<span class="at">NClusters=</span><span class="fu">n</span>())</span>
<span id="cb371-15"><a href="cluster.html#cb371-15" aria-hidden="true" tabindex="-1"></a>  <span class="co"># set seed</span></span>
<span id="cb371-16"><a href="cluster.html#cb371-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set.seed</span>(s)</span>
<span id="cb371-17"><a href="cluster.html#cb371-17" aria-hidden="true" tabindex="-1"></a>  <span class="co"># randomized allocation at the cluster level</span></span>
<span id="cb371-18"><a href="cluster.html#cb371-18" aria-hidden="true" tabindex="-1"></a>  Rs <span class="ot">&lt;-</span> <span class="fu">runif</span>(NClusters[[<span class="dv">1</span>]])</span>
<span id="cb371-19"><a href="cluster.html#cb371-19" aria-hidden="true" tabindex="-1"></a>  <span class="co"># cluster level treatment vector</span></span>
<span id="cb371-20"><a href="cluster.html#cb371-20" aria-hidden="true" tabindex="-1"></a>  Rc <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(Rs<span class="sc">&lt;=</span>.<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">0</span>)</span>
<span id="cb371-21"><a href="cluster.html#cb371-21" aria-hidden="true" tabindex="-1"></a>  <span class="co"># dataframe of treated joined to original data</span></span>
<span id="cb371-22"><a href="cluster.html#cb371-22" aria-hidden="true" tabindex="-1"></a>  RIdata <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">ClusterId=</span><span class="dv">1</span><span class="sc">:</span>NClusters[[<span class="dv">1</span>]],<span class="at">Rc=</span>Rc) <span class="sc">%&gt;%</span></span>
<span id="cb371-23"><a href="cluster.html#cb371-23" aria-hidden="true" tabindex="-1"></a>            <span class="fu">left_join</span>(data,<span class="at">by=</span><span class="fu">c</span>(<span class="st">&quot;ClusterId&quot;</span><span class="ot">=</span>cluster)) </span>
<span id="cb371-24"><a href="cluster.html#cb371-24" aria-hidden="true" tabindex="-1"></a>  <span class="co"># estimating the RI WW treatment effect</span></span>
<span id="cb371-25"><a href="cluster.html#cb371-25" aria-hidden="true" tabindex="-1"></a>  RegWWRISimple <span class="ot">&lt;-</span> <span class="fu">lm</span>(<span class="fu">as.formula</span>(<span class="fu">paste</span>(y,<span class="st">&#39;Rc&#39;</span>,<span class="at">sep=</span><span class="st">&#39;~&#39;</span>)),<span class="at">data=</span>RIdata)</span>
<span id="cb371-26"><a href="cluster.html#cb371-26" aria-hidden="true" tabindex="-1"></a>  <span class="co"># returning estimate</span></span>
<span id="cb371-27"><a href="cluster.html#cb371-27" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">coef</span>(RegWWRISimple)[[<span class="dv">2</span>]])</span>
<span id="cb371-28"><a href="cluster.html#cb371-28" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb371-29"><a href="cluster.html#cb371-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb371-30"><a href="cluster.html#cb371-30" aria-hidden="true" tabindex="-1"></a><span class="co"># testing</span></span>
<span id="cb371-31"><a href="cluster.html#cb371-31" aria-hidden="true" tabindex="-1"></a>testRISimple <span class="ot">&lt;-</span> <span class="fu">ClusteredRISimple</span>(<span class="at">s=</span><span class="dv">1</span>,<span class="at">data=</span>dataCluster,<span class="at">cluster=</span><span class="st">&#39;Cluster&#39;</span>,<span class="at">y=</span><span class="st">&#39;yA&#39;</span>)</span>
<span id="cb371-32"><a href="cluster.html#cb371-32" aria-hidden="true" tabindex="-1"></a><span class="co"># testing sapply</span></span>
<span id="cb371-33"><a href="cluster.html#cb371-33" aria-hidden="true" tabindex="-1"></a>Nsim <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="cb371-34"><a href="cluster.html#cb371-34" aria-hidden="true" tabindex="-1"></a>testRISimpleapply <span class="ot">&lt;-</span> <span class="fu">sapply</span>(<span class="dv">1</span><span class="sc">:</span>Nsim,ClusteredRISimple,<span class="at">data=</span>dataCluster,<span class="at">cluster=</span><span class="st">&#39;Cluster&#39;</span>,<span class="at">y=</span><span class="st">&#39;yA&#39;</span>)</span>
<span id="cb371-35"><a href="cluster.html#cb371-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb371-36"><a href="cluster.html#cb371-36" aria-hidden="true" tabindex="-1"></a><span class="co"># programming to run in parallel</span></span>
<span id="cb371-37"><a href="cluster.html#cb371-37" aria-hidden="true" tabindex="-1"></a>sf.RI.Cluster.Simple <span class="ot">&lt;-</span> <span class="cf">function</span>(Nsim,data,cluster,y){</span>
<span id="cb371-38"><a href="cluster.html#cb371-38" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sfInit</span>(<span class="at">parallel=</span><span class="cn">TRUE</span>,<span class="at">cpus=</span><span class="dv">8</span>)</span>
<span id="cb371-39"><a href="cluster.html#cb371-39" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sfLibrary</span>(dplyr)</span>
<span id="cb371-40"><a href="cluster.html#cb371-40" aria-hidden="true" tabindex="-1"></a>  sim <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">unlist</span>(<span class="fu">sfLapply</span>(<span class="dv">1</span><span class="sc">:</span>Nsim,ClusteredRISimple,<span class="at">data=</span>data,<span class="at">cluster=</span>cluster,<span class="at">y=</span>y)),<span class="at">nrow=</span>Nsim,<span class="at">ncol=</span><span class="dv">1</span>,<span class="at">byrow=</span><span class="cn">TRUE</span>)</span>
<span id="cb371-41"><a href="cluster.html#cb371-41" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sfStop</span>()</span>
<span id="cb371-42"><a href="cluster.html#cb371-42" aria-hidden="true" tabindex="-1"></a>  <span class="fu">colnames</span>(sim) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&#39;WW&#39;</span>)</span>
<span id="cb371-43"><a href="cluster.html#cb371-43" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(sim)</span>
<span id="cb371-44"><a href="cluster.html#cb371-44" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb371-45"><a href="cluster.html#cb371-45" aria-hidden="true" tabindex="-1"></a><span class="co"># testing</span></span>
<span id="cb371-46"><a href="cluster.html#cb371-46" aria-hidden="true" tabindex="-1"></a>sf.test.RI.simple <span class="ot">&lt;-</span> <span class="fu">sf.RI.Cluster.Simple</span>(<span class="at">Nsim=</span>Nsim,<span class="at">data=</span>dataCluster,<span class="at">cluster=</span><span class="st">&#39;Cluster&#39;</span>,<span class="at">y=</span><span class="st">&#39;yA&#39;</span>)</span>
<span id="cb371-47"><a href="cluster.html#cb371-47" aria-hidden="true" tabindex="-1"></a><span class="co"># running</span></span>
<span id="cb371-48"><a href="cluster.html#cb371-48" aria-hidden="true" tabindex="-1"></a>Nsim <span class="ot">&lt;-</span> <span class="dv">1000</span></span>
<span id="cb371-49"><a href="cluster.html#cb371-49" aria-hidden="true" tabindex="-1"></a>simuls.RI.Simple <span class="ot">&lt;-</span> <span class="fu">sf.RI.Cluster.Simple</span>(<span class="at">Nsim=</span>Nsim,<span class="at">data=</span>dataCluster,<span class="at">cluster=</span><span class="st">&#39;Cluster&#39;</span>,<span class="at">y=</span><span class="st">&#39;yA&#39;</span>)</span>
<span id="cb371-50"><a href="cluster.html#cb371-50" aria-hidden="true" tabindex="-1"></a>Var.WW.RI.Simple <span class="ot">&lt;-</span> <span class="fu">var</span>(simuls.RI.Simple)</span></code></pre></div>
<p>With the simplified randomization inference procedure, the 99% sampling noise is equal to 0.49.<br />
The true level of sampling noise estimated from the simulations is 0.43.</p>
</div>
</div>
</div>
<div id="clustering-in-panel-data" class="section level2 hasAnchor" number="9.2">
<h2><span class="header-section-number">9.2</span> Clustering in panel data<a href="cluster.html#clustering-in-panel-data" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Another source of clustering appears in panel data, where we follow the same observation over time.
One way to account for the correlation between the outcomes of the same individual over time is to add individual level fixed effects, and to use either a within estimator or a Least Squares Dummy Variable estimator, as we did in Section <a href="NE.html#DID">4.3</a>.
But adding individual level fixed effects probably does not account for the overall correlation between observations of the same individual over time.
A case in point is autocorrelation in the error terms due to persistent shocks.
If a unit has experienced a shock at date <span class="math inline">\(t\)</span>, she is more likely to experience a similar shock at date <span class="math inline">\(t+1\)</span>.
For example, health problems do not solve themselves miraculously between survey rounds.
In the same manner, job loss or job changes or hurricanes, etc, all have effects that persist over time.
As a consequence, we often believe that the observations for the same unit are correlated over time, abve and beyond what can be captured by a unit fixed effect.
In this section, we are going to study the issue of clustering in panel data, focusing on the estimators we have studied in Section <a href="NE.html#DID">4.3</a>, especially the simple DID estimator, the fixed effects estimator, and the Sun and Abraham estimator in staggered designs.
A key result of importance is that DID estimates which only involve two-periods are not affected by the autocorrelation problem, while estimates which aggregate more than two periods of data are affected, and the more so as they aggregate more time periods.
We are first going to take an example to exemplify the importance of the problem.
We will then derive the closed form variance of the various estimators under simplified assumptions on the autocorrelation between error terms.
Finally, we will explain how to estimate sampling noise in panel data with autocorrelated error terms.</p>
<div id="an-example-1" class="section level3 hasAnchor" number="9.2.1">
<h3><span class="header-section-number">9.2.1</span> An example<a href="cluster.html#an-example-1" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Let us start with an example of how autocorrelated error terms alter the precision of panel data estimates.
For that, we are going to generate long time series of panel data and explore how the variability of treatment effect estimates changes with persistence in error terms at the individual level, both for the event-study estimates (which rely on <span class="math inline">\(2\times 2\)</span> comparisons) and for the TT estimate, which relies on aggregated treatment effects.
For simplicity, we are going to jave a design without staggered entry, but everything we are saying here applies to staggered entry as well.</p>
<p><strong>Check what happens with staggered entry</strong></p>
<p>I am going to use the following model:</p>
<p>We model outcomes dynamics as follows:</p>
<p><span class="math display">\[\begin{align*}
  Y_{i,t} &amp; = D_{i,t}Y^1_{i,t}+(1-D_{i,t})Y_{i,t}^0\\
  Y_{i,t}^1 &amp; = Y_{i,t}^0 + \bar\alpha \\
  Y_{i,t}^0 &amp; = \mu_i +  U_{i,t} \\
  U_{i,t} &amp; = \rho U_{i,t-1} +\epsilon_{i,t} \\
  D_{i,t} &amp; = \uns{D^*_{i,k}\geq0}\uns{t\geq k} \\ 
  D^*_{i,k} &amp; = \theta_i + \eta_{i,k}.
\end{align*}\]</span></p>
<p>Outcome dynamics are characterized by an individual fixed effect <span class="math inline">\(\mu_i\)</span> and an AR(1) process with autoregressive parameter <span class="math inline">\(\rho\in\left[0,1\right]\)</span>.
<span class="math inline">\(\epsilon_{i,t}\)</span> is i.i.d. and has finite variance <span class="math inline">\(\sigma^2\)</span> and is independent from all the other variables in the model.
<span class="math inline">\(U_{i,0}\)</span> has finite variance <span class="math inline">\(\sigma^2_{U_0}\)</span> and is independent from all the other variables in the model.
The program is only available at period <span class="math inline">\(k\)</span>.
Participation in the program (which we denote <span class="math inline">\(D_{i,t}\)</span>) depends on the utility from entering the program <span class="math inline">\(D^*_{i,k}\)</span> being positive.
<span class="math inline">\(\eta_{i,k}\)</span> is a random shock uncorrelated with any of the other variables in the model.
Selection bias occurs because <span class="math inline">\(\mu_i\)</span> and <span class="math inline">\(\theta_i\)</span> are correlated.</p>
<p>Let us now choose some parameter values (but the value of <span class="math inline">\(\rho\)</span>):</p>
<div class="sourceCode" id="cb372"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb372-1"><a href="cluster.html#cb372-1" aria-hidden="true" tabindex="-1"></a><span class="co"># basic parameter values</span></span>
<span id="cb372-2"><a href="cluster.html#cb372-2" aria-hidden="true" tabindex="-1"></a>param.basic <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.05</span>,<span class="fl">0.72</span>,<span class="fl">0.55</span>,<span class="fl">0.55</span>,<span class="fl">0.5</span>,<span class="fl">0.1</span>,<span class="dv">0</span>)</span>
<span id="cb372-3"><a href="cluster.html#cb372-3" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(param.basic) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;sigma&quot;</span>,<span class="st">&quot;sigmaU0&quot;</span>,<span class="st">&quot;sigmamu&quot;</span>,<span class="st">&quot;sigmatheta&quot;</span>,<span class="st">&quot;rhosigmamutheta&quot;</span>,<span class="st">&quot;sigmaeta&quot;</span>,<span class="st">&quot;baralpha&quot;</span>) </span></code></pre></div>
<p>Note that I have chosen the true effect of the treatment to be zero, which saves me computational difficulties because <span class="math inline">\(Y_{i,t}=Y^0_{i,t}\)</span>, and does not matter at all for now since we are trying to estimate sampling noise and not the treatment effect itself.
Let us now encode a function generating one sample for one choice of parameter values and seed and spitting out one estimate of the event study parameters and of the TT parameter based on Sun and Abraham estimator.
I am going also to estimate the <span class="math inline">\(2\times 2\)</span> DID estimator along with its heteroskedasticity robust standard errors, both as a within estimator and as a first-difference estimator, in order to check whether the standard error estimates are similar in all three approaches.</p>
<div class="sourceCode" id="cb373"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb373-1"><a href="cluster.html#cb373-1" aria-hidden="true" tabindex="-1"></a><span class="co"># function generating a sample of outcomes for K time periods with N sample size and spitting out DID estimates (both event study and TT, with both Sunab and )</span></span>
<span id="cb373-2"><a href="cluster.html#cb373-2" aria-hidden="true" tabindex="-1"></a><span class="co"># seed: seed setting the PRNG</span></span>
<span id="cb373-3"><a href="cluster.html#cb373-3" aria-hidden="true" tabindex="-1"></a><span class="co"># N: number of units in the panel</span></span>
<span id="cb373-4"><a href="cluster.html#cb373-4" aria-hidden="true" tabindex="-1"></a><span class="co"># K: number of periods in the panel</span></span>
<span id="cb373-5"><a href="cluster.html#cb373-5" aria-hidden="true" tabindex="-1"></a><span class="co"># k: treatment date</span></span>
<span id="cb373-6"><a href="cluster.html#cb373-6" aria-hidden="true" tabindex="-1"></a><span class="co"># param: basic parameters</span></span>
<span id="cb373-7"><a href="cluster.html#cb373-7" aria-hidden="true" tabindex="-1"></a><span class="co"># rho: value of rho</span></span>
<span id="cb373-8"><a href="cluster.html#cb373-8" aria-hidden="true" tabindex="-1"></a><span class="co"># cluster: whether we cluster or not our treatment effect estimates for temporal autocorrelation (&quot;None&quot;, vs &quot;Temporal&quot;)</span></span>
<span id="cb373-9"><a href="cluster.html#cb373-9" aria-hidden="true" tabindex="-1"></a>Outcome.Sample.DID.Long <span class="ot">&lt;-</span> <span class="cf">function</span>(seed,N,K,k,param,rho,<span class="at">cluster=</span><span class="st">&quot;None&quot;</span>){</span>
<span id="cb373-10"><a href="cluster.html#cb373-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># draw all i.i.d. error terms for all years</span></span>
<span id="cb373-11"><a href="cluster.html#cb373-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set.seed</span>(seed)</span>
<span id="cb373-12"><a href="cluster.html#cb373-12" aria-hidden="true" tabindex="-1"></a>  epsilon <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="at">n=</span>K<span class="sc">*</span>N,<span class="at">sd=</span><span class="fu">sqrt</span>(param[<span class="st">&quot;sigma&quot;</span>]))</span>
<span id="cb373-13"><a href="cluster.html#cb373-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># draw initial error term</span></span>
<span id="cb373-14"><a href="cluster.html#cb373-14" aria-hidden="true" tabindex="-1"></a>  U0 <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="at">n=</span>N,<span class="at">sd=</span><span class="fu">sqrt</span>(param[<span class="st">&quot;sigmaU0&quot;</span>]))</span>
<span id="cb373-15"><a href="cluster.html#cb373-15" aria-hidden="true" tabindex="-1"></a>  <span class="co"># draw fixed effects</span></span>
<span id="cb373-16"><a href="cluster.html#cb373-16" aria-hidden="true" tabindex="-1"></a>  sigma.mu.theta <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(param[<span class="st">&quot;sigmamu&quot;</span>],param[<span class="st">&quot;sigmamu&quot;</span>]<span class="sc">*</span>param[<span class="st">&quot;sigmatheta&quot;</span>]<span class="sc">*</span>param[<span class="st">&quot;rhosigmamutheta&quot;</span>],</span>
<span id="cb373-17"><a href="cluster.html#cb373-17" aria-hidden="true" tabindex="-1"></a>                                  param[<span class="st">&quot;sigmamu&quot;</span>]<span class="sc">*</span>param[<span class="st">&quot;sigmatheta&quot;</span>]<span class="sc">*</span>param[<span class="st">&quot;rhosigmamutheta&quot;</span>],param[<span class="st">&quot;sigmatheta&quot;</span>]</span>
<span id="cb373-18"><a href="cluster.html#cb373-18" aria-hidden="true" tabindex="-1"></a>                                  ),<span class="at">ncol=</span><span class="dv">2</span>,<span class="at">nrow=</span><span class="dv">2</span>,<span class="at">byrow =</span> T)</span>
<span id="cb373-19"><a href="cluster.html#cb373-19" aria-hidden="true" tabindex="-1"></a>  mu.theta <span class="ot">&lt;-</span> <span class="fu">rmvnorm</span>(<span class="at">n=</span>N,<span class="at">mean=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">0</span>),<span class="at">sigma=</span>sigma.mu.theta)</span>
<span id="cb373-20"><a href="cluster.html#cb373-20" aria-hidden="true" tabindex="-1"></a>  mu <span class="ot">&lt;-</span> mu.theta[,<span class="dv">1</span>]</span>
<span id="cb373-21"><a href="cluster.html#cb373-21" aria-hidden="true" tabindex="-1"></a>  theta <span class="ot">&lt;-</span> mu.theta[,<span class="dv">2</span>] </span>
<span id="cb373-22"><a href="cluster.html#cb373-22" aria-hidden="true" tabindex="-1"></a>  <span class="co"># building dataset (wide format)</span></span>
<span id="cb373-23"><a href="cluster.html#cb373-23" aria-hidden="true" tabindex="-1"></a>  data <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(<span class="fu">cbind</span>(mu,U0))</span>
<span id="cb373-24"><a href="cluster.html#cb373-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>K){</span>
<span id="cb373-25"><a href="cluster.html#cb373-25" aria-hidden="true" tabindex="-1"></a>    data[<span class="fu">paste</span>(<span class="st">&#39;U&#39;</span>,i,<span class="at">sep=</span><span class="st">&quot;&quot;</span>)] <span class="ot">&lt;-</span> rho<span class="sc">*</span>data[<span class="fu">paste</span>(<span class="st">&#39;U&#39;</span>,i<span class="dv">-1</span>,<span class="at">sep=</span><span class="st">&quot;&quot;</span>)]<span class="sc">+</span>epsilon[((i<span class="dv">-1</span>)<span class="sc">*</span>N<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>(i<span class="sc">*</span>N)]</span>
<span id="cb373-26"><a href="cluster.html#cb373-26" aria-hidden="true" tabindex="-1"></a>    data[<span class="fu">paste</span>(<span class="st">&#39;Y&#39;</span>,i,<span class="at">sep=</span><span class="st">&quot;&quot;</span>)] <span class="ot">&lt;-</span> mu <span class="sc">+</span> data[<span class="fu">paste</span>(<span class="st">&#39;U&#39;</span>,i,<span class="at">sep=</span><span class="st">&quot;&quot;</span>)]</span>
<span id="cb373-27"><a href="cluster.html#cb373-27" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb373-28"><a href="cluster.html#cb373-28" aria-hidden="true" tabindex="-1"></a>  <span class="co"># selection rule</span></span>
<span id="cb373-29"><a href="cluster.html#cb373-29" aria-hidden="true" tabindex="-1"></a>  <span class="co"># draw error term</span></span>
<span id="cb373-30"><a href="cluster.html#cb373-30" aria-hidden="true" tabindex="-1"></a>  data[<span class="st">&#39;eta&#39;</span>] <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="at">n=</span>N,<span class="at">sd=</span><span class="fu">sqrt</span>(param[<span class="st">&quot;sigmaeta&quot;</span>]))</span>
<span id="cb373-31"><a href="cluster.html#cb373-31" aria-hidden="true" tabindex="-1"></a>  data <span class="ot">&lt;-</span> data <span class="sc">%&gt;%</span></span>
<span id="cb373-32"><a href="cluster.html#cb373-32" aria-hidden="true" tabindex="-1"></a>            <span class="fu">mutate</span>(</span>
<span id="cb373-33"><a href="cluster.html#cb373-33" aria-hidden="true" tabindex="-1"></a>              <span class="co"># generating utility from participation</span></span>
<span id="cb373-34"><a href="cluster.html#cb373-34" aria-hidden="true" tabindex="-1"></a>              <span class="at">Ds =</span> theta <span class="sc">+</span> eta,</span>
<span id="cb373-35"><a href="cluster.html#cb373-35" aria-hidden="true" tabindex="-1"></a>              <span class="co"># generating treatment participation</span></span>
<span id="cb373-36"><a href="cluster.html#cb373-36" aria-hidden="true" tabindex="-1"></a>              <span class="at">D =</span> <span class="fu">case_when</span>(</span>
<span id="cb373-37"><a href="cluster.html#cb373-37" aria-hidden="true" tabindex="-1"></a>                    Ds <span class="sc">&gt;</span><span class="dv">0</span> <span class="sc">~</span> <span class="dv">1</span>,</span>
<span id="cb373-38"><a href="cluster.html#cb373-38" aria-hidden="true" tabindex="-1"></a>                    <span class="cn">TRUE</span> <span class="sc">~</span> <span class="dv">0</span></span>
<span id="cb373-39"><a href="cluster.html#cb373-39" aria-hidden="true" tabindex="-1"></a>                  ),</span>
<span id="cb373-40"><a href="cluster.html#cb373-40" aria-hidden="true" tabindex="-1"></a>              <span class="co"># generating treatment identifier for Sun&amp;Abraham estimator with treatment group being at period k</span></span>
<span id="cb373-41"><a href="cluster.html#cb373-41" aria-hidden="true" tabindex="-1"></a>              <span class="at">Dsunab =</span> <span class="fu">case_when</span>(</span>
<span id="cb373-42"><a href="cluster.html#cb373-42" aria-hidden="true" tabindex="-1"></a>                        D <span class="sc">==</span> <span class="dv">1</span> <span class="sc">~</span> k,</span>
<span id="cb373-43"><a href="cluster.html#cb373-43" aria-hidden="true" tabindex="-1"></a>                        D <span class="sc">==</span> <span class="dv">0</span> <span class="sc">~</span> <span class="dv">99</span>,</span>
<span id="cb373-44"><a href="cluster.html#cb373-44" aria-hidden="true" tabindex="-1"></a>                        <span class="cn">TRUE</span> <span class="sc">~</span> <span class="sc">-</span><span class="dv">99</span></span>
<span id="cb373-45"><a href="cluster.html#cb373-45" aria-hidden="true" tabindex="-1"></a>                    )</span>
<span id="cb373-46"><a href="cluster.html#cb373-46" aria-hidden="true" tabindex="-1"></a>            ) </span>
<span id="cb373-47"><a href="cluster.html#cb373-47" aria-hidden="true" tabindex="-1"></a>  <span class="co"># generate long dataset</span></span>
<span id="cb373-48"><a href="cluster.html#cb373-48" aria-hidden="true" tabindex="-1"></a>  data <span class="ot">&lt;-</span> data <span class="sc">%&gt;%</span></span>
<span id="cb373-49"><a href="cluster.html#cb373-49" aria-hidden="true" tabindex="-1"></a>            <span class="fu">select</span>(<span class="fu">contains</span>(<span class="st">&quot;Y&quot;</span>),<span class="fu">contains</span>(<span class="st">&quot;D&quot;</span>)) <span class="sc">%&gt;%</span></span>
<span id="cb373-50"><a href="cluster.html#cb373-50" aria-hidden="true" tabindex="-1"></a>            <span class="fu">mutate</span>(<span class="at">id =</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(data)) <span class="sc">%&gt;%</span></span>
<span id="cb373-51"><a href="cluster.html#cb373-51" aria-hidden="true" tabindex="-1"></a>            <span class="fu">pivot_longer</span>(<span class="fu">starts_with</span>(<span class="st">&quot;Y&quot;</span>),<span class="at">names_to =</span> <span class="st">&quot;Period&quot;</span>,<span class="at">names_prefix =</span> <span class="st">&quot;Y&quot;</span>,<span class="at">values_to =</span> <span class="st">&quot;Y&quot;</span>) <span class="sc">%&gt;%</span></span>
<span id="cb373-52"><a href="cluster.html#cb373-52" aria-hidden="true" tabindex="-1"></a>            <span class="fu">mutate</span>(</span>
<span id="cb373-53"><a href="cluster.html#cb373-53" aria-hidden="true" tabindex="-1"></a>              <span class="at">Period =</span> <span class="fu">as.numeric</span>(Period),</span>
<span id="cb373-54"><a href="cluster.html#cb373-54" aria-hidden="true" tabindex="-1"></a>              <span class="at">TimeToTreatment =</span> <span class="fu">case_when</span>(</span>
<span id="cb373-55"><a href="cluster.html#cb373-55" aria-hidden="true" tabindex="-1"></a>                                  D <span class="sc">==</span> <span class="st">&quot;1&quot;</span> <span class="sc">~</span> Period<span class="sc">-</span>k,</span>
<span id="cb373-56"><a href="cluster.html#cb373-56" aria-hidden="true" tabindex="-1"></a>                                  <span class="cn">TRUE</span> <span class="sc">~</span> <span class="sc">-</span><span class="dv">99</span></span>
<span id="cb373-57"><a href="cluster.html#cb373-57" aria-hidden="true" tabindex="-1"></a>              )</span>
<span id="cb373-58"><a href="cluster.html#cb373-58" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb373-59"><a href="cluster.html#cb373-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb373-60"><a href="cluster.html#cb373-60" aria-hidden="true" tabindex="-1"></a>  <span class="co"># estimating DID model with Sun and Abraham estimator</span></span>
<span id="cb373-61"><a href="cluster.html#cb373-61" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (cluster<span class="sc">==</span><span class="st">&quot;None&quot;</span>){</span>
<span id="cb373-62"><a href="cluster.html#cb373-62" aria-hidden="true" tabindex="-1"></a>    reg.DID.SA <span class="ot">&lt;-</span> <span class="fu">feols</span>(Y <span class="sc">~</span> <span class="fu">sunab</span>(Dsunab,Period) <span class="sc">|</span> id <span class="sc">+</span> Period,<span class="at">vcov=</span><span class="st">&#39;HC1&#39;</span>,<span class="at">data=</span>data)</span>
<span id="cb373-63"><a href="cluster.html#cb373-63" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb373-64"><a href="cluster.html#cb373-64" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (cluster<span class="sc">==</span><span class="st">&quot;Temporal&quot;</span>){</span>
<span id="cb373-65"><a href="cluster.html#cb373-65" aria-hidden="true" tabindex="-1"></a>    reg.DID.SA <span class="ot">&lt;-</span> <span class="fu">feols</span>(Y <span class="sc">~</span> <span class="fu">sunab</span>(Dsunab,Period) <span class="sc">|</span> id <span class="sc">+</span> Period,<span class="at">vcov=</span>cluster<span class="sc">~</span>id,<span class="at">data=</span>data)</span>
<span id="cb373-66"><a href="cluster.html#cb373-66" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb373-67"><a href="cluster.html#cb373-67" aria-hidden="true" tabindex="-1"></a>  resultsDID.SA <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">Coef=</span>reg.DID.SA<span class="sc">$</span>coefficients,<span class="at">Se=</span>reg.DID.SA<span class="sc">$</span>se,<span class="at">Name=</span><span class="fu">names</span>(reg.DID.SA<span class="sc">$</span>coefficients)) <span class="sc">%&gt;%</span></span>
<span id="cb373-68"><a href="cluster.html#cb373-68" aria-hidden="true" tabindex="-1"></a>                <span class="fu">mutate</span>(</span>
<span id="cb373-69"><a href="cluster.html#cb373-69" aria-hidden="true" tabindex="-1"></a>                  <span class="co">#TimeToTreatment = as.numeric(str_split_fixed(Name,&#39;::&#39;,n=2)[,2])</span></span>
<span id="cb373-70"><a href="cluster.html#cb373-70" aria-hidden="true" tabindex="-1"></a>                  <span class="at">TimeToTreatment =</span> <span class="fu">as.numeric</span>(<span class="fu">str_split_fixed</span>(Name,<span class="st">&#39;:&#39;</span>,<span class="at">n=</span><span class="dv">4</span>)[,<span class="dv">3</span>])</span>
<span id="cb373-71"><a href="cluster.html#cb373-71" aria-hidden="true" tabindex="-1"></a>                ) <span class="sc">%&gt;%</span></span>
<span id="cb373-72"><a href="cluster.html#cb373-72" aria-hidden="true" tabindex="-1"></a>                <span class="fu">select</span>(<span class="sc">-</span>Name)</span>
<span id="cb373-73"><a href="cluster.html#cb373-73" aria-hidden="true" tabindex="-1"></a>  <span class="co"># adding reference period</span></span>
<span id="cb373-74"><a href="cluster.html#cb373-74" aria-hidden="true" tabindex="-1"></a>  resultsDID.SA <span class="ot">&lt;-</span> <span class="fu">rbind</span>(resultsDID.SA,<span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="sc">-</span><span class="dv">1</span>))</span>
<span id="cb373-75"><a href="cluster.html#cb373-75" aria-hidden="true" tabindex="-1"></a>  <span class="co"># TT</span></span>
<span id="cb373-76"><a href="cluster.html#cb373-76" aria-hidden="true" tabindex="-1"></a>  ATT.SA <span class="ot">&lt;-</span> <span class="fu">aggregate</span>(reg.DID.SA, <span class="fu">c</span>(<span class="st">&quot;ATT&quot;</span> <span class="ot">=</span> <span class="st">&quot;Period::[^-]&quot;</span>))   </span>
<span id="cb373-77"><a href="cluster.html#cb373-77" aria-hidden="true" tabindex="-1"></a>  ATT.SA <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">Coef=</span>ATT.SA[[<span class="dv">1</span>]],<span class="at">Se=</span>ATT.SA[[<span class="dv">2</span>]],<span class="at">TimeToTreatment=</span><span class="dv">99</span>)</span>
<span id="cb373-78"><a href="cluster.html#cb373-78" aria-hidden="true" tabindex="-1"></a>  <span class="co"># joining results SA</span></span>
<span id="cb373-79"><a href="cluster.html#cb373-79" aria-hidden="true" tabindex="-1"></a>  resultsDID.SA <span class="ot">&lt;-</span> <span class="fu">rbind</span>(resultsDID.SA,ATT.SA)</span>
<span id="cb373-80"><a href="cluster.html#cb373-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb373-81"><a href="cluster.html#cb373-81" aria-hidden="true" tabindex="-1"></a>  <span class="co"># estimating DID model with 2x2 FD estimators</span></span>
<span id="cb373-82"><a href="cluster.html#cb373-82" aria-hidden="true" tabindex="-1"></a>  tau.FD <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">19</span><span class="sc">:-</span><span class="dv">2</span>,<span class="dv">0</span><span class="sc">:</span><span class="dv">20</span>)</span>
<span id="cb373-83"><a href="cluster.html#cb373-83" aria-hidden="true" tabindex="-1"></a>  resultsDID.FD <span class="ot">&lt;-</span> <span class="fu">map_dfr</span>(tau.FD,StaggeredDID22,<span class="at">y=</span><span class="st">&#39;Y&#39;</span>,<span class="at">D=</span><span class="st">&#39;Dsunab&#39;</span>,<span class="at">d=</span><span class="dv">20</span>,<span class="at">dprime=</span><span class="dv">99</span>,<span class="at">tauprime=</span><span class="dv">1</span>,<span class="at">t=</span><span class="st">&quot;Period&quot;</span>,<span class="at">i=</span><span class="st">&quot;id&quot;</span>,<span class="at">data=</span>data) <span class="sc">%&gt;%</span></span>
<span id="cb373-84"><a href="cluster.html#cb373-84" aria-hidden="true" tabindex="-1"></a>                    <span class="fu">select</span>(tau,FDEst,FDSe) <span class="sc">%&gt;%</span></span>
<span id="cb373-85"><a href="cluster.html#cb373-85" aria-hidden="true" tabindex="-1"></a>                    <span class="fu">rename</span>(<span class="at">TimeToTreatment =</span> tau,</span>
<span id="cb373-86"><a href="cluster.html#cb373-86" aria-hidden="true" tabindex="-1"></a>                           <span class="at">Coef=</span>FDEst,</span>
<span id="cb373-87"><a href="cluster.html#cb373-87" aria-hidden="true" tabindex="-1"></a>                           <span class="at">Se=</span>FDSe) <span class="sc">%&gt;%</span></span>
<span id="cb373-88"><a href="cluster.html#cb373-88" aria-hidden="true" tabindex="-1"></a>                    <span class="fu">relocate</span>(TimeToTreatment,<span class="at">.after=</span>Se)</span>
<span id="cb373-89"><a href="cluster.html#cb373-89" aria-hidden="true" tabindex="-1"></a>  <span class="co"># adding reference period</span></span>
<span id="cb373-90"><a href="cluster.html#cb373-90" aria-hidden="true" tabindex="-1"></a>  resultsDID.FD <span class="ot">&lt;-</span> <span class="fu">rbind</span>(resultsDID.FD,<span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="sc">-</span><span class="dv">1</span>))</span>
<span id="cb373-91"><a href="cluster.html#cb373-91" aria-hidden="true" tabindex="-1"></a>  <span class="co"># adding aggregate ATT</span></span>
<span id="cb373-92"><a href="cluster.html#cb373-92" aria-hidden="true" tabindex="-1"></a>  ATT.FD <span class="ot">&lt;-</span> resultsDID.FD <span class="sc">%&gt;%</span></span>
<span id="cb373-93"><a href="cluster.html#cb373-93" aria-hidden="true" tabindex="-1"></a>            <span class="fu">filter</span>(TimeToTreatment<span class="sc">&gt;=</span><span class="dv">0</span>) <span class="sc">%&gt;%</span></span>
<span id="cb373-94"><a href="cluster.html#cb373-94" aria-hidden="true" tabindex="-1"></a>            <span class="fu">summarize</span>(</span>
<span id="cb373-95"><a href="cluster.html#cb373-95" aria-hidden="true" tabindex="-1"></a>              <span class="at">ATT =</span> <span class="fu">mean</span>(Coef),</span>
<span id="cb373-96"><a href="cluster.html#cb373-96" aria-hidden="true" tabindex="-1"></a>              <span class="co"># this incorrectly ignores correlations between the FD estimates</span></span>
<span id="cb373-97"><a href="cluster.html#cb373-97" aria-hidden="true" tabindex="-1"></a>              <span class="at">SeATT =</span> <span class="fu">sqrt</span>(<span class="fu">sum</span>(Se<span class="sc">^</span><span class="dv">2</span>))<span class="sc">/</span>(K<span class="sc">-</span>k<span class="sc">+</span><span class="dv">1</span>)</span>
<span id="cb373-98"><a href="cluster.html#cb373-98" aria-hidden="true" tabindex="-1"></a>            ) <span class="sc">%&gt;%</span></span>
<span id="cb373-99"><a href="cluster.html#cb373-99" aria-hidden="true" tabindex="-1"></a>            <span class="fu">rename</span>(</span>
<span id="cb373-100"><a href="cluster.html#cb373-100" aria-hidden="true" tabindex="-1"></a>              <span class="at">Coef =</span> ATT,</span>
<span id="cb373-101"><a href="cluster.html#cb373-101" aria-hidden="true" tabindex="-1"></a>              <span class="at">Se =</span> SeATT</span>
<span id="cb373-102"><a href="cluster.html#cb373-102" aria-hidden="true" tabindex="-1"></a>            ) <span class="sc">%&gt;%</span></span>
<span id="cb373-103"><a href="cluster.html#cb373-103" aria-hidden="true" tabindex="-1"></a>            <span class="fu">mutate</span>(</span>
<span id="cb373-104"><a href="cluster.html#cb373-104" aria-hidden="true" tabindex="-1"></a>              <span class="at">TimeToTreatment=</span><span class="dv">99</span></span>
<span id="cb373-105"><a href="cluster.html#cb373-105" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb373-106"><a href="cluster.html#cb373-106" aria-hidden="true" tabindex="-1"></a>  <span class="co"># joining results FD</span></span>
<span id="cb373-107"><a href="cluster.html#cb373-107" aria-hidden="true" tabindex="-1"></a>  resultsDID.FD <span class="ot">&lt;-</span> <span class="fu">rbind</span>(resultsDID.FD,ATT.FD)</span>
<span id="cb373-108"><a href="cluster.html#cb373-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb373-109"><a href="cluster.html#cb373-109" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Estimating with Stacked DID FD</span></span>
<span id="cb373-110"><a href="cluster.html#cb373-110" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (cluster<span class="sc">==</span><span class="st">&quot;None&quot;</span>){</span>
<span id="cb373-111"><a href="cluster.html#cb373-111" aria-hidden="true" tabindex="-1"></a>    results.Stacked.DID.FD.Full <span class="ot">&lt;-</span> <span class="fu">StackedDIDFD</span>(<span class="at">y=</span><span class="st">&#39;Y&#39;</span>,<span class="at">D=</span><span class="st">&#39;Dsunab&#39;</span>,<span class="at">dprime=</span><span class="dv">99</span>,<span class="at">tauprime=</span><span class="dv">1</span>,<span class="at">t=</span><span class="st">&quot;Period&quot;</span>,<span class="at">i=</span><span class="st">&quot;id&quot;</span>,<span class="at">data=</span>data) </span>
<span id="cb373-112"><a href="cluster.html#cb373-112" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb373-113"><a href="cluster.html#cb373-113" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (cluster<span class="sc">==</span><span class="st">&quot;Temporal&quot;</span>){</span>
<span id="cb373-114"><a href="cluster.html#cb373-114" aria-hidden="true" tabindex="-1"></a>    results.Stacked.DID.FD.Full <span class="ot">&lt;-</span> <span class="fu">StackedDIDFD</span>(<span class="at">y=</span><span class="st">&#39;Y&#39;</span>,<span class="at">D=</span><span class="st">&#39;Dsunab&#39;</span>,<span class="at">dprime=</span><span class="dv">99</span>,<span class="at">tauprime=</span><span class="dv">1</span>,<span class="at">t=</span><span class="st">&quot;Period&quot;</span>,<span class="at">i=</span><span class="st">&quot;id&quot;</span>,<span class="at">Leung=</span><span class="st">&#39;Temporal&#39;</span>,<span class="at">data=</span>data) </span>
<span id="cb373-115"><a href="cluster.html#cb373-115" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb373-116"><a href="cluster.html#cb373-116" aria-hidden="true" tabindex="-1"></a>  results.Stacked.DID.FD <span class="ot">&lt;-</span> results.Stacked.DID.FD.Full[[<span class="dv">1</span>]] <span class="sc">%&gt;%</span></span>
<span id="cb373-117"><a href="cluster.html#cb373-117" aria-hidden="true" tabindex="-1"></a>                              <span class="fu">rename</span>(<span class="at">Group=</span>d,</span>
<span id="cb373-118"><a href="cluster.html#cb373-118" aria-hidden="true" tabindex="-1"></a>                                     <span class="at">TimeToTreatment =</span> tau,</span>
<span id="cb373-119"><a href="cluster.html#cb373-119" aria-hidden="true" tabindex="-1"></a>                                     <span class="at">Coef=</span>TE,</span>
<span id="cb373-120"><a href="cluster.html#cb373-120" aria-hidden="true" tabindex="-1"></a>                                     <span class="at">Se=</span>SeTE) <span class="sc">%&gt;%</span></span>
<span id="cb373-121"><a href="cluster.html#cb373-121" aria-hidden="true" tabindex="-1"></a>                              <span class="fu">select</span>(<span class="sc">-</span>Ddtau)</span>
<span id="cb373-122"><a href="cluster.html#cb373-122" aria-hidden="true" tabindex="-1"></a>  <span class="co"># adding the ATT</span></span>
<span id="cb373-123"><a href="cluster.html#cb373-123" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (cluster<span class="sc">==</span><span class="st">&quot;None&quot;</span>){</span>
<span id="cb373-124"><a href="cluster.html#cb373-124" aria-hidden="true" tabindex="-1"></a>    ATT.Stacked.DID.FD <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">Group=</span><span class="st">&quot;All&quot;</span>,<span class="at">TimeToTreatment=</span><span class="dv">99</span>,<span class="at">Coef=</span>results.Stacked.DID.FD.Full[[<span class="st">&quot;ATT&quot;</span>]],<span class="at">Se=</span>results.Stacked.DID.FD.Full[[<span class="st">&quot;ATTSe&quot;</span>]]) <span class="sc">%&gt;%</span></span>
<span id="cb373-125"><a href="cluster.html#cb373-125" aria-hidden="true" tabindex="-1"></a>                          <span class="fu">rename</span>(<span class="at">Se=</span>weights)</span>
<span id="cb373-126"><a href="cluster.html#cb373-126" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb373-127"><a href="cluster.html#cb373-127" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (cluster<span class="sc">==</span><span class="st">&quot;Temporal&quot;</span>){</span>
<span id="cb373-128"><a href="cluster.html#cb373-128" aria-hidden="true" tabindex="-1"></a>   ATT.Stacked.DID.FD <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">Group=</span><span class="st">&quot;All&quot;</span>,<span class="at">TimeToTreatment=</span><span class="dv">99</span>,<span class="at">Coef=</span>results.Stacked.DID.FD.Full[[<span class="st">&quot;ATT&quot;</span>]],<span class="at">Se=</span>results.Stacked.DID.FD.Full[[<span class="st">&quot;ATTSeLeung&quot;</span>]]) <span class="sc">%&gt;%</span></span>
<span id="cb373-129"><a href="cluster.html#cb373-129" aria-hidden="true" tabindex="-1"></a>                          <span class="fu">rename</span>(<span class="at">Se=</span>weights)</span>
<span id="cb373-130"><a href="cluster.html#cb373-130" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb373-131"><a href="cluster.html#cb373-131" aria-hidden="true" tabindex="-1"></a>  results.Stacked.DID.FD <span class="ot">&lt;-</span> <span class="fu">rbind</span>(results.Stacked.DID.FD,ATT.Stacked.DID.FD)</span>
<span id="cb373-132"><a href="cluster.html#cb373-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb373-133"><a href="cluster.html#cb373-133" aria-hidden="true" tabindex="-1"></a>  <span class="co"># joining all results</span></span>
<span id="cb373-134"><a href="cluster.html#cb373-134" aria-hidden="true" tabindex="-1"></a>  resultsDID.SA <span class="ot">&lt;-</span> resultsDID.SA <span class="sc">%&gt;%</span></span>
<span id="cb373-135"><a href="cluster.html#cb373-135" aria-hidden="true" tabindex="-1"></a>                    <span class="fu">mutate</span>(<span class="at">Method =</span> <span class="st">&quot;SA&quot;</span>)</span>
<span id="cb373-136"><a href="cluster.html#cb373-136" aria-hidden="true" tabindex="-1"></a>  resultsDID.FD <span class="ot">&lt;-</span> resultsDID.FD <span class="sc">%&gt;%</span></span>
<span id="cb373-137"><a href="cluster.html#cb373-137" aria-hidden="true" tabindex="-1"></a>                    <span class="fu">mutate</span>(<span class="at">Method =</span> <span class="st">&quot;FD&quot;</span>)</span>
<span id="cb373-138"><a href="cluster.html#cb373-138" aria-hidden="true" tabindex="-1"></a>  results.Stacked.DID.FD <span class="ot">&lt;-</span> results.Stacked.DID.FD <span class="sc">%&gt;%</span></span>
<span id="cb373-139"><a href="cluster.html#cb373-139" aria-hidden="true" tabindex="-1"></a>                    <span class="fu">mutate</span>(<span class="at">Method =</span> <span class="st">&quot;StackedFD&quot;</span>) <span class="sc">%&gt;%</span> </span>
<span id="cb373-140"><a href="cluster.html#cb373-140" aria-hidden="true" tabindex="-1"></a>                    <span class="fu">select</span>(<span class="sc">-</span>Group)</span>
<span id="cb373-141"><a href="cluster.html#cb373-141" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb373-142"><a href="cluster.html#cb373-142" aria-hidden="true" tabindex="-1"></a>  resultsDID <span class="ot">&lt;-</span> <span class="fu">rbind</span>(resultsDID.SA,resultsDID.FD,results.Stacked.DID.FD)</span>
<span id="cb373-143"><a href="cluster.html#cb373-143" aria-hidden="true" tabindex="-1"></a>  <span class="co"># return results</span></span>
<span id="cb373-144"><a href="cluster.html#cb373-144" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(resultsDID)</span>
<span id="cb373-145"><a href="cluster.html#cb373-145" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb373-146"><a href="cluster.html#cb373-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb373-147"><a href="cluster.html#cb373-147" aria-hidden="true" tabindex="-1"></a><span class="co"># test</span></span>
<span id="cb373-148"><a href="cluster.html#cb373-148" aria-hidden="true" tabindex="-1"></a><span class="co"># periods of estimation</span></span>
<span id="cb373-149"><a href="cluster.html#cb373-149" aria-hidden="true" tabindex="-1"></a>tau.test <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">19</span><span class="sc">:-</span><span class="dv">2</span>,<span class="dv">0</span><span class="sc">:</span><span class="dv">20</span>)</span>
<span id="cb373-150"><a href="cluster.html#cb373-150" aria-hidden="true" tabindex="-1"></a><span class="co"># test &lt;- StaggeredDID22(tau=-19,y=&#39;Y&#39;,D=&#39;Dsunab&#39;,d=20,dprime=99,tauprime=1,t=&quot;Period&quot;,i=&quot;id&quot;,data=data) </span></span>
<span id="cb373-151"><a href="cluster.html#cb373-151" aria-hidden="true" tabindex="-1"></a><span class="co"># test &lt;- map_dfr(tau.test,StaggeredDID22,y=&#39;Y&#39;,D=&#39;Dsunab&#39;,d=20,dprime=99,tauprime=1,t=&quot;Period&quot;,i=&quot;id&quot;,data=data) </span></span>
<span id="cb373-152"><a href="cluster.html#cb373-152" aria-hidden="true" tabindex="-1"></a>testdata <span class="ot">&lt;-</span> <span class="fu">Outcome.Sample.DID.Long</span>(<span class="at">seed=</span><span class="dv">1</span>,<span class="at">N=</span><span class="dv">1000</span>,<span class="at">K=</span><span class="dv">40</span>,<span class="at">k=</span><span class="dv">20</span>,<span class="at">param=</span>param.basic,<span class="at">rho=</span><span class="dv">0</span>)</span>
<span id="cb373-153"><a href="cluster.html#cb373-153" aria-hidden="true" tabindex="-1"></a>testdataTemporal <span class="ot">&lt;-</span> <span class="fu">Outcome.Sample.DID.Long</span>(<span class="at">seed=</span><span class="dv">1</span>,<span class="at">N=</span><span class="dv">1000</span>,<span class="at">K=</span><span class="dv">40</span>,<span class="at">k=</span><span class="dv">20</span>,<span class="at">param=</span>param.basic,<span class="at">rho=</span><span class="dv">0</span>,<span class="at">cluster=</span><span class="st">&#39;Temporal&#39;</span>)</span></code></pre></div>
<p>Let us now parallelize this function and apply it for several values of <span class="math inline">\(\rho\)</span>.</p>
<div class="sourceCode" id="cb374"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb374-1"><a href="cluster.html#cb374-1" aria-hidden="true" tabindex="-1"></a><span class="co"># programming to run in parallel</span></span>
<span id="cb374-2"><a href="cluster.html#cb374-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Nsim: number of simulations</span></span>
<span id="cb374-3"><a href="cluster.html#cb374-3" aria-hidden="true" tabindex="-1"></a><span class="co"># N: number of units in the panel</span></span>
<span id="cb374-4"><a href="cluster.html#cb374-4" aria-hidden="true" tabindex="-1"></a><span class="co"># K: number of periods in the panel</span></span>
<span id="cb374-5"><a href="cluster.html#cb374-5" aria-hidden="true" tabindex="-1"></a><span class="co"># k: treatment date</span></span>
<span id="cb374-6"><a href="cluster.html#cb374-6" aria-hidden="true" tabindex="-1"></a><span class="co"># param: basic parameters</span></span>
<span id="cb374-7"><a href="cluster.html#cb374-7" aria-hidden="true" tabindex="-1"></a><span class="co"># rho: value of rho</span></span>
<span id="cb374-8"><a href="cluster.html#cb374-8" aria-hidden="true" tabindex="-1"></a><span class="co"># cluster: whether we cluster or not our treatment effect estimates for temporal autocorrelation (&quot;None&quot;, vs &quot;Temporal&quot;)</span></span>
<span id="cb374-9"><a href="cluster.html#cb374-9" aria-hidden="true" tabindex="-1"></a>sf.Cluster.MonteCarlo.DID <span class="ot">&lt;-</span> <span class="cf">function</span>(Nsim,N,K,k,param,rho,<span class="at">cluster=</span><span class="st">&#39;None&#39;</span>,<span class="at">ncpus=</span><span class="dv">8</span>){</span>
<span id="cb374-10"><a href="cluster.html#cb374-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sfInit</span>(<span class="at">parallel=</span><span class="cn">TRUE</span>,<span class="at">cpus=</span>ncpus)</span>
<span id="cb374-11"><a href="cluster.html#cb374-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sfLibrary</span>(tidyverse)</span>
<span id="cb374-12"><a href="cluster.html#cb374-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sfLibrary</span>(fixest)</span>
<span id="cb374-13"><a href="cluster.html#cb374-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sfLibrary</span>(mvtnorm)</span>
<span id="cb374-14"><a href="cluster.html#cb374-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sfLibrary</span>(recipes)</span>
<span id="cb374-15"><a href="cluster.html#cb374-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sfLibrary</span>(Matrix)</span>
<span id="cb374-16"><a href="cluster.html#cb374-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sfExport</span>(<span class="st">&#39;StaggeredDID22&#39;</span>)</span>
<span id="cb374-17"><a href="cluster.html#cb374-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sfExport</span>(<span class="st">&#39;StackedDIDFD&#39;</span>)</span>
<span id="cb374-18"><a href="cluster.html#cb374-18" aria-hidden="true" tabindex="-1"></a>  sim <span class="ot">&lt;-</span> <span class="fu">sfLapply</span>(<span class="dv">1</span><span class="sc">:</span>Nsim,Outcome.Sample.DID.Long,<span class="at">N=</span>N,<span class="at">K=</span>K,<span class="at">k=</span>k,<span class="at">param=</span>param,<span class="at">rho=</span>rho,<span class="at">cluster=</span>cluster) </span>
<span id="cb374-19"><a href="cluster.html#cb374-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sfStop</span>()</span>
<span id="cb374-20"><a href="cluster.html#cb374-20" aria-hidden="true" tabindex="-1"></a>  <span class="co"># generate mean and standard error</span></span>
<span id="cb374-21"><a href="cluster.html#cb374-21" aria-hidden="true" tabindex="-1"></a>  sim <span class="ot">&lt;-</span> sim <span class="sc">%&gt;%</span> </span>
<span id="cb374-22"><a href="cluster.html#cb374-22" aria-hidden="true" tabindex="-1"></a>          <span class="fu">bind_rows</span>(.) <span class="sc">%&gt;%</span></span>
<span id="cb374-23"><a href="cluster.html#cb374-23" aria-hidden="true" tabindex="-1"></a>          <span class="fu">group_by</span>(TimeToTreatment,Method) <span class="sc">%&gt;%</span></span>
<span id="cb374-24"><a href="cluster.html#cb374-24" aria-hidden="true" tabindex="-1"></a>          <span class="fu">summarize</span>(</span>
<span id="cb374-25"><a href="cluster.html#cb374-25" aria-hidden="true" tabindex="-1"></a>            <span class="at">TE =</span> <span class="fu">mean</span>(Coef),</span>
<span id="cb374-26"><a href="cluster.html#cb374-26" aria-hidden="true" tabindex="-1"></a>            <span class="at">SdTE =</span> <span class="fu">sd</span>(Coef),</span>
<span id="cb374-27"><a href="cluster.html#cb374-27" aria-hidden="true" tabindex="-1"></a>            <span class="at">MeanSeTE =</span> <span class="fu">mean</span>(Se)</span>
<span id="cb374-28"><a href="cluster.html#cb374-28" aria-hidden="true" tabindex="-1"></a>          ) <span class="sc">%&gt;%</span></span>
<span id="cb374-29"><a href="cluster.html#cb374-29" aria-hidden="true" tabindex="-1"></a>          <span class="fu">ungroup</span>(.) <span class="sc">%&gt;%</span></span>
<span id="cb374-30"><a href="cluster.html#cb374-30" aria-hidden="true" tabindex="-1"></a>          <span class="fu">mutate</span>(</span>
<span id="cb374-31"><a href="cluster.html#cb374-31" aria-hidden="true" tabindex="-1"></a>            <span class="at">Rho =</span> rho</span>
<span id="cb374-32"><a href="cluster.html#cb374-32" aria-hidden="true" tabindex="-1"></a>          )</span>
<span id="cb374-33"><a href="cluster.html#cb374-33" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(sim)</span>
<span id="cb374-34"><a href="cluster.html#cb374-34" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb374-35"><a href="cluster.html#cb374-35" aria-hidden="true" tabindex="-1"></a><span class="co"># testing</span></span>
<span id="cb374-36"><a href="cluster.html#cb374-36" aria-hidden="true" tabindex="-1"></a>Nsim <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="cb374-37"><a href="cluster.html#cb374-37" aria-hidden="true" tabindex="-1"></a><span class="co">#sf.test.Cluster.MonteCarlo.DID &lt;- sf.Cluster.MonteCarlo.DID(Nsim=Nsim,N=1000,K=40,k=20,param=param.basic,rho=0)</span></span>
<span id="cb374-38"><a href="cluster.html#cb374-38" aria-hidden="true" tabindex="-1"></a><span class="co">#sf.test.Cluster.MonteCarlo.DID.temporal &lt;- sf.Cluster.MonteCarlo.DID(Nsim=Nsim,N=1000,K=40,k=20,param=param.basic,rho=0,cluster=&#39;Temporal&#39;)</span></span>
<span id="cb374-39"><a href="cluster.html#cb374-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb374-40"><a href="cluster.html#cb374-40" aria-hidden="true" tabindex="-1"></a><span class="co"># function to compute variance of DID over a grid of rho</span></span>
<span id="cb374-41"><a href="cluster.html#cb374-41" aria-hidden="true" tabindex="-1"></a><span class="co"># grid.rho: values of rho</span></span>
<span id="cb374-42"><a href="cluster.html#cb374-42" aria-hidden="true" tabindex="-1"></a><span class="co"># Nsim: number of simulations</span></span>
<span id="cb374-43"><a href="cluster.html#cb374-43" aria-hidden="true" tabindex="-1"></a><span class="co"># N: number of units in the panel</span></span>
<span id="cb374-44"><a href="cluster.html#cb374-44" aria-hidden="true" tabindex="-1"></a><span class="co"># K: number of periods in the panel</span></span>
<span id="cb374-45"><a href="cluster.html#cb374-45" aria-hidden="true" tabindex="-1"></a><span class="co"># k: treatment date</span></span>
<span id="cb374-46"><a href="cluster.html#cb374-46" aria-hidden="true" tabindex="-1"></a><span class="co"># param: basic parameters</span></span>
<span id="cb374-47"><a href="cluster.html#cb374-47" aria-hidden="true" tabindex="-1"></a><span class="co"># cluster: whether we cluster or not our treatment effect estimates for temporal autocorrelation (&quot;None&quot;, vs &quot;Temporal&quot;)</span></span>
<span id="cb374-48"><a href="cluster.html#cb374-48" aria-hidden="true" tabindex="-1"></a>sf.Cluster.MonteCarlo.DID.Grid <span class="ot">&lt;-</span> <span class="cf">function</span>(grid.rho,Nsim,N,K,k,param,<span class="at">cluster=</span><span class="st">&#39;None&#39;</span>,<span class="at">ncpus=</span><span class="dv">8</span>){</span>
<span id="cb374-49"><a href="cluster.html#cb374-49" aria-hidden="true" tabindex="-1"></a>  sf.test.Cluster.MonteCarlo.DID.grid <span class="ot">&lt;-</span> <span class="fu">lapply</span>(grid.rho,sf.Cluster.MonteCarlo.DID,<span class="at">Nsim=</span>Nsim,<span class="at">N=</span>N,<span class="at">K=</span>K,<span class="at">k=</span>k,<span class="at">param=</span>param,<span class="at">ncpus=</span>ncpus,<span class="at">cluster=</span>cluster) <span class="sc">%&gt;%</span></span>
<span id="cb374-50"><a href="cluster.html#cb374-50" aria-hidden="true" tabindex="-1"></a>                                                  <span class="fu">bind_rows</span>(.)</span>
<span id="cb374-51"><a href="cluster.html#cb374-51" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(sf.test.Cluster.MonteCarlo.DID.grid)</span>
<span id="cb374-52"><a href="cluster.html#cb374-52" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb374-53"><a href="cluster.html#cb374-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb374-54"><a href="cluster.html#cb374-54" aria-hidden="true" tabindex="-1"></a><span class="co"># testing</span></span>
<span id="cb374-55"><a href="cluster.html#cb374-55" aria-hidden="true" tabindex="-1"></a>grid.rho.test <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="fl">0.5</span>,<span class="fl">0.9</span>,<span class="fl">0.99</span>,<span class="dv">1</span>)</span>
<span id="cb374-56"><a href="cluster.html#cb374-56" aria-hidden="true" tabindex="-1"></a><span class="co">#test.grid &lt;- sf.Cluster.MonteCarlo.DID.Grid(grid.rho=grid.rho.test,Nsim=Nsim,N=1000,K=40,k=20,param=param.basic)</span></span>
<span id="cb374-57"><a href="cluster.html#cb374-57" aria-hidden="true" tabindex="-1"></a><span class="co">#test.grid.temporal &lt;- sf.Cluster.MonteCarlo.DID.Grid(grid.rho=grid.rho.test,Nsim=Nsim,N=1000,K=40,k=20,param=param.basic,cluster=&#39;Temporal&#39;)</span></span>
<span id="cb374-58"><a href="cluster.html#cb374-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb374-59"><a href="cluster.html#cb374-59" aria-hidden="true" tabindex="-1"></a><span class="co"># true simulations</span></span>
<span id="cb374-60"><a href="cluster.html#cb374-60" aria-hidden="true" tabindex="-1"></a>Nsim <span class="ot">&lt;-</span> <span class="dv">1000</span></span>
<span id="cb374-61"><a href="cluster.html#cb374-61" aria-hidden="true" tabindex="-1"></a>sf.simuls.Cluster.DID.grid.rho <span class="ot">&lt;-</span> <span class="fu">sf.Cluster.MonteCarlo.DID.Grid</span>(<span class="at">grid.rho=</span>grid.rho.test,<span class="at">Nsim=</span>Nsim,<span class="at">N=</span><span class="dv">1000</span>,<span class="at">K=</span><span class="dv">40</span>,<span class="at">k=</span><span class="dv">20</span>,<span class="at">param=</span>param.basic,<span class="at">ncpus=</span><span class="dv">8</span>)</span></code></pre></div>
<p>Let us now plot the resulting estimates:</p>
<div class="sourceCode" id="cb375"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb375-1"><a href="cluster.html#cb375-1" aria-hidden="true" tabindex="-1"></a><span class="co"># prepapring data</span></span>
<span id="cb375-2"><a href="cluster.html#cb375-2" aria-hidden="true" tabindex="-1"></a>sf.simuls.Cluster.DID.grid.rho <span class="ot">&lt;-</span> sf.simuls.Cluster.DID.grid.rho <span class="sc">%&gt;%</span></span>
<span id="cb375-3"><a href="cluster.html#cb375-3" aria-hidden="true" tabindex="-1"></a>                                    <span class="fu">mutate</span>(</span>
<span id="cb375-4"><a href="cluster.html#cb375-4" aria-hidden="true" tabindex="-1"></a>                                      <span class="at">TimeToTreatment =</span> <span class="fu">case_when</span>(</span>
<span id="cb375-5"><a href="cluster.html#cb375-5" aria-hidden="true" tabindex="-1"></a>                                        TimeToTreatment <span class="sc">==</span> <span class="st">&quot;99&quot;</span> <span class="sc">~</span> <span class="dv">21</span>,</span>
<span id="cb375-6"><a href="cluster.html#cb375-6" aria-hidden="true" tabindex="-1"></a>                                        <span class="cn">TRUE</span> <span class="sc">~</span> TimeToTreatment</span>
<span id="cb375-7"><a href="cluster.html#cb375-7" aria-hidden="true" tabindex="-1"></a>                                      ),</span>
<span id="cb375-8"><a href="cluster.html#cb375-8" aria-hidden="true" tabindex="-1"></a>                                      <span class="at">Rho =</span> <span class="fu">factor</span>(Rho,<span class="at">levels=</span><span class="fu">as.character</span>(grid.rho.test))</span>
<span id="cb375-9"><a href="cluster.html#cb375-9" aria-hidden="true" tabindex="-1"></a>                                    ) <span class="sc">%&gt;%</span></span>
<span id="cb375-10"><a href="cluster.html#cb375-10" aria-hidden="true" tabindex="-1"></a>                                    <span class="fu">pivot_longer</span>(<span class="at">cols=</span>SdTE<span class="sc">:</span>MeanSeTE,<span class="at">names_to =</span> <span class="st">&quot;Type&quot;</span>,<span class="at">values_to=</span><span class="st">&quot;SeEstim&quot;</span>) <span class="sc">%&gt;%</span></span>
<span id="cb375-11"><a href="cluster.html#cb375-11" aria-hidden="true" tabindex="-1"></a>                                    <span class="fu">mutate</span>(</span>
<span id="cb375-12"><a href="cluster.html#cb375-12" aria-hidden="true" tabindex="-1"></a>                                      <span class="at">Type =</span> <span class="fu">case_when</span>(</span>
<span id="cb375-13"><a href="cluster.html#cb375-13" aria-hidden="true" tabindex="-1"></a>                                        Type <span class="sc">==</span> <span class="st">&quot;MeanSeTE&quot;</span> <span class="sc">~</span> <span class="st">&quot;Estimated&quot;</span>,</span>
<span id="cb375-14"><a href="cluster.html#cb375-14" aria-hidden="true" tabindex="-1"></a>                                        Type <span class="sc">==</span> <span class="st">&quot;SdTE&quot;</span> <span class="sc">~</span> <span class="st">&quot;Truth&quot;</span>,</span>
<span id="cb375-15"><a href="cluster.html#cb375-15" aria-hidden="true" tabindex="-1"></a>                                        <span class="cn">TRUE</span> <span class="sc">~</span> <span class="st">&quot;&quot;</span></span>
<span id="cb375-16"><a href="cluster.html#cb375-16" aria-hidden="true" tabindex="-1"></a>                                      ),</span>
<span id="cb375-17"><a href="cluster.html#cb375-17" aria-hidden="true" tabindex="-1"></a>                                      <span class="at">Type =</span> <span class="fu">factor</span>(Type,<span class="at">levels=</span><span class="fu">c</span>(<span class="st">&quot;Truth&quot;</span>,<span class="st">&quot;Estimated&quot;</span>))</span>
<span id="cb375-18"><a href="cluster.html#cb375-18" aria-hidden="true" tabindex="-1"></a>                                    ) <span class="co">#%&gt;%</span></span>
<span id="cb375-19"><a href="cluster.html#cb375-19" aria-hidden="true" tabindex="-1"></a>                                    <span class="co">#pivot_wider(names_from = &quot;Method&quot;,values_from = c(&#39;TE&#39;,&#39;SeEstim&#39;))</span></span>
<span id="cb375-20"><a href="cluster.html#cb375-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb375-21"><a href="cluster.html#cb375-21" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(sf.simuls.Cluster.DID.grid.rho <span class="sc">%&gt;%</span> <span class="fu">filter</span>(Rho<span class="sc">==</span><span class="dv">0</span>),<span class="fu">aes</span>(<span class="at">x=</span>TimeToTreatment,<span class="at">y=</span>TE,<span class="at">group=</span>Type,<span class="at">color=</span>Type))<span class="sc">+</span></span>
<span id="cb375-22"><a href="cluster.html#cb375-22" aria-hidden="true" tabindex="-1"></a><span class="co">#  geom_pointrange(aes(ymin=TE-1.96*SeEstim,ymax=TE+1.96*SeEstim),position=position_dodge(1))+</span></span>
<span id="cb375-23"><a href="cluster.html#cb375-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">color=</span><span class="st">&#39;red&#39;</span>) <span class="sc">+</span></span>
<span id="cb375-24"><a href="cluster.html#cb375-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_errorbar</span>(<span class="fu">aes</span>(<span class="at">ymin=</span>TE<span class="fl">-1.96</span><span class="sc">*</span>SeEstim,<span class="at">ymax=</span>TE<span class="fl">+1.96</span><span class="sc">*</span>SeEstim,<span class="at">color=</span>Type,<span class="at">group=</span>Type),<span class="at">position=</span><span class="fu">position_dodge</span>(<span class="dv">1</span>),<span class="at">width=</span><span class="fl">0.5</span>)<span class="sc">+</span></span>
<span id="cb375-25"><a href="cluster.html#cb375-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">coord_cartesian</span>(<span class="at">ylim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.15</span>,<span class="fl">0.15</span>))<span class="sc">+</span></span>
<span id="cb375-26"><a href="cluster.html#cb375-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_color_discrete</span>(<span class="at">name=</span><span class="st">&#39;Rho=0&#39;</span>)<span class="sc">+</span></span>
<span id="cb375-27"><a href="cluster.html#cb375-27" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()<span class="sc">+</span></span>
<span id="cb375-28"><a href="cluster.html#cb375-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(Method<span class="sc">~</span>.) </span>
<span id="cb375-29"><a href="cluster.html#cb375-29" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(sf.simuls.Cluster.DID.grid.rho <span class="sc">%&gt;%</span> <span class="fu">filter</span>(Rho<span class="sc">==</span><span class="fl">0.5</span>),<span class="fu">aes</span>(<span class="at">x=</span>TimeToTreatment,<span class="at">y=</span>TE,<span class="at">group=</span>Type,<span class="at">color=</span>Type))<span class="sc">+</span></span>
<span id="cb375-30"><a href="cluster.html#cb375-30" aria-hidden="true" tabindex="-1"></a><span class="co">#  geom_pointrange(aes(ymin=TE-1.96*SeEstim,ymax=TE+1.96*SeEstim),position=position_dodge(1))+</span></span>
<span id="cb375-31"><a href="cluster.html#cb375-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">color=</span><span class="st">&#39;red&#39;</span>) <span class="sc">+</span></span>
<span id="cb375-32"><a href="cluster.html#cb375-32" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_errorbar</span>(<span class="fu">aes</span>(<span class="at">ymin=</span>TE<span class="fl">-1.96</span><span class="sc">*</span>SeEstim,<span class="at">ymax=</span>TE<span class="fl">+1.96</span><span class="sc">*</span>SeEstim,<span class="at">color=</span>Type,<span class="at">group=</span>Type),<span class="at">position=</span><span class="fu">position_dodge</span>(<span class="dv">1</span>),<span class="at">width=</span><span class="fl">0.5</span>)<span class="sc">+</span></span>
<span id="cb375-33"><a href="cluster.html#cb375-33" aria-hidden="true" tabindex="-1"></a>  <span class="fu">coord_cartesian</span>(<span class="at">ylim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.15</span>,<span class="fl">0.15</span>))<span class="sc">+</span></span>
<span id="cb375-34"><a href="cluster.html#cb375-34" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_color_discrete</span>(<span class="at">name=</span><span class="st">&#39;Rho=0.5&#39;</span>)<span class="sc">+</span></span>
<span id="cb375-35"><a href="cluster.html#cb375-35" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()<span class="sc">+</span></span>
<span id="cb375-36"><a href="cluster.html#cb375-36" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(Method<span class="sc">~</span>.) </span>
<span id="cb375-37"><a href="cluster.html#cb375-37" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(sf.simuls.Cluster.DID.grid.rho <span class="sc">%&gt;%</span> <span class="fu">filter</span>(Rho<span class="sc">==</span><span class="fl">0.9</span>),<span class="fu">aes</span>(<span class="at">x=</span>TimeToTreatment,<span class="at">y=</span>TE,<span class="at">group=</span>Type,<span class="at">color=</span>Type))<span class="sc">+</span></span>
<span id="cb375-38"><a href="cluster.html#cb375-38" aria-hidden="true" tabindex="-1"></a><span class="co">#  geom_pointrange(aes(ymin=TE-1.96*SeEstim,ymax=TE+1.96*SeEstim),position=position_dodge(1))+</span></span>
<span id="cb375-39"><a href="cluster.html#cb375-39" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">color=</span><span class="st">&#39;red&#39;</span>) <span class="sc">+</span></span>
<span id="cb375-40"><a href="cluster.html#cb375-40" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_errorbar</span>(<span class="fu">aes</span>(<span class="at">ymin=</span>TE<span class="fl">-1.96</span><span class="sc">*</span>SeEstim,<span class="at">ymax=</span>TE<span class="fl">+1.96</span><span class="sc">*</span>SeEstim,<span class="at">color=</span>Type,<span class="at">group=</span>Type),<span class="at">position=</span><span class="fu">position_dodge</span>(<span class="dv">1</span>),<span class="at">width=</span><span class="fl">0.5</span>)<span class="sc">+</span></span>
<span id="cb375-41"><a href="cluster.html#cb375-41" aria-hidden="true" tabindex="-1"></a>  <span class="fu">coord_cartesian</span>(<span class="at">ylim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.15</span>,<span class="fl">0.15</span>))<span class="sc">+</span></span>
<span id="cb375-42"><a href="cluster.html#cb375-42" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_color_discrete</span>(<span class="at">name=</span><span class="st">&#39;Rho=0.9&#39;</span>)<span class="sc">+</span></span>
<span id="cb375-43"><a href="cluster.html#cb375-43" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()<span class="sc">+</span></span>
<span id="cb375-44"><a href="cluster.html#cb375-44" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(Method<span class="sc">~</span>.) </span>
<span id="cb375-45"><a href="cluster.html#cb375-45" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(sf.simuls.Cluster.DID.grid.rho <span class="sc">%&gt;%</span> <span class="fu">filter</span>(Rho<span class="sc">==</span><span class="fl">0.99</span>),<span class="fu">aes</span>(<span class="at">x=</span>TimeToTreatment,<span class="at">y=</span>TE,<span class="at">group=</span>Type,<span class="at">color=</span>Type))<span class="sc">+</span></span>
<span id="cb375-46"><a href="cluster.html#cb375-46" aria-hidden="true" tabindex="-1"></a><span class="co">#  geom_pointrange(aes(ymin=TE-1.96*SeEstim,ymax=TE+1.96*SeEstim),position=position_dodge(1))+</span></span>
<span id="cb375-47"><a href="cluster.html#cb375-47" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">color=</span><span class="st">&#39;red&#39;</span>) <span class="sc">+</span></span>
<span id="cb375-48"><a href="cluster.html#cb375-48" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_errorbar</span>(<span class="fu">aes</span>(<span class="at">ymin=</span>TE<span class="fl">-1.96</span><span class="sc">*</span>SeEstim,<span class="at">ymax=</span>TE<span class="fl">+1.96</span><span class="sc">*</span>SeEstim,<span class="at">color=</span>Type,<span class="at">group=</span>Type),<span class="at">position=</span><span class="fu">position_dodge</span>(<span class="dv">1</span>),<span class="at">width=</span><span class="fl">0.5</span>)<span class="sc">+</span></span>
<span id="cb375-49"><a href="cluster.html#cb375-49" aria-hidden="true" tabindex="-1"></a>  <span class="fu">coord_cartesian</span>(<span class="at">ylim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.15</span>,<span class="fl">0.15</span>))<span class="sc">+</span></span>
<span id="cb375-50"><a href="cluster.html#cb375-50" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_color_discrete</span>(<span class="at">name=</span><span class="st">&#39;Rho=0.99&#39;</span>)<span class="sc">+</span></span>
<span id="cb375-51"><a href="cluster.html#cb375-51" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()<span class="sc">+</span></span>
<span id="cb375-52"><a href="cluster.html#cb375-52" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(Method<span class="sc">~</span>.) </span>
<span id="cb375-53"><a href="cluster.html#cb375-53" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(sf.simuls.Cluster.DID.grid.rho <span class="sc">%&gt;%</span> <span class="fu">filter</span>(Rho<span class="sc">==</span><span class="dv">1</span>),<span class="fu">aes</span>(<span class="at">x=</span>TimeToTreatment,<span class="at">y=</span>TE,<span class="at">group=</span>Type,<span class="at">color=</span>Type))<span class="sc">+</span></span>
<span id="cb375-54"><a href="cluster.html#cb375-54" aria-hidden="true" tabindex="-1"></a><span class="co">#  geom_pointrange(aes(ymin=TE-1.96*SeEstim,ymax=TE+1.96*SeEstim),position=position_dodge(1))+</span></span>
<span id="cb375-55"><a href="cluster.html#cb375-55" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">color=</span><span class="st">&#39;red&#39;</span>) <span class="sc">+</span></span>
<span id="cb375-56"><a href="cluster.html#cb375-56" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_errorbar</span>(<span class="fu">aes</span>(<span class="at">ymin=</span>TE<span class="fl">-1.96</span><span class="sc">*</span>SeEstim,<span class="at">ymax=</span>TE<span class="fl">+1.96</span><span class="sc">*</span>SeEstim,<span class="at">color=</span>Type,<span class="at">group=</span>Type),<span class="at">position=</span><span class="fu">position_dodge</span>(<span class="dv">1</span>),<span class="at">width=</span><span class="fl">0.5</span>)<span class="sc">+</span></span>
<span id="cb375-57"><a href="cluster.html#cb375-57" aria-hidden="true" tabindex="-1"></a>  <span class="fu">coord_cartesian</span>(<span class="at">ylim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.15</span>,<span class="fl">0.15</span>))<span class="sc">+</span></span>
<span id="cb375-58"><a href="cluster.html#cb375-58" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_color_discrete</span>(<span class="at">name=</span><span class="st">&#39;Rho=1&#39;</span>)<span class="sc">+</span></span>
<span id="cb375-59"><a href="cluster.html#cb375-59" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()<span class="sc">+</span></span>
<span id="cb375-60"><a href="cluster.html#cb375-60" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(Method<span class="sc">~</span>.) </span>
<span id="cb375-61"><a href="cluster.html#cb375-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb375-62"><a href="cluster.html#cb375-62" aria-hidden="true" tabindex="-1"></a><span class="co"># ggplot(sf.simuls.Cluster.DID.grid.rho,aes(x=TimeToTreatment,y=TE_FD,group=Type,color=Type))+</span></span>
<span id="cb375-63"><a href="cluster.html#cb375-63" aria-hidden="true" tabindex="-1"></a><span class="co"># #  geom_pointrange(aes(ymin=TE-1.96*SeEstim,ymax=TE+1.96*SeEstim),position=position_dodge(1))+</span></span>
<span id="cb375-64"><a href="cluster.html#cb375-64" aria-hidden="true" tabindex="-1"></a><span class="co">#   geom_point(color=&#39;red&#39;) +</span></span>
<span id="cb375-65"><a href="cluster.html#cb375-65" aria-hidden="true" tabindex="-1"></a><span class="co">#   geom_errorbar(aes(ymin=TE_FD-1.96*SeEstim_FD,ymax=TE_FD+1.96*SeEstim_FD,color=Type,group=Type),position=position_dodge(1),width=0.2)+</span></span>
<span id="cb375-66"><a href="cluster.html#cb375-66" aria-hidden="true" tabindex="-1"></a><span class="co">#   geom_errorbar(aes(ymin=TE_SA-1.96*SeEstim_SA,ymax=TE_SA+1.96*SeEstim_SA,color=Type,group=Type),position=position_dodge(1),width=0.5)+</span></span>
<span id="cb375-67"><a href="cluster.html#cb375-67" aria-hidden="true" tabindex="-1"></a><span class="co">#   geom_errorbar(aes(ymin=TE_StackedFD-1.96*SeEstim_StackedFD,ymax=TE_StackedFD+1.96*SeEstim_StackedFD,color=Type,group=Type),position=position_dodge(1),width=0.9)+</span></span>
<span id="cb375-68"><a href="cluster.html#cb375-68" aria-hidden="true" tabindex="-1"></a><span class="co">#   theme_bw()+</span></span>
<span id="cb375-69"><a href="cluster.html#cb375-69" aria-hidden="true" tabindex="-1"></a><span class="co">#   facet_grid(Rho~.)</span></span></code></pre></div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:ModelSimpleParPlot"></span>
<img src="STCI_files/figure-html/ModelSimpleParPlot-1.png" alt="DID estimates with increasing temporal autocorrelation in outcomes" width="75%" /><img src="STCI_files/figure-html/ModelSimpleParPlot-2.png" alt="DID estimates with increasing temporal autocorrelation in outcomes" width="75%" /><img src="STCI_files/figure-html/ModelSimpleParPlot-3.png" alt="DID estimates with increasing temporal autocorrelation in outcomes" width="75%" /><img src="STCI_files/figure-html/ModelSimpleParPlot-4.png" alt="DID estimates with increasing temporal autocorrelation in outcomes" width="75%" /><img src="STCI_files/figure-html/ModelSimpleParPlot-5.png" alt="DID estimates with increasing temporal autocorrelation in outcomes" width="75%" />
<p class="caption">
Figure 9.5: DID estimates with increasing temporal autocorrelation in outcomes
</p>
</div>
<p>Figure <a href="cluster.html#fig:ModelSimpleParPlot">9.5</a> shows that indeed sampling noise increases with autocorrelation in panel data.
For the same sample size of <span class="math inline">\(N=1000\)</span>, the true 99% sampling noise for the average effect of the treatment on the treated estimated by Monte Carlo simulations is equal to:</p>
<ul>
<li>0.07 when <span class="math inline">\(\rho=0\)</span>,</li>
<li>0.08 when <span class="math inline">\(\rho=0.5\)</span>,</li>
<li>0.14 when <span class="math inline">\(\rho=0.9\)</span>,</li>
<li>0.19 when <span class="math inline">\(\rho=0.99\)</span>,</li>
<li>0.2 when <span class="math inline">\(\rho=1\)</span>.</li>
</ul>
<p>The heteroskedasticity-robust estimates of 99% sampling noise for the average effect of the treatment on the treated ignoring autocorrelation are equal to (taking the average estimate of sampling noise over Monte Carlo replications for the the <code>fixest</code> implementation of the Sun and Abraham estimator and for the Stacked First Difference estimator, respectively):</p>
<ul>
<li>0.07 and
0.07 when <span class="math inline">\(\rho=0\)</span>,</li>
<li>0.08 and
0.08 when <span class="math inline">\(\rho=0.5\)</span>,</li>
<li>0.13 and
0.13 when <span class="math inline">\(\rho=0.9\)</span>,</li>
<li>0.14 and
0.14 when <span class="math inline">\(\rho=0.99\)</span>,</li>
<li>0.14 and
0.14 when <span class="math inline">\(\rho=1\)</span>.</li>
</ul>
<p>This means that heteroskedasticity-robust estimates of 99% sampling noise for the average effect of the treatment on the treated ignoring autocorrelation is smaller than the truth, by a factor of (for the the <code>fixest</code> implementation of the Sun and Abraham estimator and for the Stacked First Difference estimator, respectively):</p>
<ul>
<li>1.04 and
1.02 when <span class="math inline">\(\rho=0\)</span>,</li>
<li>1.02 and
1.01 when <span class="math inline">\(\rho=0.5\)</span>,</li>
<li>0.89 and
0.88 when <span class="math inline">\(\rho=0.9\)</span>,</li>
<li>0.76 and
0.75 when <span class="math inline">\(\rho=0.99\)</span>,</li>
<li>0.71 and
0.71 when <span class="math inline">\(\rho=1\)</span>.</li>
</ul>
<p>As true autocorrelation increases, the heteroskedasticity-robust estimator of the sampling noise of the TT parameter increasingly over-estimates true sampling noise.
At the same time, the heteroskedasticity-robust <span class="math inline">\(2\times 2\)</span> estimates of sampling noise underestimate the sampling noise of ATT in a major way.
This is because they for now ignore any autocorrelation between <span class="math inline">\(2\times 2\)</span> estimates as studied in Theorem <a href="NE.html#thm:asympnoiseSATTPanel">4.27</a>.</p>
<div class="remark">
<p><span id="unlabeled-div-218" class="remark"><em>Remark</em>. </span>An interesting feature of Figure <a href="cluster.html#fig:ModelSimpleParPlot">9.5</a> is that, when <span class="math inline">\(\rho&gt;0\)</span>, sampling noise decreases as we move closer to to the treatment date and increases as we move away.
Why is that so?
It is due to a combination of our choice of reference period and of the extent of autocorrelation in the error terms.<br />
Indeed, following Theorem <a href="NE.html#thm:asympnoiseSAPanel">4.25</a>, we know that the sampling noise of each individual <span class="math inline">\(2\times 2\)</span> estimate depends on the variance of <span class="math inline">\(Y^0_{i,d+\tau}-Y^0_{i,d-1}\)</span>, and thus on the variance of <span class="math inline">\(U_{i,d+\tau}-U_{i,d-1}\)</span>
Under our <span class="math inline">\(AR(1)\)</span> model of dynamics of <span class="math inline">\(U_{i,t}\)</span> and substituting iteratively, we have:</p>
</div>
<p><span class="math display">\[\begin{align*}
  U_{i,d+\tau}-U_{i,d-1} &amp; = \rho^{\tau+1}U_{i,d-1}+\sum_{k=0}^{\tau}\rho^{k}\epsilon_{i,d+\tau-k}-U_{i,d-1}.
\end{align*}\]</span></p>
<p>As a consequence, we have:</p>
<p><span class="math display">\[\begin{align*}
  \var{U_{i,d+\tau}-U_{i,d-1}} &amp; = (1-\rho^{\tau+1})^2\var{U_{i,d-1}}+\sum_{k=0}^{\tau}\rho^{2k}\sigma^2_{\epsilon}\\
                                &amp; = (1-\rho^{\tau+1})^2\var{U_{i,d-1}}+\frac{1-\rho^{2(\tau+1)}}{1-\rho^{2}}\sigma^2_{\epsilon},
\end{align*}\]</span></p>
<p>where the last term in the right hand side of the second equality is valid when <span class="math inline">\(\rho&lt;1\)</span>, and is replaced by <span class="math inline">\((\tau+1)\sigma^2_{\epsilon}\)</span> when <span class="math inline">\(\rho=1\)</span>.
That formula means that when <span class="math inline">\(\tau\)</span> is close to <span class="math inline">\(-1\)</span>, that is when the estimation period is close to the reference period, the variance of the <span class="math inline">\(2\times 2\)</span> DID estimate is small.
When <span class="math inline">\(\tau\)</span> increases and the estimation period gets further away from the reference period, the variance of the <span class="math inline">\(2\times 2\)</span> DID estimate increases.
The intuition for this result is that, with autocorrelated error terms, the outcomes of the same individual observed at periods that are close to each other in time are positively correlated, and the first differencing of DID gets rid of part of their influence.
In the limit, with perfectly persistent error terms (<span class="math inline">\(\rho=1\)</span>), the shocks that occur up to the reference period <span class="math inline">\(d-1\)</span> are completely cancelled (first part of the right hand side of the equation).</p>
<div class="remark">
<p><span id="unlabeled-div-219" class="remark"><em>Remark</em>. </span>A more unexpected result, is that, when autocorrelation increases, <code>fixest</code> heteroskedasticity-robust estimates of sampling noise using Sun and Abraham estimator overestimate true sampling noise in a major way when treatment and reference periods are close to each other (<code>Method=="SA"</code>), and seems to slighlty underestimate it when the treatment and reference period are far apart.
This is strange because using heteroskedasticity-robust <span class="math inline">\(2\times 2\)</span> and Stacked First Difference estimates of sampling noise gives a correct estimate of the amount of true sampling noise, irrespective of the level of autocorrelation in the data.
It looks as if the heteroskedasticity-robust estimator of sampling noise in <code>fixest</code> fails at identifying and estimating correctly the heteroskedasticity that takes place across time periods, and instead smooths out the variance over all time periods.</p>
<p>The reason for this behavior lies in how <code>fixest</code> estimates sampling noise.
The <code>feols</code> command in <code>fixest</code> uses a within type of estimator.
As a consequence, it recovers estimates of residuals in levels, not in first difference as with the <span class="math inline">\(2\times 2\)</span> estimates in First Difference or the Stacked FD estimator.
Therefore, the <code>feols</code> command in <code>fixest</code> does not use the estimator in Theorem <a href="NE.html#thm:asympnoiseSAPanel">4.25</a> which involves the residual of the FD estimator, but rather something equivalent to the estimate in Theorem <a href="NE.html#thm:asympnoiseSACross">4.24</a>, with <span class="math inline">\(Y_{i,t}\)</span> replaced by <span class="math inline">\(U_{i,t}\)</span>.
These two approaches are equivalent when the error terms are independent over time (<em>i.e</em> under Assumption <a href="NE.html#hyp:iidDIDPanel">4.28</a>), but they do not yield the same estimates when the error terms are correlated over time.
Indeed, <span class="math inline">\(\var{Y_{i,d+\tau}^1-Y_{i,d-1}^0}=\var{Y_{i,d+\tau}^1}+\var{Y_{i,d-1}^0}-2\cov{Y_{i,d+\tau}^1,Y_{i,d-1}^0}\)</span>.
When <span class="math inline">\(\cov{Y_{i,d+\tau}^1,Y_{i,d-1}^0}&gt;0\)</span>, the variance of the difference is smaller than the sum of the variances of each components, and thus the estimate of samling noise based on the FD estimators is going to be smaller than the one based on the within estimator (as in <code>fixest</code>).</p>
<p>It is less clear why <code>fixest</code> heteroskedasticity-robust estimates of sampling noise using Sun and Abraham estimator slighlty underestimates sampling noise when the treatment and reference period are far apart.
This is an open question at the time of writing.</p>
</div>
</div>
<div id="design-effect-in-panel-data" class="section level3 hasAnchor" number="9.2.2">
<h3><span class="header-section-number">9.2.2</span> Design effect in panel data<a href="cluster.html#design-effect-in-panel-data" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Let us now derive an estimate of the design effect in panel data.</p>
<div id="design-effect-for-2times-2-did-estimates" class="section level4 hasAnchor" number="9.2.2.1">
<h4><span class="header-section-number">9.2.2.1</span> Design effect for <span class="math inline">\(2\times 2\)</span> DID estimates<a href="cluster.html#design-effect-for-2times-2-did-estimates" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Autocorrelation of error terms over time does not affect the estimates of sampling noise for the individual <span class="math inline">\(2\times 2\)</span> DID estimates in panel data based on the First-Difference transformation.
Indeed, Theorem <a href="NE.html#thm:asympnoiseSAPanel">4.25</a> only rests on the fact that outcomes are independent over space, not over time (Assumption <a href="NE.html#hyp:iidDID">4.15</a>).
This is confirmed by the simulations in Figure <a href="cluster.html#fig:ModelSimpleParPlot">9.5</a>: when <span class="math inline">\(\rho&gt;0\)</span>, and thus there is autocorrelation between outcomes over time, the estimates of sampling noise of the individual <span class="math inline">\(2\times 2\)</span> DID estimates based on Theorem <a href="NE.html#thm:asympnoiseSAPanel">4.25</a> (for the <span class="math inline">\(2\times 2\)</span> First Difference and Stacked First Difference estimators) are correct.
The reason is that the <span class="math inline">\(2\times 2\)</span> First Difference estimators are purely cross-sectional: they do not involve observations from several periods.
All of that is taken into account in the differencing part.
As a consequence, the validity of the estimates of sampling noise of the <span class="math inline">\(2\times 2\)</span> DID estimates based on Theorem <a href="NE.html#thm:asympnoiseSAPanel">4.25</a> are valid under any type of autocorrelation, which makes them extremely attractive.</p>
<p>In contrast, <span class="math inline">\(2\times 2\)</span> DID estimates in panel data that are not based on the First Difference transformation, but rather on the within transformation, such as the ones obtained using the <code>feols</code> command of the <code>fixest</code> package, require an absence of temporal autocorrelation to be valid.
They will overestimate the extent of sampling noise when error terms are positively correlated over time, and they will underestimate sampling noise when error terms are negatively correlated over time.</p>
</div>
<div id="design-effect-for-the-average-treatment-effect-on-the-treated" class="section level4 hasAnchor" number="9.2.2.2">
<h4><span class="header-section-number">9.2.2.2</span> Design effect for the Average Treatment Effect on the Treated<a href="cluster.html#design-effect-for-the-average-treatment-effect-on-the-treated" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Estimates of sampling noise for the Average Treatment Effect on the Treated will always be affected by temporal auto-correlation of the error terms, even when the estimates of sampling noise for the individual <span class="math inline">\(2\times 2\)</span> DID estimates is not.
The intuition for why is that, when error terms are correlated over time, individual <span class="math inline">\(2\times 2\)</span> DID estimates are more correlated with each other than what Theorem <a href="NE.html#thm:asympnoiseSATTPanel">4.27</a> would suggest.
If they are more correlated, then the variance of their weighted average increases, since it is more likely that two individual <span class="math inline">\(2\times 2\)</span> DID estimates look alike than what we would have expected under Assumption <a href="NE.html#hyp:iidDIDPanel">4.28</a>.
Let’s see how the sampling noise of the Average Treatment Effect on the Treated changes when relaxing Assumption <a href="NE.html#hyp:iidDIDPanel">4.28</a>.</p>
<div class="hypothesis">
<p><span id="hyp:AR1DIDPanel" class="hypothesis"><strong>Hypothesis 9.2  (AR(1) autocorrelation and i.i.d. sampling in panel data) </strong></span>We assume that potential outcomes are generated as follows:</p>
<p><span class="math display">\[\begin{align*}
  Y^0_{i,t} &amp; = \mu_i + \delta_t + U^0_{i,t}\\
  Y^1_{i,t} &amp; = \mu_i + \delta_t + \bar{\alpha} +\eta_{i,t} + U^0_{i,t}\\
  U^0_{i,t} &amp; = \rho U^0_{i,t-1} + \epsilon_{i,t},
\end{align*}\]</span></p>
<p>with <span class="math inline">\(\esp{U^0_{i,t}}=\esp{\eta_{i,t}}=0\)</span>, <span class="math inline">\(\forall t\)</span>, <span class="math inline">\(\esp{U^0_{i,t}|D_i}=0\)</span>, <span class="math inline">\(\forall t\)</span> and:</p>
<p><span class="math display">\[\begin{align*}
\forall i,j\leq N\text{, }\forall t,t&#39;\leq T\text{, with either }i\neq j \text{ or } t\neq t&#39; &amp; (\epsilon_{i,t},\eta_{i,t},D_i)\Ind(\epsilon_{j,t&#39;},\eta_{j,t&#39;},D_j),\\
                                           &amp; (\epsilon_{i,t},\eta_{i,t},D_i)\&amp;(\epsilon_{j,t&#39;},\eta_{j,t&#39;},D_j)\sim F_{\epsilon,\eta,D}.
\end{align*}\]</span></p>
<p>We also assume that <span class="math inline">\(U^0_{i,t}\Ind\epsilon_{j,t&#39;},\eta_{j,t&#39;}\)</span>, <span class="math inline">\(\forall i,j\leq N\text{, }\forall t,t&#39;\leq T\)</span>.</p>
</div>
<div class="remark">
<p><span id="unlabeled-div-220" class="remark"><em>Remark</em>. </span>Assumption <a href="cluster.html#hyp:AR1DIDPanel">9.2</a> is less restrictive than Assumption <a href="NE.html#hyp:iidDIDPanel">4.28</a>: it allows for error terms for the same unit <span class="math inline">\(i\)</span> to be correlated over time through an AR(1) process.
Assumption <a href="cluster.html#hyp:AR1DIDPanel">9.2</a> nevertheless still imposes than treatment effects are not autocorrelated over time, which is still pretty restrictive.</p>
</div>
<div class="theorem">
<p><span id="thm:asympnoiseSATTPanelAR1" class="theorem"><strong>Theorem 9.2  (Asymptotic Distribution of Treatment of the Treated Estimated Using Sun and Abraham Estimator in Panel Data with AR(1) Error Terms) </strong></span>Under Assumptions <a href="NE.html#hyp:NoTreatmentFirst">4.12</a>, <a href="NE.html#hyp:NoAnticipationEffects">4.13</a>, <a href="NE.html#hyp:ParallelTrends">4.14</a>, <a href="cluster.html#hyp:AR1DIDPanel">9.2</a> and <a href="NE.html#hyp:finitevarDID">4.16</a>, and with panel data containing a total of <span class="math inline">\(N\)</span> units observed over <span class="math inline">\(T\)</span> time periods, we have:</p>
<p><span class="math display">\[\begin{align*}
\sqrt{N}(\hat\Delta^{Y}_{TT_{SA}}(k)-\Delta^{Y}_{TT_{SA}}(k)) &amp; \stackrel{d}{\rightarrow}
  \mathcal{N}\left(0,\sum_d\sum_{\tau}V_P(\hat\beta^{SA}_{d,\tau})(w^k(d,d-1,\tau,\infty))^2\right.\\
      &amp; \phantom{\stackrel{d}{\rightarrow}}\left.+\sum_{d}\sum_{d&#39;}\sum_{\tau}\sum_{\tau&#39;\neq\tau}
        \text{Cov}_P(\hat\beta^{SA}_{d,\tau},\hat\beta^{SA}_{d&#39;,\tau&#39;})w^k(d,d-1,\tau,\infty)w^k(d&#39;,d&#39;-1,\tau&#39;,\infty)\right),
\end{align*}\]</span></p>
<p>where:</p>
<p><span class="math display">\[\begin{align*}
V_P(\hat\beta^{SA}_{d,\tau}) &amp; =\frac{1}{p^{d,\infty}}\left(\frac{\var{Y_{i,d+\tau}^1-Y_{i,d-1}^0|D_i=d}}{p^{d,\infty}_D}+\frac{\var{Y_{i,d+\tau}^0-Y_{i,d-1}^0|D_i=\infty}}{1-p^{d,\infty}_D}\right)\\
\text{Cov}_P(\hat\beta^{SA}_{d,\tau},\hat\beta^{SA}_{d&#39;,\tau&#39;})
&amp; =\frac{1}{p^{d,\infty}}\left[\frac{\esp{\Delta\epsilon^{d,\tau}_i\Delta\epsilon^{d&#39;,\tau&#39;}_i|D_i=\infty}}{1-p^{d,\infty}_D}+\frac{\esp{\Delta\epsilon^{d,\tau}_i\Delta\epsilon^{d&#39;,\tau&#39;}_i|D_i=d}}{p^{d,\infty}_D}\right] \text{ when } d=d&#39;\\
&amp; = \frac{\esp{\Delta\epsilon^{d,\tau}_i\Delta\epsilon^{d&#39;,\tau&#39;}_i|D_i=d}}{p^{d&#39;,\infty}(1-p^{d&#39;,\infty}_D)} \text{ when } d\neq d&#39;,
\end{align*}\]</span></p>
<p>with <span class="math inline">\(p^{d,\infty}=\Pr(D_i=d\cup D_i=\infty)\)</span> and <span class="math inline">\(p^{d,\infty}_D=\Pr(D_i=d|D_i=d\cup D_i=\infty)\)</span>.</p>
</div>
<div class="proof">
<p><span id="unlabeled-div-221" class="proof"><em>Proof</em>. </span>See Section <a href="proofs.html#proofasympnoiseSATTPanelAR1">A.5.2</a>.</p>
</div>
<div class="remark">
<p><span id="unlabeled-div-222" class="remark"><em>Remark</em>. </span>The details of the terms in Theorem <a href="cluster.html#thm:asympnoiseSATTPanelAR1">9.2</a> can be found in the proof, Section <a href="proofs.html#proofasympnoiseSATTPanelAR1">A.5.2</a>.
They depend on the variance of <span class="math inline">\(U^0_{i,t}\)</span> and on <span class="math inline">\(\rho\)</span>.</p>
</div>
</div>
</div>
<div id="estimating-sampling-noise-in-panel-data-with-autocorrelated-error-terms" class="section level3 hasAnchor" number="9.2.3">
<h3><span class="header-section-number">9.2.3</span> Estimating sampling noise in panel data with autocorrelated error terms<a href="cluster.html#estimating-sampling-noise-in-panel-data-with-autocorrelated-error-terms" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>We are now equipped to estimate sampling noise in panel data with autocorrelated error terms.
As in the case of spatial autocorrelation, the solutions involve using the plug-in estimator based on Theorem <a href="cluster.html#thm:asympnoiseSATTPanelAR1">9.2</a>, using cluster-robust standard errors, using Feasible Generalized Least Squares, the bootstrap and randomization inference.</p>
<div id="using-the-plug-in-estimator" class="section level4 hasAnchor" number="9.2.3.1">
<h4><span class="header-section-number">9.2.3.1</span> Using the plug-in estimator<a href="cluster.html#using-the-plug-in-estimator" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Although a little bit tedious, it is possible to estimate each component of the plug-in formula in Theorem <a href="cluster.html#thm:asympnoiseSATTPanelAR1">9.2</a>, whose details can be found in Section <a href="proofs.html#proofasympnoiseSATTPanelAR1">A.5.2</a>.
We need mostly to estimate <span class="math inline">\(\rho\)</span>, by regressing <span class="math inline">\(\hat{U}^0_{i,t}\)</span> on <span class="math inline">\(\hat{U}^0_{i,t-1}\)</span>.
We then need to estimate the variance terms.
This is left as an exercise.</p>
</div>
<div id="using-feasible-generalized-least-squares-1" class="section level4 hasAnchor" number="9.2.3.2">
<h4><span class="header-section-number">9.2.3.2</span> Using Feasible Generalized Least Squares<a href="cluster.html#using-feasible-generalized-least-squares-1" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>It is possible to build the matrix <span class="math inline">\(\hat{\Omega}_{GLS}=\hatesp{UU&#39;|X}\)</span> under Assumption <a href="NE.html#hyp:iidDIDPanel">4.28</a>.
It is a block diagonal matrix, with all blocks being the observations over time of the same unit in the panel.
The covariance terms depend on <span class="math inline">\(\hat\rho\)</span> and the variance of <span class="math inline">\(\hat{U}^0_{i,t}\)</span> and <span class="math inline">\(\eta_{i,t}\)</span>.
Estimating the terms in this matrix is left as an exercise.
CLuster-robust FGLS estimates are also feasible, obviously.</p>
</div>
<div id="using-cluster-robust-standard-errors-1" class="section level4 hasAnchor" number="9.2.3.3">
<h4><span class="header-section-number">9.2.3.3</span> Using Cluster-Robust Standard Errors<a href="cluster.html#using-cluster-robust-standard-errors-1" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>As in the spatial clustering case, it is possible to use a cluster robust covariance matrix in panel data with autocorrelated error terms.
For the within estimator, the formula can be derived in the same way, except with clusters being the groups of observations belonging to the same unit observed over time.
Estimating this formula can be done with either the <code>sandwich</code> package or the <code>cluster</code> option in the <code>fixest</code> package.</p>
<p>Here, I want to introduce an alternative approach, which is going to make our lives much easier when correlation between error terms is going to be richer and more complex.
This approach is due to <a href="https://doi.org/10.1162/rest_a_00818">Leung (2020)</a> and it generalizes cluster-robust covariance matrices to a much broader set of cases while retaining the interpretability of the cluster-robust standard errors.
Leung’s estimator of the variance of the OLS estimator is as follows: <span class="math inline">\(\hatvar{\hat{\Theta}_{OLS,Leung}}=(X&#39;X)^{-1}\hat{\mathcal{M}}&#39;G\hat{\mathcal{M}}(X&#39;X)^{-1}\)</span>, where <span class="math inline">\(\hat{\mathcal{M}}=(X_1\hat{\epsilon}_1,\dots,X_N\hat{\epsilon}_N)&#39;\)</span>, with <span class="math inline">\(\hat{\epsilon}\)</span> the vector of regression residuals and <span class="math inline">\(X_k\)</span> the vector of covariates for observation <span class="math inline">\(k\)</span>, and <span class="math inline">\(G\)</span> is a matrix indicating which observations are correlated with each other.
In the case of temporal autocorrelation, <span class="math inline">\(G_{i,j}\)</span> takes value <span class="math inline">\(1\)</span> when observations <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> in the dataset belong to the same unit and zero otherwise.</p>
<div class="example">
<p><span id="exm:unnamed-chunk-382" class="example"><strong>Example 9.8  </strong></span>Let’s see how this all works in our example.
We actually already introduced the <code>cluster</code> option in the original Monte Carlo simulation functions.
Extending our simulations to clustering is therefore straightfoward.</p>
</div>
<div class="sourceCode" id="cb376"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb376-1"><a href="cluster.html#cb376-1" aria-hidden="true" tabindex="-1"></a><span class="co"># true simulations</span></span>
<span id="cb376-2"><a href="cluster.html#cb376-2" aria-hidden="true" tabindex="-1"></a>Nsim <span class="ot">&lt;-</span> <span class="dv">1000</span></span>
<span id="cb376-3"><a href="cluster.html#cb376-3" aria-hidden="true" tabindex="-1"></a>sf.simuls.Cluster.DID.Temporal.grid.rho <span class="ot">&lt;-</span> <span class="fu">sf.Cluster.MonteCarlo.DID.Grid</span>(<span class="at">grid.rho=</span>grid.rho.test,<span class="at">Nsim=</span>Nsim,<span class="at">N=</span><span class="dv">1000</span>,<span class="at">K=</span><span class="dv">40</span>,<span class="at">k=</span><span class="dv">20</span>,<span class="at">param=</span>param.basic,<span class="at">cluster=</span><span class="st">&#39;Temporal&#39;</span>,<span class="at">ncpus=</span><span class="dv">8</span>)</span></code></pre></div>
<p>Let us now plot the resulting estimates:</p>
<div class="sourceCode" id="cb377"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb377-1"><a href="cluster.html#cb377-1" aria-hidden="true" tabindex="-1"></a><span class="co"># prepapring data</span></span>
<span id="cb377-2"><a href="cluster.html#cb377-2" aria-hidden="true" tabindex="-1"></a>sf.simuls.Cluster.DID.Temporal.grid.rho <span class="ot">&lt;-</span> sf.simuls.Cluster.DID.Temporal.grid.rho <span class="sc">%&gt;%</span></span>
<span id="cb377-3"><a href="cluster.html#cb377-3" aria-hidden="true" tabindex="-1"></a>                                    <span class="fu">mutate</span>(</span>
<span id="cb377-4"><a href="cluster.html#cb377-4" aria-hidden="true" tabindex="-1"></a>                                      <span class="at">TimeToTreatment =</span> <span class="fu">case_when</span>(</span>
<span id="cb377-5"><a href="cluster.html#cb377-5" aria-hidden="true" tabindex="-1"></a>                                        TimeToTreatment <span class="sc">==</span> <span class="st">&quot;99&quot;</span> <span class="sc">~</span> <span class="dv">21</span>,</span>
<span id="cb377-6"><a href="cluster.html#cb377-6" aria-hidden="true" tabindex="-1"></a>                                        <span class="cn">TRUE</span> <span class="sc">~</span> TimeToTreatment</span>
<span id="cb377-7"><a href="cluster.html#cb377-7" aria-hidden="true" tabindex="-1"></a>                                      ),</span>
<span id="cb377-8"><a href="cluster.html#cb377-8" aria-hidden="true" tabindex="-1"></a>                                      <span class="at">Rho =</span> <span class="fu">factor</span>(Rho,<span class="at">levels=</span><span class="fu">as.character</span>(grid.rho.test))</span>
<span id="cb377-9"><a href="cluster.html#cb377-9" aria-hidden="true" tabindex="-1"></a>                                    ) <span class="sc">%&gt;%</span></span>
<span id="cb377-10"><a href="cluster.html#cb377-10" aria-hidden="true" tabindex="-1"></a>                                    <span class="fu">pivot_longer</span>(<span class="at">cols=</span>SdTE<span class="sc">:</span>MeanSeTE,<span class="at">names_to =</span> <span class="st">&quot;Type&quot;</span>,<span class="at">values_to=</span><span class="st">&quot;SeEstim&quot;</span>) <span class="sc">%&gt;%</span></span>
<span id="cb377-11"><a href="cluster.html#cb377-11" aria-hidden="true" tabindex="-1"></a>                                    <span class="fu">mutate</span>(</span>
<span id="cb377-12"><a href="cluster.html#cb377-12" aria-hidden="true" tabindex="-1"></a>                                      <span class="at">Type =</span> <span class="fu">case_when</span>(</span>
<span id="cb377-13"><a href="cluster.html#cb377-13" aria-hidden="true" tabindex="-1"></a>                                        Type <span class="sc">==</span> <span class="st">&quot;MeanSeTE&quot;</span> <span class="sc">~</span> <span class="st">&quot;Estimated&quot;</span>,</span>
<span id="cb377-14"><a href="cluster.html#cb377-14" aria-hidden="true" tabindex="-1"></a>                                        Type <span class="sc">==</span> <span class="st">&quot;SdTE&quot;</span> <span class="sc">~</span> <span class="st">&quot;Truth&quot;</span>,</span>
<span id="cb377-15"><a href="cluster.html#cb377-15" aria-hidden="true" tabindex="-1"></a>                                        <span class="cn">TRUE</span> <span class="sc">~</span> <span class="st">&quot;&quot;</span></span>
<span id="cb377-16"><a href="cluster.html#cb377-16" aria-hidden="true" tabindex="-1"></a>                                      ),</span>
<span id="cb377-17"><a href="cluster.html#cb377-17" aria-hidden="true" tabindex="-1"></a>                                      <span class="at">Type =</span> <span class="fu">factor</span>(Type,<span class="at">levels=</span><span class="fu">c</span>(<span class="st">&quot;Truth&quot;</span>,<span class="st">&quot;Estimated&quot;</span>))</span>
<span id="cb377-18"><a href="cluster.html#cb377-18" aria-hidden="true" tabindex="-1"></a>                                    ) <span class="co">#%&gt;%</span></span>
<span id="cb377-19"><a href="cluster.html#cb377-19" aria-hidden="true" tabindex="-1"></a>                                    <span class="co">#pivot_wider(names_from = &quot;Method&quot;,values_from = c(&#39;TE&#39;,&#39;SeEstim&#39;))</span></span>
<span id="cb377-20"><a href="cluster.html#cb377-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb377-21"><a href="cluster.html#cb377-21" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(sf.simuls.Cluster.DID.Temporal.grid.rho <span class="sc">%&gt;%</span> <span class="fu">filter</span>(Rho<span class="sc">==</span><span class="dv">0</span>),<span class="fu">aes</span>(<span class="at">x=</span>TimeToTreatment,<span class="at">y=</span>TE,<span class="at">group=</span>Type,<span class="at">color=</span>Type))<span class="sc">+</span></span>
<span id="cb377-22"><a href="cluster.html#cb377-22" aria-hidden="true" tabindex="-1"></a><span class="co">#  geom_pointrange(aes(ymin=TE-1.96*SeEstim,ymax=TE+1.96*SeEstim),position=position_dodge(1))+</span></span>
<span id="cb377-23"><a href="cluster.html#cb377-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">color=</span><span class="st">&#39;red&#39;</span>) <span class="sc">+</span></span>
<span id="cb377-24"><a href="cluster.html#cb377-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_errorbar</span>(<span class="fu">aes</span>(<span class="at">ymin=</span>TE<span class="fl">-1.96</span><span class="sc">*</span>SeEstim,<span class="at">ymax=</span>TE<span class="fl">+1.96</span><span class="sc">*</span>SeEstim,<span class="at">color=</span>Type,<span class="at">group=</span>Type),<span class="at">position=</span><span class="fu">position_dodge</span>(<span class="dv">1</span>),<span class="at">width=</span><span class="fl">0.5</span>)<span class="sc">+</span></span>
<span id="cb377-25"><a href="cluster.html#cb377-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">coord_cartesian</span>(<span class="at">ylim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.15</span>,<span class="fl">0.15</span>))<span class="sc">+</span></span>
<span id="cb377-26"><a href="cluster.html#cb377-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_color_discrete</span>(<span class="at">name=</span><span class="st">&#39;Rho=0&#39;</span>)<span class="sc">+</span></span>
<span id="cb377-27"><a href="cluster.html#cb377-27" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()<span class="sc">+</span></span>
<span id="cb377-28"><a href="cluster.html#cb377-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(Method<span class="sc">~</span>.) </span>
<span id="cb377-29"><a href="cluster.html#cb377-29" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(sf.simuls.Cluster.DID.Temporal.grid.rho <span class="sc">%&gt;%</span> <span class="fu">filter</span>(Rho<span class="sc">==</span><span class="fl">0.5</span>),<span class="fu">aes</span>(<span class="at">x=</span>TimeToTreatment,<span class="at">y=</span>TE,<span class="at">group=</span>Type,<span class="at">color=</span>Type))<span class="sc">+</span></span>
<span id="cb377-30"><a href="cluster.html#cb377-30" aria-hidden="true" tabindex="-1"></a><span class="co">#  geom_pointrange(aes(ymin=TE-1.96*SeEstim,ymax=TE+1.96*SeEstim),position=position_dodge(1))+</span></span>
<span id="cb377-31"><a href="cluster.html#cb377-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">color=</span><span class="st">&#39;red&#39;</span>) <span class="sc">+</span></span>
<span id="cb377-32"><a href="cluster.html#cb377-32" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_errorbar</span>(<span class="fu">aes</span>(<span class="at">ymin=</span>TE<span class="fl">-1.96</span><span class="sc">*</span>SeEstim,<span class="at">ymax=</span>TE<span class="fl">+1.96</span><span class="sc">*</span>SeEstim,<span class="at">color=</span>Type,<span class="at">group=</span>Type),<span class="at">position=</span><span class="fu">position_dodge</span>(<span class="dv">1</span>),<span class="at">width=</span><span class="fl">0.5</span>)<span class="sc">+</span></span>
<span id="cb377-33"><a href="cluster.html#cb377-33" aria-hidden="true" tabindex="-1"></a>  <span class="fu">coord_cartesian</span>(<span class="at">ylim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.15</span>,<span class="fl">0.15</span>))<span class="sc">+</span></span>
<span id="cb377-34"><a href="cluster.html#cb377-34" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_color_discrete</span>(<span class="at">name=</span><span class="st">&#39;Rho=0.5&#39;</span>)<span class="sc">+</span></span>
<span id="cb377-35"><a href="cluster.html#cb377-35" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()<span class="sc">+</span></span>
<span id="cb377-36"><a href="cluster.html#cb377-36" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(Method<span class="sc">~</span>.) </span>
<span id="cb377-37"><a href="cluster.html#cb377-37" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(sf.simuls.Cluster.DID.Temporal.grid.rho <span class="sc">%&gt;%</span> <span class="fu">filter</span>(Rho<span class="sc">==</span><span class="fl">0.9</span>),<span class="fu">aes</span>(<span class="at">x=</span>TimeToTreatment,<span class="at">y=</span>TE,<span class="at">group=</span>Type,<span class="at">color=</span>Type))<span class="sc">+</span></span>
<span id="cb377-38"><a href="cluster.html#cb377-38" aria-hidden="true" tabindex="-1"></a><span class="co">#  geom_pointrange(aes(ymin=TE-1.96*SeEstim,ymax=TE+1.96*SeEstim),position=position_dodge(1))+</span></span>
<span id="cb377-39"><a href="cluster.html#cb377-39" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">color=</span><span class="st">&#39;red&#39;</span>) <span class="sc">+</span></span>
<span id="cb377-40"><a href="cluster.html#cb377-40" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_errorbar</span>(<span class="fu">aes</span>(<span class="at">ymin=</span>TE<span class="fl">-1.96</span><span class="sc">*</span>SeEstim,<span class="at">ymax=</span>TE<span class="fl">+1.96</span><span class="sc">*</span>SeEstim,<span class="at">color=</span>Type,<span class="at">group=</span>Type),<span class="at">position=</span><span class="fu">position_dodge</span>(<span class="dv">1</span>),<span class="at">width=</span><span class="fl">0.5</span>)<span class="sc">+</span></span>
<span id="cb377-41"><a href="cluster.html#cb377-41" aria-hidden="true" tabindex="-1"></a>  <span class="fu">coord_cartesian</span>(<span class="at">ylim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.15</span>,<span class="fl">0.15</span>))<span class="sc">+</span></span>
<span id="cb377-42"><a href="cluster.html#cb377-42" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_color_discrete</span>(<span class="at">name=</span><span class="st">&#39;Rho=0.9&#39;</span>)<span class="sc">+</span></span>
<span id="cb377-43"><a href="cluster.html#cb377-43" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()<span class="sc">+</span></span>
<span id="cb377-44"><a href="cluster.html#cb377-44" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(Method<span class="sc">~</span>.) </span>
<span id="cb377-45"><a href="cluster.html#cb377-45" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(sf.simuls.Cluster.DID.Temporal.grid.rho <span class="sc">%&gt;%</span> <span class="fu">filter</span>(Rho<span class="sc">==</span><span class="fl">0.99</span>),<span class="fu">aes</span>(<span class="at">x=</span>TimeToTreatment,<span class="at">y=</span>TE,<span class="at">group=</span>Type,<span class="at">color=</span>Type))<span class="sc">+</span></span>
<span id="cb377-46"><a href="cluster.html#cb377-46" aria-hidden="true" tabindex="-1"></a><span class="co">#  geom_pointrange(aes(ymin=TE-1.96*SeEstim,ymax=TE+1.96*SeEstim),position=position_dodge(1))+</span></span>
<span id="cb377-47"><a href="cluster.html#cb377-47" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">color=</span><span class="st">&#39;red&#39;</span>) <span class="sc">+</span></span>
<span id="cb377-48"><a href="cluster.html#cb377-48" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_errorbar</span>(<span class="fu">aes</span>(<span class="at">ymin=</span>TE<span class="fl">-1.96</span><span class="sc">*</span>SeEstim,<span class="at">ymax=</span>TE<span class="fl">+1.96</span><span class="sc">*</span>SeEstim,<span class="at">color=</span>Type,<span class="at">group=</span>Type),<span class="at">position=</span><span class="fu">position_dodge</span>(<span class="dv">1</span>),<span class="at">width=</span><span class="fl">0.5</span>)<span class="sc">+</span></span>
<span id="cb377-49"><a href="cluster.html#cb377-49" aria-hidden="true" tabindex="-1"></a>  <span class="fu">coord_cartesian</span>(<span class="at">ylim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.15</span>,<span class="fl">0.15</span>))<span class="sc">+</span></span>
<span id="cb377-50"><a href="cluster.html#cb377-50" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_color_discrete</span>(<span class="at">name=</span><span class="st">&#39;Rho=0.99&#39;</span>)<span class="sc">+</span></span>
<span id="cb377-51"><a href="cluster.html#cb377-51" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()<span class="sc">+</span></span>
<span id="cb377-52"><a href="cluster.html#cb377-52" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(Method<span class="sc">~</span>.) </span>
<span id="cb377-53"><a href="cluster.html#cb377-53" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(sf.simuls.Cluster.DID.Temporal.grid.rho <span class="sc">%&gt;%</span> <span class="fu">filter</span>(Rho<span class="sc">==</span><span class="dv">1</span>),<span class="fu">aes</span>(<span class="at">x=</span>TimeToTreatment,<span class="at">y=</span>TE,<span class="at">group=</span>Type,<span class="at">color=</span>Type))<span class="sc">+</span></span>
<span id="cb377-54"><a href="cluster.html#cb377-54" aria-hidden="true" tabindex="-1"></a><span class="co">#  geom_pointrange(aes(ymin=TE-1.96*SeEstim,ymax=TE+1.96*SeEstim),position=position_dodge(1))+</span></span>
<span id="cb377-55"><a href="cluster.html#cb377-55" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">color=</span><span class="st">&#39;red&#39;</span>) <span class="sc">+</span></span>
<span id="cb377-56"><a href="cluster.html#cb377-56" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_errorbar</span>(<span class="fu">aes</span>(<span class="at">ymin=</span>TE<span class="fl">-1.96</span><span class="sc">*</span>SeEstim,<span class="at">ymax=</span>TE<span class="fl">+1.96</span><span class="sc">*</span>SeEstim,<span class="at">color=</span>Type,<span class="at">group=</span>Type),<span class="at">position=</span><span class="fu">position_dodge</span>(<span class="dv">1</span>),<span class="at">width=</span><span class="fl">0.5</span>)<span class="sc">+</span></span>
<span id="cb377-57"><a href="cluster.html#cb377-57" aria-hidden="true" tabindex="-1"></a>  <span class="fu">coord_cartesian</span>(<span class="at">ylim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.15</span>,<span class="fl">0.15</span>))<span class="sc">+</span></span>
<span id="cb377-58"><a href="cluster.html#cb377-58" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_color_discrete</span>(<span class="at">name=</span><span class="st">&#39;Rho=1&#39;</span>)<span class="sc">+</span></span>
<span id="cb377-59"><a href="cluster.html#cb377-59" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()<span class="sc">+</span></span>
<span id="cb377-60"><a href="cluster.html#cb377-60" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(Method<span class="sc">~</span>.) </span>
<span id="cb377-61"><a href="cluster.html#cb377-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb377-62"><a href="cluster.html#cb377-62" aria-hidden="true" tabindex="-1"></a><span class="co"># ggplot(sf.simuls.Cluster.DID.grid.rho,aes(x=TimeToTreatment,y=TE_FD,group=Type,color=Type))+</span></span>
<span id="cb377-63"><a href="cluster.html#cb377-63" aria-hidden="true" tabindex="-1"></a><span class="co"># #  geom_pointrange(aes(ymin=TE-1.96*SeEstim,ymax=TE+1.96*SeEstim),position=position_dodge(1))+</span></span>
<span id="cb377-64"><a href="cluster.html#cb377-64" aria-hidden="true" tabindex="-1"></a><span class="co">#   geom_point(color=&#39;red&#39;) +</span></span>
<span id="cb377-65"><a href="cluster.html#cb377-65" aria-hidden="true" tabindex="-1"></a><span class="co">#   geom_errorbar(aes(ymin=TE_FD-1.96*SeEstim_FD,ymax=TE_FD+1.96*SeEstim_FD,color=Type,group=Type),position=position_dodge(1),width=0.2)+</span></span>
<span id="cb377-66"><a href="cluster.html#cb377-66" aria-hidden="true" tabindex="-1"></a><span class="co">#   geom_errorbar(aes(ymin=TE_SA-1.96*SeEstim_SA,ymax=TE_SA+1.96*SeEstim_SA,color=Type,group=Type),position=position_dodge(1),width=0.5)+</span></span>
<span id="cb377-67"><a href="cluster.html#cb377-67" aria-hidden="true" tabindex="-1"></a><span class="co">#   geom_errorbar(aes(ymin=TE_StackedFD-1.96*SeEstim_StackedFD,ymax=TE_StackedFD+1.96*SeEstim_StackedFD,color=Type,group=Type),position=position_dodge(1),width=0.9)+</span></span>
<span id="cb377-68"><a href="cluster.html#cb377-68" aria-hidden="true" tabindex="-1"></a><span class="co">#   theme_bw()+</span></span>
<span id="cb377-69"><a href="cluster.html#cb377-69" aria-hidden="true" tabindex="-1"></a><span class="co">#   facet_grid(Rho~.)</span></span></code></pre></div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:ModelSimpleParClusteredPlot"></span>
<img src="STCI_files/figure-html/ModelSimpleParClusteredPlot-1.png" alt="Clustered DID estimates of sampling noise with increasing temporal autocorrelation in outcomes" width="75%" /><img src="STCI_files/figure-html/ModelSimpleParClusteredPlot-2.png" alt="Clustered DID estimates of sampling noise with increasing temporal autocorrelation in outcomes" width="75%" /><img src="STCI_files/figure-html/ModelSimpleParClusteredPlot-3.png" alt="Clustered DID estimates of sampling noise with increasing temporal autocorrelation in outcomes" width="75%" /><img src="STCI_files/figure-html/ModelSimpleParClusteredPlot-4.png" alt="Clustered DID estimates of sampling noise with increasing temporal autocorrelation in outcomes" width="75%" /><img src="STCI_files/figure-html/ModelSimpleParClusteredPlot-5.png" alt="Clustered DID estimates of sampling noise with increasing temporal autocorrelation in outcomes" width="75%" />
<p class="caption">
Figure 9.6: Clustered DID estimates of sampling noise with increasing temporal autocorrelation in outcomes
</p>
</div>
<p>Two results appear clearly on Figure <a href="cluster.html#fig:ModelSimpleParClusteredPlot">9.6</a>:</p>
<ol style="list-style-type: decimal">
<li>The estimates of sampling noise for the ATT are now correct both with the Sun and Abraham estimator implemented with <code>fixest</code> and the <code>cluster</code> option and with the Stacked First Difference estimator implemented with the Leung covariance matric estimator.
It even seems that the estimates of sampling noise are slightly too large with respect to the results of the simulations, but overall, the result is pretty good.</li>
<li>The estimates of sampling noise for the individual <span class="math inline">\(2\times 2\)</span> DID estimates estimated with the Sun and Abraham estimator implemented with <code>fixest</code> and the <code>cluster</code> option have now a correct estimate of sampling noise.
The <code>cluster</code> option is here critical to take into account the fact that the error terms that belong to the same unit observed at different time periods are negatively autocorrelated.
We should therefore always use the the <code>cluster</code> option when using the Sun and Abraham estimator implemented with <code>fixest</code>.</li>
</ol>
</div>
<div id="using-the-bootstrap-1" class="section level4 hasAnchor" number="9.2.3.4">
<h4><span class="header-section-number">9.2.3.4</span> Using the Bootstrap<a href="cluster.html#using-the-bootstrap-1" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>The bootstrap can be used exactly in the same way as we have seen for clustering in RCTs in Section <a href="cluster.html#ClusterRCT">9.1</a>.
The only difference is that clusters here are units and therefore one samples with replacement among units, and includes all the observations of the same unit over time when it has been sampled.
Implementation is left as an exercise.</p>
</div>
<div id="using-randomization-inference-1" class="section level4 hasAnchor" number="9.2.3.5">
<h4><span class="header-section-number">9.2.3.5</span> Using Randomization Inference<a href="cluster.html#using-randomization-inference-1" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Similarly as in Section <a href="cluster.html#ClusterRCT">9.1</a>, we can also use randomization inference.
We again have to build potential outcomes under the assumed null, both before and after the various treatment dates, and to allocate the treatment date at random across units, among the dates that actually exist in the sample, respecting their actual proportions.
Implementation is left as an exercise.</p>
</div>
</div>
</div>
<div id="spatial-correlation" class="section level2 hasAnchor" number="9.3">
<h2><span class="header-section-number">9.3</span> Spatial correlation<a href="cluster.html#spatial-correlation" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Clusters are a very peculiar form of autocorrelation: it is identical for all members of the cluster and stops abruptly at the border of the cluster.
Sometimes, the treatment and the outcomes of interest are correlated across units in a less crude way than through clusters.
For example, it might very well be that observations are correlated more smoothly across space, such as for example neighboring observations, that is observations that are close in space, sharing unobserved influences both for their outcomes and for their treatment status.
Does this smoother form of spatial autocorrelation matter for sampling noise?
Do we have to adapt our estimators of sampling noise accordingly?
If yes, when and how?
These are the questions we are going to examine here.</p>
<div id="an-example-2" class="section level3 hasAnchor" number="9.3.1">
<h3><span class="header-section-number">9.3.1</span> An example<a href="cluster.html#an-example-2" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>We are going to generate data with spatially autocorrelated error terms.
We are going to denote <span class="math inline">\(W\)</span> our matrix of spatial influence.
<span class="math inline">\(W\)</span> is a square matrix of size <span class="math inline">\(N\times N\)</span>, where <span class="math inline">\(N\)</span> is sample size.
Row <span class="math inline">\(i\)</span> of <span class="math inline">\(W\)</span> is a vector of weights <span class="math inline">\(w_{i,j}\)</span> between zero and one, which sum to one (<span class="math inline">\(\sum_{j=1}^Nw_{i,j}=1\)</span>), and which correspond to the influence each observation <span class="math inline">\(j\)</span> has on observation <span class="math inline">\(i\)</span>.
<span class="math inline">\(W\)</span> has a diagonal of zeroes, since each observation does not influence itself.
We can thus write, in matrix form:</p>
<p><span class="math display">\[\begin{align*}
  U &amp; = \rho WU + \epsilon
\end{align*}\]</span></p>
<p>where <span class="math inline">\(U\)</span> is the vector of all autocorrelated error terms for all <span class="math inline">\(N\)</span> observations and <span class="math inline">\(\epsilon\)</span> is an i.i.d. random vector of the same size.
In order to build <span class="math inline">\(U\)</span>, we can make use of the fact that:</p>
<p><span class="math display">\[\begin{align*}
  U &amp; = (I_N-\rho W)^{-1}\epsilon,
\end{align*}\]</span></p>
<p>where <span class="math inline">\(I_N\)</span> is the identity matrix of size <span class="math inline">\(N\)</span>.
For assignment to the treatment, we are going to use an independent set of random variables that exhibits the same pattern of spatial autocorrelation:</p>
<p><span class="math display">\[\begin{align*}
  V &amp; = (I_N-\rho W)^{-1}\eta\\
  D_i &amp; = \uns{V_i\geq0}, 
\end{align*}\]</span></p>
<p>where <span class="math inline">\(\eta\)</span> is a vector of i.i.d. shocks independent from <span class="math inline">\(\epsilon\)</span>.</p>
<p>In order to generate this spatial process, we first need spatial data.
For that, we are going to draw coordinates randomly in latitudes and longitudes, and define distances among the resulting points.
I’m going to choose points within the French territory, between 46 and 49 degress of latitude and 0 and 3 degrees of longitude.
I’m using the <code>sf</code> package to then convert these coordinates to a map.</p>
<div class="sourceCode" id="cb378"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb378-1"><a href="cluster.html#cb378-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">12345</span>)</span>
<span id="cb378-2"><a href="cluster.html#cb378-2" aria-hidden="true" tabindex="-1"></a>SpatialData <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">id=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">1000</span>,<span class="at">latitude=</span><span class="fu">runif</span>(<span class="dv">1000</span>,<span class="fl">49.8</span>,<span class="dv">51</span>),<span class="at">longitude=</span><span class="fu">runif</span>(<span class="dv">1000</span>,<span class="fl">1.8</span>,<span class="fl">2.8</span>)) <span class="sc">%&gt;%</span></span>
<span id="cb378-3"><a href="cluster.html#cb378-3" aria-hidden="true" tabindex="-1"></a>        <span class="fu">st_as_sf</span>(.,<span class="at">coords=</span><span class="fu">c</span>(<span class="st">&#39;longitude&#39;</span>,<span class="st">&#39;latitude&#39;</span>),<span class="at">crs=</span><span class="dv">4326</span>) </span>
<span id="cb378-4"><a href="cluster.html#cb378-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb378-5"><a href="cluster.html#cb378-5" aria-hidden="true" tabindex="-1"></a><span class="co"># extracting coordinates from `sf` object for later uses</span></span>
<span id="cb378-6"><a href="cluster.html#cb378-6" aria-hidden="true" tabindex="-1"></a>SpatialData <span class="ot">&lt;-</span>SpatialData <span class="sc">%&gt;%</span></span>
<span id="cb378-7"><a href="cluster.html#cb378-7" aria-hidden="true" tabindex="-1"></a>        <span class="fu">mutate</span>(</span>
<span id="cb378-8"><a href="cluster.html#cb378-8" aria-hidden="true" tabindex="-1"></a>          <span class="at">latitude =</span> <span class="fu">st_coordinates</span>(SpatialData)[,<span class="dv">2</span>],</span>
<span id="cb378-9"><a href="cluster.html#cb378-9" aria-hidden="true" tabindex="-1"></a>          <span class="at">longitude =</span> <span class="fu">st_coordinates</span>(SpatialData)[,<span class="dv">1</span>]</span>
<span id="cb378-10"><a href="cluster.html#cb378-10" aria-hidden="true" tabindex="-1"></a>        )</span></code></pre></div>
<p>Let us plot these data:</p>
<div class="sourceCode" id="cb379"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb379-1"><a href="cluster.html#cb379-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Map of France</span></span>
<span id="cb379-2"><a href="cluster.html#cb379-2" aria-hidden="true" tabindex="-1"></a>FranceMap <span class="ot">&lt;-</span> <span class="fu">st_as_sf</span>(maps<span class="sc">::</span><span class="fu">map</span>(<span class="st">&quot;france&quot;</span>,<span class="at">plot=</span><span class="cn">FALSE</span>,<span class="at">fill=</span><span class="cn">TRUE</span>,<span class="at">crs=</span><span class="dv">4326</span>))</span>
<span id="cb379-3"><a href="cluster.html#cb379-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb379-4"><a href="cluster.html#cb379-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Map</span></span>
<span id="cb379-5"><a href="cluster.html#cb379-5" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(<span class="at">data=</span>FranceMap,<span class="at">fill=</span><span class="st">&quot;transparent&quot;</span>) <span class="sc">+</span></span>
<span id="cb379-6"><a href="cluster.html#cb379-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_sf</span>(<span class="at">fill=</span><span class="st">&quot;transparent&quot;</span>)<span class="sc">+</span></span>
<span id="cb379-7"><a href="cluster.html#cb379-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_sf</span>(<span class="at">data=</span>SpatialData)<span class="sc">+</span></span>
<span id="cb379-8"><a href="cluster.html#cb379-8" aria-hidden="true" tabindex="-1"></a><span class="co">#  coord_sf(xlim = c(-5, 8), ylim = c(48,51))+</span></span>
<span id="cb379-9"><a href="cluster.html#cb379-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">coord_sf</span>(<span class="at">xlim =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">3</span>), <span class="at">ylim =</span> <span class="fu">c</span>(<span class="fl">49.5</span>,<span class="dv">51</span>))<span class="sc">+</span></span>
<span id="cb379-10"><a href="cluster.html#cb379-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span></code></pre></div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:SpatialSamplePlot"></span>
<img src="STCI_files/figure-html/SpatialSamplePlot-1.png" alt="Map of our sample points" width="75%" />
<p class="caption">
Figure 9.7: Map of our sample points
</p>
</div>
<p>Let us now compute the distance between all of these points in kilometers:</p>
<div class="sourceCode" id="cb380"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb380-1"><a href="cluster.html#cb380-1" aria-hidden="true" tabindex="-1"></a><span class="co"># dividing by 1000 to have kilometers</span></span>
<span id="cb380-2"><a href="cluster.html#cb380-2" aria-hidden="true" tabindex="-1"></a>DistanceMatrix <span class="ot">&lt;-</span> <span class="fu">st_distance</span>(SpatialData,SpatialData)<span class="sc">/</span><span class="dv">1000</span></span></code></pre></div>
<p>Let us now take 10 kilometers as a boundary to define influence.</p>
<div class="sourceCode" id="cb381"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb381-1"><a href="cluster.html#cb381-1" aria-hidden="true" tabindex="-1"></a><span class="co"># distance (in km)</span></span>
<span id="cb381-2"><a href="cluster.html#cb381-2" aria-hidden="true" tabindex="-1"></a>dist <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="cb381-3"><a href="cluster.html#cb381-3" aria-hidden="true" tabindex="-1"></a><span class="co"># computation of the discrete influence matrix</span></span>
<span id="cb381-4"><a href="cluster.html#cb381-4" aria-hidden="true" tabindex="-1"></a>DistanceMatrixDiscrete <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(DistanceMatrix)</span>
<span id="cb381-5"><a href="cluster.html#cb381-5" aria-hidden="true" tabindex="-1"></a>DistanceMatrixDiscrete[DistanceMatrixDiscrete<span class="sc">&lt;=</span>dist] <span class="ot">&lt;-</span>  <span class="dv">1</span></span>
<span id="cb381-6"><a href="cluster.html#cb381-6" aria-hidden="true" tabindex="-1"></a>DistanceMatrixDiscrete[DistanceMatrixDiscrete<span class="sc">&gt;</span>dist] <span class="ot">&lt;-</span>  <span class="dv">0</span></span>
<span id="cb381-7"><a href="cluster.html#cb381-7" aria-hidden="true" tabindex="-1"></a><span class="co"># the diagonal terms are all zeroes, since we want close neighbors and not egos to be ones</span></span>
<span id="cb381-8"><a href="cluster.html#cb381-8" aria-hidden="true" tabindex="-1"></a>DistanceMatrixDiscrete[<span class="fu">as.numeric</span>(DistanceMatrix)<span class="sc">==</span><span class="dv">0</span>] <span class="ot">&lt;-</span>  <span class="dv">0</span></span>
<span id="cb381-9"><a href="cluster.html#cb381-9" aria-hidden="true" tabindex="-1"></a><span class="co"># forming a sparse matrix</span></span>
<span id="cb381-10"><a href="cluster.html#cb381-10" aria-hidden="true" tabindex="-1"></a>DistanceMatrixDiscrete <span class="ot">&lt;-</span> <span class="fu">Matrix</span>(<span class="at">data=</span>DistanceMatrixDiscrete,<span class="at">nrow=</span><span class="dv">1000</span>,<span class="at">ncol=</span><span class="dv">1000</span>,<span class="at">byrow=</span><span class="cn">TRUE</span>,<span class="at">sparse=</span><span class="cn">TRUE</span>)</span>
<span id="cb381-11"><a href="cluster.html#cb381-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb381-12"><a href="cluster.html#cb381-12" aria-hidden="true" tabindex="-1"></a><span class="co"># for later uses, same but with 20km</span></span>
<span id="cb381-13"><a href="cluster.html#cb381-13" aria-hidden="true" tabindex="-1"></a><span class="co"># distance (in km)</span></span>
<span id="cb381-14"><a href="cluster.html#cb381-14" aria-hidden="true" tabindex="-1"></a>dist <span class="ot">&lt;-</span> <span class="dv">20</span></span>
<span id="cb381-15"><a href="cluster.html#cb381-15" aria-hidden="true" tabindex="-1"></a><span class="co"># computation of the discrete influence matrix</span></span>
<span id="cb381-16"><a href="cluster.html#cb381-16" aria-hidden="true" tabindex="-1"></a>DistanceMatrixDiscrete20 <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(DistanceMatrix)</span>
<span id="cb381-17"><a href="cluster.html#cb381-17" aria-hidden="true" tabindex="-1"></a>DistanceMatrixDiscrete20[DistanceMatrixDiscrete20<span class="sc">&lt;=</span>dist] <span class="ot">&lt;-</span>  <span class="dv">1</span></span>
<span id="cb381-18"><a href="cluster.html#cb381-18" aria-hidden="true" tabindex="-1"></a>DistanceMatrixDiscrete20[DistanceMatrixDiscrete20<span class="sc">&gt;</span>dist] <span class="ot">&lt;-</span>  <span class="dv">0</span></span>
<span id="cb381-19"><a href="cluster.html#cb381-19" aria-hidden="true" tabindex="-1"></a><span class="co"># the diagonal terms are all zeroes, since we want close neighbors and not egos to be ones</span></span>
<span id="cb381-20"><a href="cluster.html#cb381-20" aria-hidden="true" tabindex="-1"></a>DistanceMatrixDiscrete20[<span class="fu">as.numeric</span>(DistanceMatrix)<span class="sc">==</span><span class="dv">0</span>] <span class="ot">&lt;-</span>  <span class="dv">0</span></span>
<span id="cb381-21"><a href="cluster.html#cb381-21" aria-hidden="true" tabindex="-1"></a><span class="co"># forming a sparse matrix</span></span>
<span id="cb381-22"><a href="cluster.html#cb381-22" aria-hidden="true" tabindex="-1"></a>DistanceMatrixDiscrete20 <span class="ot">&lt;-</span> <span class="fu">Matrix</span>(<span class="at">data=</span>DistanceMatrixDiscrete20,<span class="at">nrow=</span><span class="dv">1000</span>,<span class="at">ncol=</span><span class="dv">1000</span>,<span class="at">byrow=</span><span class="cn">TRUE</span>,<span class="at">sparse=</span><span class="cn">TRUE</span>)</span></code></pre></div>
<p>Let us now compute the sum of the entries in each row, and divide each row by this sum, to normalize each neighbor by the number of neighbors and obtain weights that sum to one in each row.</p>
<div class="sourceCode" id="cb382"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb382-1"><a href="cluster.html#cb382-1" aria-hidden="true" tabindex="-1"></a>DistanceMatrixDiscreteRowSum <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">/</span><span class="fu">rowSums</span>(DistanceMatrixDiscrete)</span>
<span id="cb382-2"><a href="cluster.html#cb382-2" aria-hidden="true" tabindex="-1"></a>DistanceMatrixDiscreteWeights <span class="ot">&lt;-</span> DistanceMatrixDiscreteRowSum<span class="sc">*</span>DistanceMatrixDiscrete</span>
<span id="cb382-3"><a href="cluster.html#cb382-3" aria-hidden="true" tabindex="-1"></a><span class="co"># same with 20 km for later uses</span></span>
<span id="cb382-4"><a href="cluster.html#cb382-4" aria-hidden="true" tabindex="-1"></a>DistanceMatrixDiscreteRowSum20 <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">/</span><span class="fu">rowSums</span>(DistanceMatrixDiscrete20)</span>
<span id="cb382-5"><a href="cluster.html#cb382-5" aria-hidden="true" tabindex="-1"></a>DistanceMatrixDiscreteWeights20 <span class="ot">&lt;-</span> DistanceMatrixDiscreteRowSum20<span class="sc">*</span>DistanceMatrixDiscrete20</span></code></pre></div>
<p>Now, in order to compute autocorrelated error terms from i.i.d. errors, we need to form the matrix <span class="math inline">\((I_N-\rho W)^{-1}\)</span>, where <span class="math inline">\(I_N\)</span> is the identity matrix of size <span class="math inline">\(N\)</span> and <span class="math inline">\(W\)</span> our spatial influence matrix with rows summing to one, and <span class="math inline">\(\rho\)</span> the spatial autocorrelation coefficient.</p>
<div class="sourceCode" id="cb383"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb383-1"><a href="cluster.html#cb383-1" aria-hidden="true" tabindex="-1"></a>SpatialInfluenceMatrix <span class="ot">&lt;-</span> <span class="fu">solve</span>(<span class="fu">Diagonal</span>(<span class="dv">1000</span>)<span class="sc">-</span>param[<span class="st">&#39;rho&#39;</span>]<span class="sc">*</span>DistanceMatrixDiscreteWeights)</span></code></pre></div>
<p>Let us finally generate our autocorrelated error terms <span class="math inline">\(U=(I_N-\rho W)^{-1}\epsilon\)</span>, where <span class="math inline">\(\epsilon\)</span> is a vector of i.i.d. shocks:</p>
<div class="sourceCode" id="cb384"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb384-1"><a href="cluster.html#cb384-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1234</span>)</span>
<span id="cb384-2"><a href="cluster.html#cb384-2" aria-hidden="true" tabindex="-1"></a>epsilon <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="at">n=</span><span class="dv">1000</span>,<span class="at">mean=</span><span class="dv">0</span>,<span class="at">sd=</span><span class="fu">sqrt</span>(param[<span class="st">&#39;sigma2epsilon&#39;</span>]))</span>
<span id="cb384-3"><a href="cluster.html#cb384-3" aria-hidden="true" tabindex="-1"></a>U <span class="ot">&lt;-</span> SpatialInfluenceMatrix<span class="sc">%*%</span>epsilon</span>
<span id="cb384-4"><a href="cluster.html#cb384-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Spatially lagged error term</span></span>
<span id="cb384-5"><a href="cluster.html#cb384-5" aria-hidden="true" tabindex="-1"></a>SLU <span class="ot">&lt;-</span> DistanceMatrixDiscreteWeights<span class="sc">%*%</span>U</span></code></pre></div>
<p>Let us now compute the spatial autocorrelation among the error terms in this dataset.
This is done using Moran’s <span class="math inline">\(I\)</span> statistic, which is <a href="https://r-spatial.org/book/15-Measures.html">defined</a> <a href="https://www.insee.fr/en/statistiques/fichier/3635545/imet131-g-chapitre-3.pdf">as</a> <a href="https://bookdown.org/lexcomber/brunsdoncomber2e/morans-i-an-index-of-autocorrelation.html">follows</a>:</p>
<p><span class="math display">\[\begin{align*}
  I &amp; = \frac{N\sum_i\sum{j\neq i}w_{i,j}(x_i-\bar{x})(x_j-\bar{x})}{\sum_i\sum{j\neq i}w_{i,j}\sum_i\sum{i\neq j}(x_i-\bar{x})^2},
\end{align*}\]</span></p>
<p>where <span class="math inline">\(w_{i,j}\)</span> is the element of the <span class="math inline">\(i\)</span> line and the <span class="math inline">\(j\)</span> column in the spatial weighting matrix <span class="math inline">\(W\)</span>.
Moran’s <span class="math inline">\(I\)</span> is the correlation between <span class="math inline">\(x_i\)</span> and its spatially lagged value.
As a result, it can be estimated using OLS and it can be represented as a matrix product, when the <span class="math inline">\(W\)</span> matrix is row normalised:</p>
<p><span class="math display">\[\begin{align*}
  I &amp; = \frac{z&#39;Wz}{z&#39;z},
\end{align*}\]</span></p>
<p>where <span class="math inline">\(z\)</span> is the vector of all observations <span class="math inline">\(x_i-\bar{x}\)</span>.
Let us first look at the correlation between <span class="math inline">\(U\)</span> and its spatially lagged values <span class="math inline">\(WU\)</span>:</p>
<div class="sourceCode" id="cb385"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb385-1"><a href="cluster.html#cb385-1" aria-hidden="true" tabindex="-1"></a><span class="co"># preparing data</span></span>
<span id="cb385-2"><a href="cluster.html#cb385-2" aria-hidden="true" tabindex="-1"></a>SpatialData<span class="sc">$</span>U <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(U)</span>
<span id="cb385-3"><a href="cluster.html#cb385-3" aria-hidden="true" tabindex="-1"></a>SpatialData<span class="sc">$</span>SLU <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(SLU)</span>
<span id="cb385-4"><a href="cluster.html#cb385-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb385-5"><a href="cluster.html#cb385-5" aria-hidden="true" tabindex="-1"></a><span class="co"># plot</span></span>
<span id="cb385-6"><a href="cluster.html#cb385-6" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(SpatialData,<span class="fu">aes</span>(U,SLU)) <span class="sc">+</span></span>
<span id="cb385-7"><a href="cluster.html#cb385-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb385-8"><a href="cluster.html#cb385-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_smooth</span>(<span class="at">method=</span><span class="st">&#39;lm&#39;</span>) <span class="sc">+</span></span>
<span id="cb385-9"><a href="cluster.html#cb385-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span></code></pre></div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:MoranPlot"></span>
<img src="STCI_files/figure-html/MoranPlot-1.png" alt="Moran's plot" width="65%" />
<p class="caption">
Figure 9.8: Moran’s plot
</p>
</div>
<p>Let us now compute Moran’s <span class="math inline">\(I\)</span>:</p>
<div class="sourceCode" id="cb386"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb386-1"><a href="cluster.html#cb386-1" aria-hidden="true" tabindex="-1"></a><span class="co"># using regression</span></span>
<span id="cb386-2"><a href="cluster.html#cb386-2" aria-hidden="true" tabindex="-1"></a>MoranReg <span class="ot">&lt;-</span> <span class="fu">lm</span>(SLU<span class="sc">~-</span><span class="dv">1</span><span class="sc">+</span>U,<span class="at">data=</span>SpatialData)</span>
<span id="cb386-3"><a href="cluster.html#cb386-3" aria-hidden="true" tabindex="-1"></a><span class="co"># using matrix notation</span></span>
<span id="cb386-4"><a href="cluster.html#cb386-4" aria-hidden="true" tabindex="-1"></a>MoranMat <span class="ot">&lt;-</span> (<span class="fu">t</span>(U)<span class="sc">%*%</span>DistanceMatrixDiscreteWeights<span class="sc">%*%</span>U)<span class="sc">/</span>(<span class="fu">t</span>(U)<span class="sc">%*%</span>U)</span></code></pre></div>
<p>In this data, Moran’s <span class="math inline">\(I\)</span> is equal to 0.35, which is testament to non-trivial spatial autocorrelation.
Let us now simulate a process allocating a binary treatment randomly, but with a process that is going to be spatially correlated with the same contiguity matrix as the one used for <span class="math inline">\(U\)</span>:</p>
<div class="sourceCode" id="cb387"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb387-1"><a href="cluster.html#cb387-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">12345</span>)</span>
<span id="cb387-2"><a href="cluster.html#cb387-2" aria-hidden="true" tabindex="-1"></a>eta <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="at">n=</span><span class="dv">1000</span>,<span class="at">mean=</span><span class="dv">0</span>,<span class="at">sd=</span><span class="fu">sqrt</span>(param[<span class="st">&#39;sigma2epsilon&#39;</span>]))</span>
<span id="cb387-3"><a href="cluster.html#cb387-3" aria-hidden="true" tabindex="-1"></a>SpatialData<span class="sc">$</span>SpatialEta <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(SpatialInfluenceMatrix<span class="sc">%*%</span>eta)</span>
<span id="cb387-4"><a href="cluster.html#cb387-4" aria-hidden="true" tabindex="-1"></a><span class="co"># allocating the treatment</span></span>
<span id="cb387-5"><a href="cluster.html#cb387-5" aria-hidden="true" tabindex="-1"></a>SpatialData <span class="ot">&lt;-</span> SpatialData <span class="sc">%&gt;%</span></span>
<span id="cb387-6"><a href="cluster.html#cb387-6" aria-hidden="true" tabindex="-1"></a>          <span class="fu">mutate</span>(</span>
<span id="cb387-7"><a href="cluster.html#cb387-7" aria-hidden="true" tabindex="-1"></a>            <span class="at">Ds =</span> <span class="fu">case_when</span>(</span>
<span id="cb387-8"><a href="cluster.html#cb387-8" aria-hidden="true" tabindex="-1"></a>                      SpatialEta<span class="sc">&gt;</span><span class="dv">0</span> <span class="sc">~</span> <span class="dv">1</span>,</span>
<span id="cb387-9"><a href="cluster.html#cb387-9" aria-hidden="true" tabindex="-1"></a>                      <span class="cn">TRUE</span> <span class="sc">~</span> <span class="dv">0</span>)</span>
<span id="cb387-10"><a href="cluster.html#cb387-10" aria-hidden="true" tabindex="-1"></a>          )</span></code></pre></div>
<p>We can now try to visualize what the data looks like, and especially the level of spatial autocorrelation, by mapping the spatial conditional expectation of the two variables of interest.
For that, I am going to use the <code>btb</code> package in <code>R</code>, which has a very nice function to compute spatial conditional expectations: <code>btb_smooth</code>.
Because some of the results I obtain with <code>btb</code> are somewhat strange, I also use the <code>spatstat</code> package and its function <code>markmean</code>.</p>
<div class="sourceCode" id="cb388"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb388-1"><a href="cluster.html#cb388-1" aria-hidden="true" tabindex="-1"></a><span class="co"># with btb</span></span>
<span id="cb388-2"><a href="cluster.html#cb388-2" aria-hidden="true" tabindex="-1"></a><span class="co"># dataset with X and Y coordinates</span></span>
<span id="cb388-3"><a href="cluster.html#cb388-3" aria-hidden="true" tabindex="-1"></a><span class="co"># I use the Universal Mercator projection zone 31N, which corresponds to the North of France, and whose EPSG identity is 32631</span></span>
<span id="cb388-4"><a href="cluster.html#cb388-4" aria-hidden="true" tabindex="-1"></a>xy.SpatialData <span class="ot">&lt;-</span> SpatialData <span class="sc">%&gt;%</span></span>
<span id="cb388-5"><a href="cluster.html#cb388-5" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">st_transform</span>(<span class="at">crs=</span><span class="dv">32631</span>) <span class="sc">%&gt;%</span></span>
<span id="cb388-6"><a href="cluster.html#cb388-6" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">cbind</span>(<span class="fu">st_coordinates</span>(SpatialData)) <span class="sc">%&gt;%</span></span>
<span id="cb388-7"><a href="cluster.html#cb388-7" aria-hidden="true" tabindex="-1"></a><span class="co">#                  select(-geometry) %&gt;%</span></span>
<span id="cb388-8"><a href="cluster.html#cb388-8" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">relocate</span>(Y) <span class="sc">%&gt;%</span></span>
<span id="cb388-9"><a href="cluster.html#cb388-9" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">relocate</span>(X) <span class="sc">%&gt;%</span></span>
<span id="cb388-10"><a href="cluster.html#cb388-10" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">rename</span>(</span>
<span id="cb388-11"><a href="cluster.html#cb388-11" aria-hidden="true" tabindex="-1"></a>                    <span class="at">x=</span>X,</span>
<span id="cb388-12"><a href="cluster.html#cb388-12" aria-hidden="true" tabindex="-1"></a>                    <span class="at">y=</span>Y</span>
<span id="cb388-13"><a href="cluster.html#cb388-13" aria-hidden="true" tabindex="-1"></a>                  )</span>
<span id="cb388-14"><a href="cluster.html#cb388-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb388-15"><a href="cluster.html#cb388-15" aria-hidden="true" tabindex="-1"></a><span class="co"># choosing parameters</span></span>
<span id="cb388-16"><a href="cluster.html#cb388-16" aria-hidden="true" tabindex="-1"></a><span class="co"># grid size (in m)</span></span>
<span id="cb388-17"><a href="cluster.html#cb388-17" aria-hidden="true" tabindex="-1"></a>grid.size <span class="ot">&lt;-</span> <span class="dv">5000</span></span>
<span id="cb388-18"><a href="cluster.html#cb388-18" aria-hidden="true" tabindex="-1"></a><span class="co"># bandwidth (in m)</span></span>
<span id="cb388-19"><a href="cluster.html#cb388-19" aria-hidden="true" tabindex="-1"></a>bandwith.radius <span class="ot">&lt;-</span> <span class="dv">10000</span></span>
<span id="cb388-20"><a href="cluster.html#cb388-20" aria-hidden="true" tabindex="-1"></a><span class="co"># estimating spatial conditional expectation</span></span>
<span id="cb388-21"><a href="cluster.html#cb388-21" aria-hidden="true" tabindex="-1"></a>dfSpatialCondExp <span class="ot">&lt;-</span> btb<span class="sc">::</span><span class="fu">btb_smooth</span>(xy.SpatialData,<span class="at">iCellSize=</span>grid.size,<span class="at">iBandwidth=</span>bandwith.radius,<span class="at">sEPSG=</span><span class="st">&quot;4326&quot;</span>) <span class="sc">%&gt;%</span></span>
<span id="cb388-22"><a href="cluster.html#cb388-22" aria-hidden="true" tabindex="-1"></a>                    <span class="fu">st_transform</span>(<span class="dv">4326</span>) <span class="sc">%&gt;%</span></span>
<span id="cb388-23"><a href="cluster.html#cb388-23" aria-hidden="true" tabindex="-1"></a>                    <span class="fu">st_as_sf</span>()</span>
<span id="cb388-24"><a href="cluster.html#cb388-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb388-25"><a href="cluster.html#cb388-25" aria-hidden="true" tabindex="-1"></a><span class="co"># with spatstat</span></span>
<span id="cb388-26"><a href="cluster.html#cb388-26" aria-hidden="true" tabindex="-1"></a>range <span class="ot">&lt;-</span> <span class="fu">owin</span>(<span class="at">xrange=</span><span class="fu">c</span>(<span class="fu">min</span>(xy.SpatialData<span class="sc">$</span>x),<span class="fu">max</span>(xy.SpatialData<span class="sc">$</span>x)),<span class="at">yrange=</span><span class="fu">c</span>(<span class="fu">min</span>(xy.SpatialData<span class="sc">$</span>y),<span class="fu">max</span>(xy.SpatialData<span class="sc">$</span>y)))</span>
<span id="cb388-27"><a href="cluster.html#cb388-27" aria-hidden="true" tabindex="-1"></a><span class="co"># U</span></span>
<span id="cb388-28"><a href="cluster.html#cb388-28" aria-hidden="true" tabindex="-1"></a>xy.SpatialData.U.ppp <span class="ot">&lt;-</span> <span class="fu">ppp</span>(xy.SpatialData<span class="sc">$</span>x,xy.SpatialData<span class="sc">$</span>y,<span class="at">window=</span>range,<span class="at">marks=</span>xy.SpatialData<span class="sc">$</span>U)</span>
<span id="cb388-29"><a href="cluster.html#cb388-29" aria-hidden="true" tabindex="-1"></a><span class="co"># smoothing</span></span>
<span id="cb388-30"><a href="cluster.html#cb388-30" aria-hidden="true" tabindex="-1"></a>dfSpatialCondExp.U.ppp <span class="ot">&lt;-</span> <span class="fu">markmean</span>(xy.SpatialData.U.ppp)</span>
<span id="cb388-31"><a href="cluster.html#cb388-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Ds</span></span>
<span id="cb388-32"><a href="cluster.html#cb388-32" aria-hidden="true" tabindex="-1"></a>xy.SpatialData.Ds.ppp <span class="ot">&lt;-</span> <span class="fu">ppp</span>(xy.SpatialData<span class="sc">$</span>x,xy.SpatialData<span class="sc">$</span>y,<span class="at">window=</span>range,<span class="at">marks=</span>xy.SpatialData<span class="sc">$</span>Ds)</span>
<span id="cb388-33"><a href="cluster.html#cb388-33" aria-hidden="true" tabindex="-1"></a><span class="co"># smoothing</span></span>
<span id="cb388-34"><a href="cluster.html#cb388-34" aria-hidden="true" tabindex="-1"></a>dfSpatialCondExp.Ds.ppp <span class="ot">&lt;-</span> <span class="fu">markmean</span>(xy.SpatialData.Ds.ppp)</span></code></pre></div>
<p>Let us now plot the resulting maps:</p>
<div class="sourceCode" id="cb389"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb389-1"><a href="cluster.html#cb389-1" aria-hidden="true" tabindex="-1"></a><span class="co"># with btb</span></span>
<span id="cb389-2"><a href="cluster.html#cb389-2" aria-hidden="true" tabindex="-1"></a>cartography<span class="sc">::</span><span class="fu">choroLayer</span>(dfSpatialCondExp, <span class="at">var =</span> <span class="st">&quot;U&quot;</span>, <span class="at">nclass =</span> <span class="dv">5</span>, <span class="at">method =</span> <span class="st">&quot;fisher-jenks&quot;</span>, <span class="at">border =</span> <span class="cn">NA</span>, <span class="at">legend.pos =</span> <span class="st">&quot;topright&quot;</span>, <span class="at">legend.title.txt =</span><span class="st">&quot;U&quot;</span>)</span>
<span id="cb389-3"><a href="cluster.html#cb389-3" aria-hidden="true" tabindex="-1"></a>cartography<span class="sc">::</span><span class="fu">choroLayer</span>(dfSpatialCondExp, <span class="at">var =</span> <span class="st">&quot;Ds&quot;</span>, <span class="at">nclass =</span> <span class="dv">5</span>, <span class="at">method =</span> <span class="st">&quot;fisher-jenks&quot;</span>, <span class="at">border =</span> <span class="cn">NA</span>, <span class="at">legend.pos =</span> <span class="st">&quot;topright&quot;</span>, <span class="at">legend.title.txt =</span><span class="st">&quot;Ds&quot;</span>)</span>
<span id="cb389-4"><a href="cluster.html#cb389-4" aria-hidden="true" tabindex="-1"></a><span class="co"># with spatstat</span></span>
<span id="cb389-5"><a href="cluster.html#cb389-5" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(dfSpatialCondExp.U.ppp,<span class="at">axes=</span>T,<span class="at">main=</span><span class="st">&#39;U&#39;</span>)</span>
<span id="cb389-6"><a href="cluster.html#cb389-6" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(dfSpatialCondExp.Ds.ppp,<span class="at">axes=</span>T,<span class="at">main=</span><span class="st">&#39;Ds&#39;</span>)</span></code></pre></div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:SpatialCondExpPlot"></span>
<img src="STCI_files/figure-html/SpatialCondExpPlot-1.png" alt="Spatial correlation" width="45%" /><img src="STCI_files/figure-html/SpatialCondExpPlot-2.png" alt="Spatial correlation" width="45%" /><img src="STCI_files/figure-html/SpatialCondExpPlot-3.png" alt="Spatial correlation" width="45%" /><img src="STCI_files/figure-html/SpatialCondExpPlot-4.png" alt="Spatial correlation" width="45%" />
<p class="caption">
Figure 9.9: Spatial correlation
</p>
</div>
<p>We can see on the maps that there are clear signs of spatial autocorrelation both in the <span class="math inline">\(U_i\)</span> variable and in the <span class="math inline">\(D_i\)</span> variable.
On the <code>btb</code> plots, each pixels has edges of 5km.
The autocorrelation patterns seem larger than that, reaching 15 to 20 km.
On the <code>spatstat</code> plots, units are in meters, meaning that each tick mark measures 20km.
It seems that this is an adequate scale to describe the amount of spatial autocorrelation in the data.
Note finally that the prediction of <span class="math inline">\(D_i\)</span> obtained with <code>btb</code> is weird, since it is not comprised between 0 and 1, while the one obtained using <code>spatstat</code> makes a lot of sense.
They both offer the same overall picture though: there is substantial spatial autocorrelation in this data.</p>
<p>We finally can run a regression of the outcome <span class="math inline">\(U\)</span> on the treatment <span class="math inline">\(D\)</span> in this very simple model:</p>
<div class="sourceCode" id="cb390"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb390-1"><a href="cluster.html#cb390-1" aria-hidden="true" tabindex="-1"></a><span class="co"># regression</span></span>
<span id="cb390-2"><a href="cluster.html#cb390-2" aria-hidden="true" tabindex="-1"></a>SpatialReg <span class="ot">&lt;-</span> <span class="fu">lm</span>(U<span class="sc">~</span>Ds,<span class="at">data=</span>SpatialData)</span></code></pre></div>
<p>The estimated treatment effect in this example is equal to 0.01 <span class="math inline">\(\pm\)</span> 0.03.
Let us reproduce this simulation, only randomly reallocating the treatment variable, as in a randomization inference exercise, to see how the actual treatment effect estimate is distributed.
We know it should be centered around zero.</p>
<div class="sourceCode" id="cb391"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb391-1"><a href="cluster.html#cb391-1" aria-hidden="true" tabindex="-1"></a><span class="co"># function for one monte carlo draw</span></span>
<span id="cb391-2"><a href="cluster.html#cb391-2" aria-hidden="true" tabindex="-1"></a><span class="co"># seed: seed</span></span>
<span id="cb391-3"><a href="cluster.html#cb391-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Wm: spatial influence matrix (I-rho*W)^{-1}</span></span>
<span id="cb391-4"><a href="cluster.html#cb391-4" aria-hidden="true" tabindex="-1"></a><span class="co"># sigma2epsilon: variance of the error term for the outcomes</span></span>
<span id="cb391-5"><a href="cluster.html#cb391-5" aria-hidden="true" tabindex="-1"></a><span class="co"># sigma2eta: variance of the error term for participation</span></span>
<span id="cb391-6"><a href="cluster.html#cb391-6" aria-hidden="true" tabindex="-1"></a><span class="co"># ConleyDist: distance used for estimating Conley standard errors</span></span>
<span id="cb391-7"><a href="cluster.html#cb391-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Matrix Used for Leung Estimation</span></span>
<span id="cb391-8"><a href="cluster.html#cb391-8" aria-hidden="true" tabindex="-1"></a><span class="co"># data: data frame with outcomes</span></span>
<span id="cb391-9"><a href="cluster.html#cb391-9" aria-hidden="true" tabindex="-1"></a>SpatialRegMonteCarlo <span class="ot">&lt;-</span> <span class="cf">function</span>(seed,Wm,sigma2epsilon,sigma2eta,ConleyDist,LeungMatrix,data){</span>
<span id="cb391-10"><a href="cluster.html#cb391-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set.seed</span>(seed)</span>
<span id="cb391-11"><a href="cluster.html#cb391-11" aria-hidden="true" tabindex="-1"></a>  epsilon <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="at">n=</span><span class="fu">nrow</span>(data),<span class="at">mean=</span><span class="dv">0</span>,<span class="at">sd=</span><span class="fu">sqrt</span>(sigma2epsilon))</span>
<span id="cb391-12"><a href="cluster.html#cb391-12" aria-hidden="true" tabindex="-1"></a>  data<span class="sc">$</span>SpatialUsim <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(Wm<span class="sc">%*%</span>epsilon)</span>
<span id="cb391-13"><a href="cluster.html#cb391-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set.seed</span>(seed<span class="sc">+</span><span class="dv">1</span>)</span>
<span id="cb391-14"><a href="cluster.html#cb391-14" aria-hidden="true" tabindex="-1"></a>  eta <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="at">n=</span><span class="fu">nrow</span>(data),<span class="at">mean=</span><span class="dv">0</span>,<span class="at">sd=</span><span class="fu">sqrt</span>(sigma2eta))</span>
<span id="cb391-15"><a href="cluster.html#cb391-15" aria-hidden="true" tabindex="-1"></a>  data<span class="sc">$</span>SpatialEtasim <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(Wm<span class="sc">%*%</span>eta)</span>
<span id="cb391-16"><a href="cluster.html#cb391-16" aria-hidden="true" tabindex="-1"></a>  <span class="co"># allocating the treatment</span></span>
<span id="cb391-17"><a href="cluster.html#cb391-17" aria-hidden="true" tabindex="-1"></a>  data <span class="ot">&lt;-</span> data <span class="sc">%&gt;%</span></span>
<span id="cb391-18"><a href="cluster.html#cb391-18" aria-hidden="true" tabindex="-1"></a>          <span class="fu">mutate</span>(</span>
<span id="cb391-19"><a href="cluster.html#cb391-19" aria-hidden="true" tabindex="-1"></a>            <span class="at">Dsim =</span> <span class="fu">case_when</span>(</span>
<span id="cb391-20"><a href="cluster.html#cb391-20" aria-hidden="true" tabindex="-1"></a>                      SpatialEtasim<span class="sc">&gt;</span><span class="dv">0</span> <span class="sc">~</span> <span class="dv">1</span>,</span>
<span id="cb391-21"><a href="cluster.html#cb391-21" aria-hidden="true" tabindex="-1"></a>                      <span class="cn">TRUE</span> <span class="sc">~</span> <span class="dv">0</span>)</span>
<span id="cb391-22"><a href="cluster.html#cb391-22" aria-hidden="true" tabindex="-1"></a>          )</span>
<span id="cb391-23"><a href="cluster.html#cb391-23" aria-hidden="true" tabindex="-1"></a>  <span class="co"># run regression</span></span>
<span id="cb391-24"><a href="cluster.html#cb391-24" aria-hidden="true" tabindex="-1"></a>  formulaSpatialReg <span class="ot">&lt;-</span> <span class="fu">as.formula</span>(<span class="fu">paste</span>(<span class="st">&#39;SpatialUsim&#39;</span>,<span class="st">&#39;Dsim&#39;</span>,<span class="at">sep=</span><span class="st">&#39;~&#39;</span>))</span>
<span id="cb391-25"><a href="cluster.html#cb391-25" aria-hidden="true" tabindex="-1"></a>  SpatialReg <span class="ot">&lt;-</span> <span class="fu">lm</span>(formulaSpatialReg,<span class="at">data=</span>data)</span>
<span id="cb391-26"><a href="cluster.html#cb391-26" aria-hidden="true" tabindex="-1"></a>  <span class="co"># conley standard error</span></span>
<span id="cb391-27"><a href="cluster.html#cb391-27" aria-hidden="true" tabindex="-1"></a>  <span class="co"># computing regression</span></span>
<span id="cb391-28"><a href="cluster.html#cb391-28" aria-hidden="true" tabindex="-1"></a>  RegSpatial <span class="ot">&lt;-</span> <span class="fu">feols</span>(formulaSpatialReg,<span class="at">data=</span>data)</span>
<span id="cb391-29"><a href="cluster.html#cb391-29" aria-hidden="true" tabindex="-1"></a>  VcovConleyFixest <span class="ot">&lt;-</span> <span class="fu">vcov_conley</span>(RegSpatial,<span class="at">lat=</span><span class="st">&quot;latitude&quot;</span>,<span class="at">lon=</span><span class="st">&quot;longitude&quot;</span>,<span class="at">cutoff=</span>ConleyDist)</span>
<span id="cb391-30"><a href="cluster.html#cb391-30" aria-hidden="true" tabindex="-1"></a>  <span class="co"># SEWWConleyFixest</span></span>
<span id="cb391-31"><a href="cluster.html#cb391-31" aria-hidden="true" tabindex="-1"></a>  SEWWConleyFixest <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(<span class="fu">diag</span>(VcovConleyFixest))[[<span class="dv">2</span>]]</span>
<span id="cb391-32"><a href="cluster.html#cb391-32" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Leung Standard error</span></span>
<span id="cb391-33"><a href="cluster.html#cb391-33" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Let us first generate the G matrix, which is simply the DistanceMatrixDiscrete matrix plus a diagonal matrix of ones.</span></span>
<span id="cb391-34"><a href="cluster.html#cb391-34" aria-hidden="true" tabindex="-1"></a>  G <span class="ot">&lt;-</span> LeungMatrix<span class="sc">+</span><span class="fu">Diagonal</span>(<span class="at">n=</span><span class="fu">nrow</span>(LeungMatrix))</span>
<span id="cb391-35"><a href="cluster.html#cb391-35" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Let us now generate the M and X matrices</span></span>
<span id="cb391-36"><a href="cluster.html#cb391-36" aria-hidden="true" tabindex="-1"></a>  <span class="co"># M has two columns: one for U*constant (vector of ones) and the other for U*Ds</span></span>
<span id="cb391-37"><a href="cluster.html#cb391-37" aria-hidden="true" tabindex="-1"></a>  <span class="co"># normally, the epsilons are used instead of the Us, with epsilon the residuals from an ols regression of U (or Y) on a constant and Ds</span></span>
<span id="cb391-38"><a href="cluster.html#cb391-38" aria-hidden="true" tabindex="-1"></a>  data <span class="ot">&lt;-</span> data <span class="sc">%&gt;%</span> </span>
<span id="cb391-39"><a href="cluster.html#cb391-39" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mutate</span>(</span>
<span id="cb391-40"><a href="cluster.html#cb391-40" aria-hidden="true" tabindex="-1"></a>      <span class="at">residuals =</span> SpatialReg<span class="sc">$</span>residuals,</span>
<span id="cb391-41"><a href="cluster.html#cb391-41" aria-hidden="true" tabindex="-1"></a>      <span class="at">ResidDs =</span> residuals<span class="sc">*</span>Ds, </span>
<span id="cb391-42"><a href="cluster.html#cb391-42" aria-hidden="true" tabindex="-1"></a>      <span class="at">Cst =</span> <span class="dv">1</span></span>
<span id="cb391-43"><a href="cluster.html#cb391-43" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb391-44"><a href="cluster.html#cb391-44" aria-hidden="true" tabindex="-1"></a>  M <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(<span class="fu">cbind</span>(data<span class="sc">$</span>residuals,data<span class="sc">$</span>ResidDs))</span>
<span id="cb391-45"><a href="cluster.html#cb391-45" aria-hidden="true" tabindex="-1"></a>  X <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(<span class="fu">cbind</span>(data<span class="sc">$</span>Cst,data<span class="sc">$</span>Ds))</span>
<span id="cb391-46"><a href="cluster.html#cb391-46" aria-hidden="true" tabindex="-1"></a>  <span class="co"># LEt us now compute Leung&#39;s matrix</span></span>
<span id="cb391-47"><a href="cluster.html#cb391-47" aria-hidden="true" tabindex="-1"></a>  VcovLeung <span class="ot">&lt;-</span> ((<span class="fu">solve</span>(<span class="fu">t</span>(X)<span class="sc">%*%</span>X))<span class="sc">%*%</span><span class="fu">t</span>(M)<span class="sc">%*%</span>G<span class="sc">%*%</span>M<span class="sc">%*%</span>(<span class="fu">solve</span>(<span class="fu">t</span>(X)<span class="sc">%*%</span>X)))</span>
<span id="cb391-48"><a href="cluster.html#cb391-48" aria-hidden="true" tabindex="-1"></a>  <span class="co"># SEWWLeung</span></span>
<span id="cb391-49"><a href="cluster.html#cb391-49" aria-hidden="true" tabindex="-1"></a>  SEWWLeung <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(<span class="fu">diag</span>(VcovLeung))[[<span class="dv">2</span>]]</span>
<span id="cb391-50"><a href="cluster.html#cb391-50" aria-hidden="true" tabindex="-1"></a>  <span class="co"># results </span></span>
<span id="cb391-51"><a href="cluster.html#cb391-51" aria-hidden="true" tabindex="-1"></a>  results <span class="ot">&lt;-</span> <span class="fu">list</span>(SpatialReg<span class="sc">$</span>coefficients[[<span class="dv">2</span>]],<span class="fu">sqrt</span>(<span class="fu">diag</span>(<span class="fu">vcov</span>(SpatialReg)))[[<span class="dv">2</span>]],SEWWConleyFixest,SEWWLeung)</span>
<span id="cb391-52"><a href="cluster.html#cb391-52" aria-hidden="true" tabindex="-1"></a>  <span class="fu">names</span>(results) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&#39;WW&#39;</span>,<span class="st">&#39;SeWW&#39;</span>,<span class="st">&#39;SeWWConley&#39;</span>,<span class="st">&#39;SeWWLeung&#39;</span>)</span>
<span id="cb391-53"><a href="cluster.html#cb391-53" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(results)</span>
<span id="cb391-54"><a href="cluster.html#cb391-54" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb391-55"><a href="cluster.html#cb391-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb391-56"><a href="cluster.html#cb391-56" aria-hidden="true" tabindex="-1"></a><span class="co"># test</span></span>
<span id="cb391-57"><a href="cluster.html#cb391-57" aria-hidden="true" tabindex="-1"></a>test.spatial.Reg <span class="ot">&lt;-</span> <span class="fu">SpatialRegMonteCarlo</span>(<span class="at">seed=</span><span class="dv">1</span>,<span class="at">Wm=</span>SpatialInfluenceMatrix,<span class="at">sigma2epsilon=</span>param[<span class="st">&#39;sigma2epsilon&#39;</span>],<span class="at">sigma2eta=</span>param[<span class="st">&#39;sigma2epsilon&#39;</span>],<span class="at">ConleyDist=</span><span class="dv">20</span>,<span class="at">LeungMatrix=</span>DistanceMatrixDiscrete20,<span class="at">data=</span>SpatialData)</span>
<span id="cb391-58"><a href="cluster.html#cb391-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb391-59"><a href="cluster.html#cb391-59" aria-hidden="true" tabindex="-1"></a><span class="co"># parallelized Monte Carlo function</span></span>
<span id="cb391-60"><a href="cluster.html#cb391-60" aria-hidden="true" tabindex="-1"></a>sf.SpatialRegMonteCarlo <span class="ot">&lt;-</span> <span class="cf">function</span>(Nsim,Wm,sigma2epsilon,sigma2eta,ConleyDist,LeungMatrix,data){</span>
<span id="cb391-61"><a href="cluster.html#cb391-61" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sfInit</span>(<span class="at">parallel=</span><span class="cn">TRUE</span>,<span class="at">cpus=</span><span class="dv">8</span>)</span>
<span id="cb391-62"><a href="cluster.html#cb391-62" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sfLibrary</span>(dplyr)</span>
<span id="cb391-63"><a href="cluster.html#cb391-63" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sfLibrary</span>(Matrix)</span>
<span id="cb391-64"><a href="cluster.html#cb391-64" aria-hidden="true" tabindex="-1"></a>  <span class="co">#sim &lt;- matrix(unlist(sfLapply(1:Nsim,SpatialRegMonteCarlo,y=y,Wm=Wm,sigma2eta=sigma2eta,data=data)),nrow=Nsim,ncol=1,byrow=TRUE)</span></span>
<span id="cb391-65"><a href="cluster.html#cb391-65" aria-hidden="true" tabindex="-1"></a>  sim <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">unlist</span>(<span class="fu">lapply</span>(<span class="dv">1</span><span class="sc">:</span>Nsim,SpatialRegMonteCarlo,<span class="at">Wm=</span>Wm,<span class="at">sigma2epsilon=</span>sigma2epsilon,<span class="at">sigma2eta=</span>sigma2eta,<span class="at">ConleyDist=</span>ConleyDist,<span class="at">LeungMatrix=</span>LeungMatrix,<span class="at">data=</span>data)),<span class="at">nrow=</span>Nsim,<span class="at">ncol=</span><span class="dv">4</span>,<span class="at">byrow=</span><span class="cn">TRUE</span>)</span>
<span id="cb391-66"><a href="cluster.html#cb391-66" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sfStop</span>()</span>
<span id="cb391-67"><a href="cluster.html#cb391-67" aria-hidden="true" tabindex="-1"></a>  <span class="fu">colnames</span>(sim) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&#39;WW&#39;</span>,<span class="st">&#39;SeWW&#39;</span>,<span class="st">&#39;SeWWConley&#39;</span>,<span class="st">&#39;SeWWLeung&#39;</span>)</span>
<span id="cb391-68"><a href="cluster.html#cb391-68" aria-hidden="true" tabindex="-1"></a>  sim <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(sim)</span>
<span id="cb391-69"><a href="cluster.html#cb391-69" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(sim)</span>
<span id="cb391-70"><a href="cluster.html#cb391-70" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb391-71"><a href="cluster.html#cb391-71" aria-hidden="true" tabindex="-1"></a><span class="co"># Number of simulations </span></span>
<span id="cb391-72"><a href="cluster.html#cb391-72" aria-hidden="true" tabindex="-1"></a>Nsim <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="cb391-73"><a href="cluster.html#cb391-73" aria-hidden="true" tabindex="-1"></a>test.simuls.SpatialRegMonteCarlo <span class="ot">&lt;-</span> <span class="fu">sf.SpatialRegMonteCarlo</span>(<span class="at">Nsim=</span>Nsim,<span class="at">Wm=</span>SpatialInfluenceMatrix,<span class="at">sigma2epsilon=</span>param[<span class="st">&#39;sigma2epsilon&#39;</span>],<span class="at">sigma2eta=</span>param[<span class="st">&#39;sigma2epsilon&#39;</span>],<span class="at">ConleyDist=</span><span class="dv">20</span>,<span class="at">LeungMatrix=</span>DistanceMatrixDiscrete20,<span class="at">data=</span>SpatialData)</span></code></pre></div>
<pre><code>## R Version:  R version 4.1.1 (2021-08-10) 
## 
## Library dplyr loaded.
## Library Matrix loaded.</code></pre>
<div class="sourceCode" id="cb393"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb393-1"><a href="cluster.html#cb393-1" aria-hidden="true" tabindex="-1"></a><span class="co"># true 99% sampling noise</span></span>
<span id="cb393-2"><a href="cluster.html#cb393-2" aria-hidden="true" tabindex="-1"></a><span class="co"># 99% confidence interval over monte carlo replications</span></span>
<span id="cb393-3"><a href="cluster.html#cb393-3" aria-hidden="true" tabindex="-1"></a>True.CI<span class="fl">.99</span> <span class="ot">&lt;-</span> <span class="fu">quantile</span>(test.simuls.SpatialRegMonteCarlo<span class="sc">$</span>WW,<span class="at">prob=</span><span class="fu">c</span>(<span class="fl">0.01</span>,<span class="fl">0.99</span>))</span>
<span id="cb393-4"><a href="cluster.html#cb393-4" aria-hidden="true" tabindex="-1"></a>TrueSpatialSampNoise<span class="fl">.99</span> <span class="ot">&lt;-</span> True.CI<span class="fl">.99</span>[[<span class="dv">2</span>]]<span class="sc">-</span>True.CI<span class="fl">.99</span>[[<span class="dv">1</span>]]</span>
<span id="cb393-5"><a href="cluster.html#cb393-5" aria-hidden="true" tabindex="-1"></a>True.Se.WW <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(<span class="fu">var</span>(test.simuls.SpatialRegMonteCarlo<span class="sc">$</span>WW))</span>
<span id="cb393-6"><a href="cluster.html#cb393-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Estimated sampling noise ignoring spatial correlation</span></span>
<span id="cb393-7"><a href="cluster.html#cb393-7" aria-hidden="true" tabindex="-1"></a>SeWW.Mean <span class="ot">&lt;-</span> test.simuls.SpatialRegMonteCarlo <span class="sc">%&gt;%</span></span>
<span id="cb393-8"><a href="cluster.html#cb393-8" aria-hidden="true" tabindex="-1"></a>                <span class="fu">summarise</span>(</span>
<span id="cb393-9"><a href="cluster.html#cb393-9" aria-hidden="true" tabindex="-1"></a>                  <span class="at">MeanSeWW =</span> <span class="fu">mean</span>(SeWW)</span>
<span id="cb393-10"><a href="cluster.html#cb393-10" aria-hidden="true" tabindex="-1"></a>                ) <span class="sc">%&gt;%</span></span>
<span id="cb393-11"><a href="cluster.html#cb393-11" aria-hidden="true" tabindex="-1"></a>                <span class="fu">pull</span>(MeanSeWW)</span>
<span id="cb393-12"><a href="cluster.html#cb393-12" aria-hidden="true" tabindex="-1"></a>EstimatedSpatialSampNoise<span class="fl">.99</span> <span class="ot">&lt;-</span> <span class="dv">2</span><span class="sc">*</span><span class="fu">qnorm</span>((<span class="fl">0.99</span><span class="sc">+</span><span class="dv">1</span>)<span class="sc">/</span><span class="dv">2</span>)<span class="sc">*</span>SeWW.Mean</span>
<span id="cb393-13"><a href="cluster.html#cb393-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Estimated sampling noise with  spatial correlation (conley)</span></span>
<span id="cb393-14"><a href="cluster.html#cb393-14" aria-hidden="true" tabindex="-1"></a>SeWWConley.Mean <span class="ot">&lt;-</span> test.simuls.SpatialRegMonteCarlo <span class="sc">%&gt;%</span></span>
<span id="cb393-15"><a href="cluster.html#cb393-15" aria-hidden="true" tabindex="-1"></a>                <span class="fu">summarise</span>(</span>
<span id="cb393-16"><a href="cluster.html#cb393-16" aria-hidden="true" tabindex="-1"></a>                  <span class="at">MeanSeWWConley =</span> <span class="fu">mean</span>(SeWWConley)</span>
<span id="cb393-17"><a href="cluster.html#cb393-17" aria-hidden="true" tabindex="-1"></a>                ) <span class="sc">%&gt;%</span></span>
<span id="cb393-18"><a href="cluster.html#cb393-18" aria-hidden="true" tabindex="-1"></a>                <span class="fu">pull</span>(MeanSeWWConley)</span>
<span id="cb393-19"><a href="cluster.html#cb393-19" aria-hidden="true" tabindex="-1"></a>ConleyEstimatedSpatialSampNoise<span class="fl">.99</span> <span class="ot">&lt;-</span> <span class="dv">2</span><span class="sc">*</span><span class="fu">qnorm</span>((<span class="fl">0.99</span><span class="sc">+</span><span class="dv">1</span>)<span class="sc">/</span><span class="dv">2</span>)<span class="sc">*</span>SeWWConley.Mean</span>
<span id="cb393-20"><a href="cluster.html#cb393-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb393-21"><a href="cluster.html#cb393-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Estimated sampling noise with  spatial correlation (Leung)</span></span>
<span id="cb393-22"><a href="cluster.html#cb393-22" aria-hidden="true" tabindex="-1"></a>SeWWLeung.Mean <span class="ot">&lt;-</span> test.simuls.SpatialRegMonteCarlo <span class="sc">%&gt;%</span></span>
<span id="cb393-23"><a href="cluster.html#cb393-23" aria-hidden="true" tabindex="-1"></a>                <span class="fu">summarise</span>(</span>
<span id="cb393-24"><a href="cluster.html#cb393-24" aria-hidden="true" tabindex="-1"></a>                  <span class="at">MeanSeWWLeung =</span> <span class="fu">mean</span>(SeWWLeung)</span>
<span id="cb393-25"><a href="cluster.html#cb393-25" aria-hidden="true" tabindex="-1"></a>                ) <span class="sc">%&gt;%</span></span>
<span id="cb393-26"><a href="cluster.html#cb393-26" aria-hidden="true" tabindex="-1"></a>                <span class="fu">pull</span>(MeanSeWWLeung)</span>
<span id="cb393-27"><a href="cluster.html#cb393-27" aria-hidden="true" tabindex="-1"></a>LeungEstimatedSpatialSampNoise<span class="fl">.99</span> <span class="ot">&lt;-</span> <span class="dv">2</span><span class="sc">*</span><span class="fu">qnorm</span>((<span class="fl">0.99</span><span class="sc">+</span><span class="dv">1</span>)<span class="sc">/</span><span class="dv">2</span>)<span class="sc">*</span>SeWWLeung.Mean</span></code></pre></div>
<p>Let us now plot the resulting estimates:</p>
<div class="sourceCode" id="cb394"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb394-1"><a href="cluster.html#cb394-1" aria-hidden="true" tabindex="-1"></a><span class="co"># # first plot</span></span>
<span id="cb394-2"><a href="cluster.html#cb394-2" aria-hidden="true" tabindex="-1"></a><span class="co"># ggplot(test.simuls.SpatialRegMonteCarlo,aes(x=WW)) +</span></span>
<span id="cb394-3"><a href="cluster.html#cb394-3" aria-hidden="true" tabindex="-1"></a><span class="co">#   geom_histogram(binwidth=.01, colour=&quot;black&quot;, fill=&quot;white&quot;) +</span></span>
<span id="cb394-4"><a href="cluster.html#cb394-4" aria-hidden="true" tabindex="-1"></a><span class="co">#   theme_bw()</span></span>
<span id="cb394-5"><a href="cluster.html#cb394-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb394-6"><a href="cluster.html#cb394-6" aria-hidden="true" tabindex="-1"></a><span class="co"># second plot</span></span>
<span id="cb394-7"><a href="cluster.html#cb394-7" aria-hidden="true" tabindex="-1"></a><span class="co"># prepare data</span></span>
<span id="cb394-8"><a href="cluster.html#cb394-8" aria-hidden="true" tabindex="-1"></a>Data.precision.Spatial <span class="ot">&lt;-</span> test.simuls.SpatialRegMonteCarlo <span class="sc">%&gt;%</span></span>
<span id="cb394-9"><a href="cluster.html#cb394-9" aria-hidden="true" tabindex="-1"></a>                            <span class="fu">summarize</span>(</span>
<span id="cb394-10"><a href="cluster.html#cb394-10" aria-hidden="true" tabindex="-1"></a>                              <span class="at">True =</span> <span class="fu">sqrt</span>(<span class="fu">var</span>(WW)),</span>
<span id="cb394-11"><a href="cluster.html#cb394-11" aria-hidden="true" tabindex="-1"></a>                              <span class="at">EstimatedNaive =</span> <span class="fu">mean</span>(SeWW),</span>
<span id="cb394-12"><a href="cluster.html#cb394-12" aria-hidden="true" tabindex="-1"></a>                              <span class="at">EstimatedConley =</span> <span class="fu">mean</span>(SeWWConley),</span>
<span id="cb394-13"><a href="cluster.html#cb394-13" aria-hidden="true" tabindex="-1"></a>                              <span class="at">EstimatedLeung =</span> <span class="fu">mean</span>(SeWWLeung)</span>
<span id="cb394-14"><a href="cluster.html#cb394-14" aria-hidden="true" tabindex="-1"></a>                            ) <span class="sc">%&gt;%</span></span>
<span id="cb394-15"><a href="cluster.html#cb394-15" aria-hidden="true" tabindex="-1"></a>                            <span class="fu">pivot_longer</span>(True<span class="sc">:</span>EstimatedLeung,<span class="at">names_to =</span> <span class="st">&#39;Method&#39;</span>,<span class="at">values_to =</span> <span class="st">&quot;Se&quot;</span>) <span class="sc">%&gt;%</span></span>
<span id="cb394-16"><a href="cluster.html#cb394-16" aria-hidden="true" tabindex="-1"></a>                            <span class="fu">mutate</span>(</span>
<span id="cb394-17"><a href="cluster.html#cb394-17" aria-hidden="true" tabindex="-1"></a>                              <span class="at">TE =</span> <span class="dv">0</span>,</span>
<span id="cb394-18"><a href="cluster.html#cb394-18" aria-hidden="true" tabindex="-1"></a>                              <span class="at">Method=</span><span class="fu">factor</span>(Method,<span class="at">levels=</span><span class="fu">c</span>(<span class="st">&#39;True&#39;</span>,<span class="st">&#39;EstimatedNaive&#39;</span>,<span class="st">&#39;EstimatedConley&#39;</span>,<span class="st">&#39;EstimatedLeung&#39;</span>))</span>
<span id="cb394-19"><a href="cluster.html#cb394-19" aria-hidden="true" tabindex="-1"></a>                            ) </span>
<span id="cb394-20"><a href="cluster.html#cb394-20" aria-hidden="true" tabindex="-1"></a>                            </span>
<span id="cb394-21"><a href="cluster.html#cb394-21" aria-hidden="true" tabindex="-1"></a><span class="co"># plot</span></span>
<span id="cb394-22"><a href="cluster.html#cb394-22" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(<span class="fu">filter</span>(Data.precision.Spatial,Method<span class="sc">==</span><span class="st">&#39;True&#39;</span> <span class="sc">|</span> Method<span class="sc">==</span><span class="st">&#39;EstimatedNaive&#39;</span>),<span class="fu">aes</span>(<span class="at">x=</span>Method,<span class="at">y=</span>TE,<span class="at">color=</span>Method,<span class="at">group=</span>Method)) <span class="sc">+</span><span class="co">#filter(,Method!=&#39;EstimatedConley&#39;)</span></span>
<span id="cb394-23"><a href="cluster.html#cb394-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb394-24"><a href="cluster.html#cb394-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_errorbar</span>(<span class="fu">aes</span>(<span class="at">ymin=</span>TE<span class="fl">-1.96</span><span class="sc">*</span>Se,<span class="at">ymax=</span>TE<span class="fl">+1.96</span><span class="sc">*</span>Se,<span class="at">color=</span>Method,<span class="at">group=</span>Method),<span class="at">width=</span><span class="fl">0.1</span>)<span class="sc">+</span></span>
<span id="cb394-25"><a href="cluster.html#cb394-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>() <span class="sc">+</span></span>
<span id="cb394-26"><a href="cluster.html#cb394-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">legend.position=</span><span class="st">&quot;none&quot;</span>) </span></code></pre></div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:SpatialMonteCarloPlot"></span>
<img src="STCI_files/figure-html/SpatialMonteCarloPlot-1.png" alt="True vs estimated sampling noise under spatial autocorrelation" width="65%" />
<p class="caption">
Figure 9.10: True vs estimated sampling noise under spatial autocorrelation
</p>
</div>
<p>As we can see on the second plot on Figure <a href="cluster.html#fig:SpatialMonteCarloPlot">9.10</a>, there is a major difference between the true and estimated sampling noise.
Default OLS standard errors underestimate sampling noise severely: the true 99% level of sampling noise stemming from the Monte Carlo replications is equal to 0.18, while the sampling noise estimated using default OLS standard errors is equal to 0.1.</p>
</div>
<div id="design-effect-in-spatially-autocorrelated-data" class="section level3 hasAnchor" number="9.3.2">
<h3><span class="header-section-number">9.3.2</span> Design effect in spatially autocorrelated data<a href="cluster.html#design-effect-in-spatially-autocorrelated-data" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>To derive the design with spatially autocorrelated data, we are going to assume a simple situation in which each observation has <span class="math inline">\(k\)</span> neighbors, and their error terms are correlated with correlation coefficient <span class="math inline">\(\rho\)</span>.
We denote <span class="math inline">\(\mathcal{N}_{i,j}\)</span> the variable that takes value <span class="math inline">\(1\)</span> when <span class="math inline">\(j\)</span> is the neighbor of <span class="math inline">\(i\)</span> and zero otherwise.
Under most contiguity matrices, we have <span class="math inline">\(\mathcal{N}_{i,j}=\mathcal{N}_{j,i}\)</span>.
We also assume, for simplicity, constant treatment effects.
This enables us to only focus on autocorrelation between potential outcome without the treatment, and thus to only focus on one autocorrelation parameter <span class="math inline">\(\rho\)</span>, and one variance parameter, <span class="math inline">\(\sigma^2=\var{U_i^0}\)</span>.</p>
<div class="hypothesis">
<p><span id="hyp:SpatialACErrors" class="hypothesis"><strong>Hypothesis 9.3  (Spatially Autocorrelated Errors) </strong></span>We assume that the error terms are homoskedastic and autocorrelated:</p>
<p><span class="math display">\[\begin{align*}
  \esp{UU&#39;} &amp; = \sigma^2\Omega,
\end{align*}\]</span></p>
<p>with <span class="math inline">\(\Omega(i,i)=1\)</span>, <span class="math inline">\(\Omega(i,j)=\rho\)</span> when <span class="math inline">\(\mathcal{N}_{i,j}=1\)</span>, and <span class="math inline">\(\Omega(i,j)=0\)</span> when <span class="math inline">\(\mathcal{N}_{i,j}=0\)</span>.
We also assume that <span class="math inline">\(\sum_{j=1}^N\mathcal{N}_{i,j}=k\)</span>, <span class="math inline">\(\forall i\leq N\)</span>.</p>
</div>
<div class="remark">
<p><span id="unlabeled-div-223" class="remark"><em>Remark</em>. </span>Assumption <a href="cluster.html#hyp:SpatialACErrors">9.3</a> imposes a simple contiguity matrix <span class="math inline">\(\Omega\)</span> where all the observations contiguous with <span class="math inline">\(i\)</span> are correlated in the same way with <span class="math inline">\(i\)</span>.
More general spatial correlation matrices can be functions of the distance between <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>, and decrease either linearly or exponentially with the distance.</p>
</div>
<div class="theorem">
<p><span id="thm:VarWWSpatial" class="theorem"><strong>Theorem 9.3  (Variance of the With/Without estimator under Spatial Autocorrelation) </strong></span>Under Assumptions <a href="FPCI.html#def:noselb">1.7</a>, <a href="FPSI.html#hyp:fullrank">2.1</a> and <a href="cluster.html#hyp:SpatialACErrors">9.3</a>,
<span class="math display">\[\begin{align*}
\var{\hat{\Delta^Y_{WW}}|X} &amp; = \frac{1}{N}\left(\frac{\sigma^2}{p(1-p)}(1+k\rho\frac{p_1-p}{p(1-p)})\right),
\end{align*}\]</span></p>
<p>with <span class="math inline">\(p=\plims\frac{1}{N}\sum_{i=1}^ND_i\)</span> and <span class="math inline">\(p_1=\plims\frac{1}{\sum_{i=1}^ND_i}\sum_{i=1}^ND_i\frac{1}{k}\sum_{j\neq i}\mathcal{N}_{i,j}D_j\)</span>.</p>
</div>
<div class="proof">
<p><span id="unlabeled-div-224" class="proof"><em>Proof</em>. </span>See in Appendix <a href="proofs.html#proofVarWWSpatial">A.5.3</a>.</p>
</div>
<div class="remark">
<p><span id="unlabeled-div-225" class="remark"><em>Remark</em>. </span>The result in Theorem <a href="cluster.html#thm:VarWWSpatial">9.3</a> makes a lot of sense.
It says that there are three conditions for the variance of the treatment effect parameter to be unaffected by spatial autocorrelation:</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(k=0\)</span>: each unit has no neighbor with which it is correlated, which might happen if the sample is scattered across space.</li>
<li><span class="math inline">\(\rho=0\)</span>: there is no spatial autocorrelation in error terms.</li>
<li><span class="math inline">\(p_1=p\)</span>: the proportion of neighbors of treated units which are treated is equal to the proportion of treated units in the population.
Stated otherwise: there is no correlation between the treatment status of neighbors.</li>
</ol>
<p>If none of these conditions are met, then the variance of the WW estimator increases when <span class="math inline">\(p_1&gt;p\)</span>, that is when the neighbors of treated units are more likely to be treated than units taken at random in the population.
In that case, the treatment is clustered across space: treated units tend to cluster together, even if not in as clean a pattern as when all the observations in each cluster where either treated or not treated.</p>
</div>
<div class="remark">
<p><span id="unlabeled-div-226" class="remark"><em>Remark</em>. </span>Point 3 above is crucial.
There is no problem with clustering or spatial autocorrelation of the outcomes as long as the treatment is not itself spatially autocorrelated.
With one-stage RCT, where treatment is randomized at the unit level, no clustering is required even if the outcomes are autocorrelated over space.
With a clustered RCT in which all units of each cluster have either probability zero or one to be treated, there is no need to account for autocorrelation beyond that that exists at the level of the clusters.
These two points are made even more generally in Lemma 4 and Theorem 1 in <a href="https://doi.org/10.1080/01621459.2012.682524">Barrios, Diamond, Imbens and Kolesar (2012)</a> in the case of Randomization Inference.</p>
</div>
</div>
<div id="estimating-sampling-noise-with-spatially-autocorrelated-data" class="section level3 hasAnchor" number="9.3.3">
<h3><span class="header-section-number">9.3.3</span> Estimating sampling noise with spatially autocorrelated data<a href="cluster.html#estimating-sampling-noise-with-spatially-autocorrelated-data" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Let us now study how to estimate sampling noise in data where there is spatial autocorrelation.
There are at least three ways to do just that: either use the plug-in formula, estimate the covariance matrix of error terms <span class="math inline">\(\sigma^2\Omega\)</span> and use Feasible Generalized Least Squares or
use a covariance matrix robust to spatial correlation.</p>
<div id="using-the-plug-in-formula-1" class="section level4 hasAnchor" number="9.3.3.1">
<h4><span class="header-section-number">9.3.3.1</span> Using the plug-in formula<a href="cluster.html#using-the-plug-in-formula-1" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>One possibility would be to use the plug-in formula in Theorem <a href="cluster.html#thm:VarWWSpatial">9.3</a>.
It requires to determine <span class="math inline">\(k\)</span>, the number of neighbors (which is mostly a modelling choice, depending on the size of the pixel and on the shape of the contiguity matrix).
Then one has to estimate <span class="math inline">\(\rho\)</span>, the correlation between the error term of unit <span class="math inline">\(i\)</span> and of its neighbors.
One quick way to do just that is to regress the estimated residuals <span class="math inline">\(\hat{U}_i\)</span> on an average of the residuals of the neighbors of <span class="math inline">\(i\)</span>.
Then, one has to estimate <span class="math inline">\(p\)</span> and <span class="math inline">\(p_1\)</span>, which are simply the average proportion of treated units in the sample and among the neighbors of treated units, respectively.</p>
<p>This approach can be convenient as a quick fix but the formula is simplified by the existence of only one type of neighbors.
In real life, influence might decrease over space more continuously.
Also, this approach mostly works when the sample covers all space (like pixels, for example).
In real life, samples might cover only part of the space, making <span class="math inline">\(k\)</span> vary with each unit.
A valid approach would be to use the average number of neighbors over the sample <span class="math inline">\(\bar{k}\)</span> as an estimate of <span class="math inline">\(k\)</span>.</p>
<div class="example">
<p><span id="exm:unnamed-chunk-387" class="example"><strong>Example 9.9  </strong></span>Let’s see how this works in our example.
The key is first to estimate the value of <span class="math inline">\(\rho\)</span>.
<span class="math inline">\(\rho\)</span> measures the correlation of the outcomes between two neighboring observations.
One way to do just that is to estimate the average correlation between the error terms of all the units and of their neighbors.
There are at least two ways to do that: sum all the products of the error terms of each individual and of its neighbors and divide by the total number of neighbors.
Or sum all the products of the error terms for each unit with its neighbors, divide by the number of each unit’s neighbors, and then take the average of that.
For the first approach, we can take the matrix of the products of the residuals, and multiply it by the matrix of neighbors, before it has been normalized by the number of neighbors at each line.
The second approach uses the normalized matrix.
Both approaches rely on taking the sum of the diagonal terms of the resulting product matrix, since this is where the terms corresponding to the neighbors of each unit are.
Let’s go.</p>
</div>
<div class="sourceCode" id="cb395"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb395-1"><a href="cluster.html#cb395-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Computing the matrix of the products of the residuals</span></span>
<span id="cb395-2"><a href="cluster.html#cb395-2" aria-hidden="true" tabindex="-1"></a>UU <span class="ot">&lt;-</span> U<span class="sc">%*%</span><span class="fu">t</span>(U)</span>
<span id="cb395-3"><a href="cluster.html#cb395-3" aria-hidden="true" tabindex="-1"></a><span class="co"># First approach</span></span>
<span id="cb395-4"><a href="cluster.html#cb395-4" aria-hidden="true" tabindex="-1"></a>Prod <span class="ot">&lt;-</span> DistanceMatrixDiscrete20<span class="sc">%*%</span>UU</span>
<span id="cb395-5"><a href="cluster.html#cb395-5" aria-hidden="true" tabindex="-1"></a>Rho.First <span class="ot">&lt;-</span> <span class="fu">sum</span>(<span class="fu">diag</span>(Prod))<span class="sc">/</span><span class="fu">sum</span>(<span class="fu">rowSums</span>(DistanceMatrixDiscrete20))</span>
<span id="cb395-6"><a href="cluster.html#cb395-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Second approach</span></span>
<span id="cb395-7"><a href="cluster.html#cb395-7" aria-hidden="true" tabindex="-1"></a>Prod.Second <span class="ot">&lt;-</span> DistanceMatrixDiscreteWeights20<span class="sc">%*%</span>UU</span>
<span id="cb395-8"><a href="cluster.html#cb395-8" aria-hidden="true" tabindex="-1"></a>Rho.Second <span class="ot">&lt;-</span> <span class="fu">sum</span>(<span class="fu">diag</span>(Prod.Second))<span class="sc">/</span><span class="fu">nrow</span>(DistanceMatrixDiscreteWeights20)</span>
<span id="cb395-9"><a href="cluster.html#cb395-9" aria-hidden="true" tabindex="-1"></a><span class="co"># mean number of neighbors</span></span>
<span id="cb395-10"><a href="cluster.html#cb395-10" aria-hidden="true" tabindex="-1"></a>k <span class="ot">&lt;-</span> <span class="fu">mean</span>(<span class="fu">rowSums</span>(DistanceMatrixDiscrete20))</span></code></pre></div>
<p>Both approaches give consistent results: approach one gives <span class="math inline">\(\hat\rho=\)</span> 0.01 and approach two gives <span class="math inline">\(\hat\rho=\)</span> 0.02.
Now, we need to compute <span class="math inline">\(k\)</span>.
We use the mean number of neighbors: <span class="math inline">\(\hat k=\)</span> 109.
Finally, we need to compute <span class="math inline">\(p_1\)</span>, the average number of treated neighbors of treated units.
For that, we can do the same thing as for estimating <span class="math inline">\(\rho\)</span>, except that we use the treatment indicator in the place of <span class="math inline">\(U\)</span>, and we use the second approach.</p>
<div class="sourceCode" id="cb396"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb396-1"><a href="cluster.html#cb396-1" aria-hidden="true" tabindex="-1"></a>DD <span class="ot">&lt;-</span> SpatialData<span class="sc">$</span>Ds<span class="sc">%*%</span><span class="fu">t</span>(SpatialData<span class="sc">$</span>Ds)</span>
<span id="cb396-2"><a href="cluster.html#cb396-2" aria-hidden="true" tabindex="-1"></a>ProdDD <span class="ot">&lt;-</span> DistanceMatrixDiscreteWeights20<span class="sc">%*%</span>DD</span>
<span id="cb396-3"><a href="cluster.html#cb396-3" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">&lt;-</span> <span class="fu">sum</span>(<span class="fu">diag</span>(ProdDD))<span class="sc">/</span><span class="fu">sum</span>(SpatialData<span class="sc">$</span>Ds)</span>
<span id="cb396-4"><a href="cluster.html#cb396-4" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fu">sum</span>(SpatialData<span class="sc">$</span>Ds)<span class="sc">/</span><span class="fu">nrow</span>(DistanceMatrixDiscreteWeights20)</span>
<span id="cb396-5"><a href="cluster.html#cb396-5" aria-hidden="true" tabindex="-1"></a>CorrP1 <span class="ot">&lt;-</span> (p1<span class="sc">-</span>p)<span class="sc">/</span>(p<span class="sc">*</span>(<span class="dv">1</span><span class="sc">-</span>p))</span></code></pre></div>
<p>Our estimates yield that <span class="math inline">\(\hat{p}_1=\)</span> 0.65 and <span class="math inline">\(\hat{p}=\)</span> 0.55.
Let us now compute the correction term and our estimate of the variance of the with/without estimator:</p>
<div class="sourceCode" id="cb397"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb397-1"><a href="cluster.html#cb397-1" aria-hidden="true" tabindex="-1"></a>Correction <span class="ot">&lt;-</span> k<span class="sc">*</span>Rho.Second<span class="sc">*</span>CorrP1</span>
<span id="cb397-2"><a href="cluster.html#cb397-2" aria-hidden="true" tabindex="-1"></a>VarWWSpatial <span class="ot">&lt;-</span> (<span class="fu">var</span>(<span class="fu">as.numeric</span>(U))<span class="sc">/</span>(p<span class="sc">*</span>(<span class="dv">1</span><span class="sc">-</span>p))<span class="sc">*</span>(<span class="dv">1</span><span class="sc">+</span>Correction))<span class="sc">/</span><span class="fu">nrow</span>(DistanceMatrixDiscreteWeights20)</span>
<span id="cb397-3"><a href="cluster.html#cb397-3" aria-hidden="true" tabindex="-1"></a>SeWWPlugIn <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(VarWWSpatial)</span></code></pre></div>
<p>Using the plug-in estimator, we estimate the standard error of the WW estimator to be equal to 0.02.
Remember that the true standard error estimated over Monte Carlo replications is equal to 0.06 and that the naive standard error is: 0.02.</p>
<div class="remark">
<p><span id="unlabeled-div-227" class="remark"><em>Remark</em>. </span>Extending this approach so that it is robust to heteroskedasticity is left as an exercise.</p>
</div>
</div>
<div id="using-feasible-generalized-least-squares-2" class="section level4 hasAnchor" number="9.3.3.2">
<h4><span class="header-section-number">9.3.3.2</span> Using Feasible Generalized Least Squares<a href="cluster.html#using-feasible-generalized-least-squares-2" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Another approach is to use Feasible Generalized Least Squares, by building an estimator <span class="math inline">\(\hat{\Omega}\)</span> of the matrix <span class="math inline">\(\Omega\)</span> is Assumption <a href="cluster.html#hyp:SpatialACErrors">9.3</a>.
We can then use the FGLS estimator <span class="math inline">\(\hatvar{\hat{\Theta}_{FGLS}}=(X&#39;\hat{\Omega}_{FGLS}^{-1}X)^{-1}\)</span>.</p>
<div class="example">
<p><span id="exm:unnamed-chunk-389" class="example"><strong>Example 9.10  </strong></span>Let’s see how this works in our example.</p>
</div>
<p>In the previous section, we have computed an estimator of <span class="math inline">\(\rho\)</span> and an estimator of <span class="math inline">\(\sigma^2\)</span>.
We also know the structure of the matrix of neighbors.
We can thus compute <span class="math inline">\(\hat{\Omega}\)</span>.
Let’s go.</p>
<div class="sourceCode" id="cb398"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb398-1"><a href="cluster.html#cb398-1" aria-hidden="true" tabindex="-1"></a>OmegaNeighbors <span class="ot">&lt;-</span> Rho.Second<span class="sc">*</span>DistanceMatrixDiscrete20</span>
<span id="cb398-2"><a href="cluster.html#cb398-2" aria-hidden="true" tabindex="-1"></a>OmegaSpatial <span class="ot">&lt;-</span> <span class="fu">var</span>(<span class="fu">as.numeric</span>(U))<span class="sc">*</span>(<span class="fu">Diagonal</span>(<span class="fu">nrow</span>(DistanceMatrixDiscrete20),<span class="at">x=</span><span class="dv">1</span>)<span class="sc">+</span>Rho.Second<span class="sc">*</span>DistanceMatrixDiscrete20)</span>
<span id="cb398-3"><a href="cluster.html#cb398-3" aria-hidden="true" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="fu">rep</span>(<span class="dv">1</span>,<span class="fu">nrow</span>(DistanceMatrixDiscrete20)),SpatialData<span class="sc">$</span>Ds),<span class="at">nrow=</span><span class="fu">nrow</span>(DistanceMatrixDiscrete20),<span class="at">ncol=</span><span class="dv">2</span>)</span>
<span id="cb398-4"><a href="cluster.html#cb398-4" aria-hidden="true" tabindex="-1"></a>Var.Theta.FGLS <span class="ot">&lt;-</span> <span class="fu">solve</span>(<span class="fu">t</span>(X)<span class="sc">%*%</span><span class="fu">solve</span>(OmegaSpatial)<span class="sc">%*%</span>X) </span>
<span id="cb398-5"><a href="cluster.html#cb398-5" aria-hidden="true" tabindex="-1"></a>SeWWFGLS <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(<span class="fu">diag</span>(Var.Theta.FGLS))[[<span class="dv">2</span>]]</span></code></pre></div>
<p>Using the FGLS estimator, we estimate the standard error of the WW estimator to be equal to 0.02.
Remember that the true standard error estimated over Monte Carlo replications is equal to 0.06 and that the naive standard error is: 0.02.</p>
<div class="remark">
<p><span id="unlabeled-div-228" class="remark"><em>Remark</em>. </span>Extending this approach so that it is robust to heteroskedasticity is left as an exercise.</p>
</div>
</div>
<div id="using-spatial-robust-inference" class="section level4 hasAnchor" number="9.3.3.3">
<h4><span class="header-section-number">9.3.3.3</span> Using Spatial-Robust inference<a href="cluster.html#using-spatial-robust-inference" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Finally, the most widespread way to account for spatial autocorrelation is to use <a href="https://doi.org/10.1016/S0304-4076(98)00084-0">Conley (1999)</a>’s standard errors.
Conley proposes a way to estimate the covariance matrix of the parameters that is robust to (some degree of) spatial autocorrelation in the data.
The original paper by <a href="https://doi.org/10.1016/S0304-4076(98)00084-0">Conley (1999)</a> describes the proposed matrix in its equation (3.13), which is rather difficult to decipher.
Fortunately, <a href="https://doi.org/10.1057/978-1-349-95121-5_2023-1">Conley (2016)</a>’s Palgrave entry is less cryptic.
Here, he writes his proposed estimator for the asymptotic distribution of the IV estimator in simpler terms.
By analogy, and using the fact that OLS is simply that IV estimator using the explanatory variables as instruments for themselves, we can write Conley’s spatially-robust estimator as follows;</p>
<p><span class="math display">\[\begin{align*}
  \sqrt{N}(\hat{\Theta}_{OLS}-\Theta) &amp; \sim \mathcal{N}\left(0,\left(\frac{1}{N}\sum_{i=1}^Nx_ix^{&#39;}_i\right)^{-1}\hat{V}_N\left(\frac{1}{N}\sum_{i=1}^Nx_ix^{&#39;}_i\right)^{-1&#39;}\right) \\
  \hat{V}_N &amp; = \frac{1}{N}\sum_{i=1}^N\sum_{j=1}^NK_N(s_i,s_j)x_i\hat{\epsilon}_i(x_j\hat{\epsilon}_j)^{&#39;},
\end{align*}\]</span></p>
<p>where <span class="math inline">\(x_i\)</span> is the column vector of covariates for observation <span class="math inline">\(i\)</span>, <span class="math inline">\(\hat{\epsilon}_i\)</span> is the estimated OLS residual, <span class="math inline">\(s_i\)</span> are the spatial coordinates of observation <span class="math inline">\(i\)</span> (for example its longitude and latitude) and <span class="math inline">\(K_N\)</span> is a kernel function attributing weights to observation <span class="math inline">\(j\)</span> as a function of its distance to observation <span class="math inline">\(i\)</span>.
The most commonly used of such kernels is the uniform kernel, which takes value one when the distance between <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> is below some threshold and zero otherwise.
This is the kernel we have used when building the <span class="math inline">\(W\)</span> matrix in our example above (except that we have set the distance to zero when <span class="math inline">\(j=i\)</span>, and it is equal to <span class="math inline">\(1\)</span> with the uniform kernel).</p>
<p>One thing that would be great is if we could write Conley’s estimator of the variance/covariance matrix in a fully matrix-style formula (without sums, but only using matrix products).
One assumption that I entertain is that Conley’s matrix is actually identical to <a href="https://doi.org/10.1162/rest_a_00818">Leung (2020)</a>’s matrix, with the entries in <span class="math inline">\(\mathcal{G}\)</span> defined by the values of <span class="math inline">\(K_N(s_i,s_j)\)</span>.
Let’s try to prove that.
First, <span class="math inline">\(\sum_{i=1}^Nx_ix^{&#39;}_i=X&#39;X\)</span>, by the definition of the matrix product.
Second, <span class="math inline">\(\sum_{i=1}^N\sum_{j=1}^NK_N(s_i,s_j)x_i\hat{\epsilon}_i(x_j\hat{\epsilon}_j)^{&#39;}=\hat{\mathcal{M}}&#39;G\hat{\mathcal{M}}\)</span>.
This is because <span class="math inline">\(\hat{\mathcal{M}}&#39;G=\left(\dots,\sum_{j=1}^NK_N(s_i,s_j)(x_j\hat{\epsilon}_j),\dots\right)\)</span>, and <span class="math inline">\(\hat{\mathcal{M}}&#39;G\hat{\mathcal{M}}=\sum_{i=1}^Nx_i\hat{\epsilon}_i\sum_{j=1}^NK_N(s_i,s_j)(x_j^{&#39;}\hat{\epsilon}_j)^{&#39;}\)</span>, again by virtue of matrix multiplication.
Finally, note that the terms in <span class="math inline">\((\frac{1}{N})^{-1}\)</span> simplify, one with the <span class="math inline">\(\frac{1}{N}\)</span> in <span class="math inline">\(\hat{V}_N\)</span> and the other with the <span class="math inline">\(\frac{1}{N}\)</span> stemming from the normalizing factor in <span class="math inline">\(\sqrt{N}(\hat{\Theta}_{OLS}-\Theta)\)</span>.
Ok, so we have that <a href="https://doi.org/10.1016/S0304-4076(98)00084-0">Conley (1999)</a>’s standard errors are a particular case of <a href="https://doi.org/10.1162/rest_a_00818">Leung (2020)</a>’s matrix.</p>
<div class="example">
<p><span id="exm:unnamed-chunk-391" class="example"><strong>Example 9.11  </strong></span>Let’s see how this all works in our example.</p>
</div>
<p>Let us first start with Leung’s formula, and we will then move to the wonderful <code>fixest</code> package, which proposes a <code>vcov_conley()</code> function, but also has a <code>vcov="conley"</code> option.</p>
<div class="sourceCode" id="cb399"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb399-1"><a href="cluster.html#cb399-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Let us first generate the G matrix, which is simply the DistanceMatrixDiscrete matrix plus a diagonal matrix of ones.</span></span>
<span id="cb399-2"><a href="cluster.html#cb399-2" aria-hidden="true" tabindex="-1"></a>G.Conley <span class="ot">&lt;-</span> DistanceMatrixDiscrete20<span class="sc">+</span><span class="fu">Diagonal</span>(<span class="at">n=</span><span class="fu">nrow</span>(DistanceMatrixDiscrete20))</span>
<span id="cb399-3"><a href="cluster.html#cb399-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Let us now generate the M and X matrices</span></span>
<span id="cb399-4"><a href="cluster.html#cb399-4" aria-hidden="true" tabindex="-1"></a><span class="co"># M has two columns: one for U*constant (vector of ones) and the other for U*Ds</span></span>
<span id="cb399-5"><a href="cluster.html#cb399-5" aria-hidden="true" tabindex="-1"></a><span class="co"># normally, the epsilons are used instead of the Us, with epsilon the residuals from an ols regression of U (or Y) on a constant and Ds</span></span>
<span id="cb399-6"><a href="cluster.html#cb399-6" aria-hidden="true" tabindex="-1"></a>SpatialData <span class="ot">&lt;-</span> SpatialData <span class="sc">%&gt;%</span> <span class="fu">mutate</span>(<span class="at">UDs =</span> U<span class="sc">*</span>Ds, <span class="at">Cst =</span> <span class="dv">1</span>)</span>
<span id="cb399-7"><a href="cluster.html#cb399-7" aria-hidden="true" tabindex="-1"></a>M <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(<span class="fu">cbind</span>(SpatialData<span class="sc">$</span>U,SpatialData<span class="sc">$</span>UDs))</span>
<span id="cb399-8"><a href="cluster.html#cb399-8" aria-hidden="true" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(<span class="fu">cbind</span>(SpatialData<span class="sc">$</span>Cst,SpatialData<span class="sc">$</span>Ds))</span>
<span id="cb399-9"><a href="cluster.html#cb399-9" aria-hidden="true" tabindex="-1"></a><span class="co"># LEt us now compute Leung&#39;s matrix</span></span>
<span id="cb399-10"><a href="cluster.html#cb399-10" aria-hidden="true" tabindex="-1"></a>VcovLeung <span class="ot">&lt;-</span> ((<span class="fu">solve</span>(<span class="fu">t</span>(X)<span class="sc">%*%</span>X))<span class="sc">%*%</span><span class="fu">t</span>(M)<span class="sc">%*%</span>G.Conley<span class="sc">%*%</span>M<span class="sc">%*%</span>(<span class="fu">solve</span>(<span class="fu">t</span>(X)<span class="sc">%*%</span>X)))</span>
<span id="cb399-11"><a href="cluster.html#cb399-11" aria-hidden="true" tabindex="-1"></a><span class="co"># SEWWConley</span></span>
<span id="cb399-12"><a href="cluster.html#cb399-12" aria-hidden="true" tabindex="-1"></a>SEWWConley <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(<span class="fu">diag</span>(VcovLeung))[[<span class="dv">2</span>]]</span></code></pre></div>
<p>Using Conley standard errors as implemented using Leung’s matrix, we estimate the standard error of the WW estimator to be equal to 0.05.
Remember that the true standard error estimated over Monte Carlo replications is equal to 0.06 and that the naive standard error is: 0.02.</p>
<p>Let us now check what happens when we use the <code>conley</code> option in fixest.</p>
<div class="sourceCode" id="cb400"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb400-1"><a href="cluster.html#cb400-1" aria-hidden="true" tabindex="-1"></a><span class="co"># computing regression</span></span>
<span id="cb400-2"><a href="cluster.html#cb400-2" aria-hidden="true" tabindex="-1"></a>RegSpatial <span class="ot">&lt;-</span> <span class="fu">feols</span>(U<span class="sc">~</span>Ds,<span class="at">data=</span>SpatialData)</span>
<span id="cb400-3"><a href="cluster.html#cb400-3" aria-hidden="true" tabindex="-1"></a>VcovConleyFixest <span class="ot">&lt;-</span> <span class="fu">vcov_conley</span>(RegSpatial,<span class="at">lat=</span><span class="st">&quot;latitude&quot;</span>,<span class="at">lon=</span><span class="st">&quot;longitude&quot;</span>,<span class="at">cutoff=</span><span class="dv">20</span>)</span>
<span id="cb400-4"><a href="cluster.html#cb400-4" aria-hidden="true" tabindex="-1"></a><span class="co"># SEWWConleyFixest</span></span>
<span id="cb400-5"><a href="cluster.html#cb400-5" aria-hidden="true" tabindex="-1"></a>SEWWConleyFixest <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(<span class="fu">diag</span>(VcovConleyFixest))[[<span class="dv">2</span>]]</span></code></pre></div>
<p>Using the <code>fixest</code>implementation of Conley’s standard errors, we estimate the standard error of the WW estimator to be equal to 0.05.
Remember that the true standard error estimated over Monte Carlo replications is equal to 0.06 and that the naive standard error is: 0.02.</p>
</div>
<div id="monte-carlo-simulations" class="section level4 hasAnchor" number="9.3.3.4">
<h4><span class="header-section-number">9.3.3.4</span> Monte Carlo simulations<a href="cluster.html#monte-carlo-simulations" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Let us check what works best using Monte Carlo simulations of our data generating process.
Actually, we already performed these simulations when we generated the Monte Carlo simulations to show the problem of autocorrelation with default standard errors.
Let’s now just see how the estimators perform:</p>
<div class="sourceCode" id="cb401"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb401-1"><a href="cluster.html#cb401-1" aria-hidden="true" tabindex="-1"></a><span class="co"># plot</span></span>
<span id="cb401-2"><a href="cluster.html#cb401-2" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(Data.precision.Spatial,<span class="fu">aes</span>(<span class="at">x=</span>Method,<span class="at">y=</span>TE,<span class="at">color=</span>Method,<span class="at">group=</span>Method)) <span class="sc">+</span></span>
<span id="cb401-3"><a href="cluster.html#cb401-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb401-4"><a href="cluster.html#cb401-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_errorbar</span>(<span class="fu">aes</span>(<span class="at">ymin=</span>TE<span class="fl">-1.96</span><span class="sc">*</span>Se,<span class="at">ymax=</span>TE<span class="fl">+1.96</span><span class="sc">*</span>Se,<span class="at">color=</span>Method,<span class="at">group=</span>Method),<span class="at">width=</span><span class="fl">0.1</span>)<span class="sc">+</span></span>
<span id="cb401-5"><a href="cluster.html#cb401-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>() <span class="sc">+</span></span>
<span id="cb401-6"><a href="cluster.html#cb401-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">legend.position=</span><span class="st">&quot;none&quot;</span>) </span></code></pre></div>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:SpatialMonteCarloTotPlot"></span>
<img src="STCI_files/figure-html/SpatialMonteCarloTotPlot-1.png" alt="Estimated sampling noise under spatial autocorrelation" width="65%" />
<p class="caption">
Figure 9.11: Estimated sampling noise under spatial autocorrelation
</p>
</div>
<p>It seems that both Conley and Leung standard errors perform very well.
It is unclear why there are not eactly equivalent though, but it might be due to the treatment of degrees of freedom, or specifics in the way Conley standard errors are implemented in <code>fixest</code>.</p>
<div class="remark">
<p><span id="unlabeled-div-229" class="remark"><em>Remark</em>. </span>One last question is how to choose the bandwidth of the social influence matrix.</p>
</div>
<p><strong>Also, change social influence matrix of other methods to 20k to see if they work better then</strong></p>
</div>
</div>
<div id="testing-for-spatial-autocorrelation" class="section level3 hasAnchor" number="9.3.4">
<h3><span class="header-section-number">9.3.4</span> Testing for spatial autocorrelation<a href="cluster.html#testing-for-spatial-autocorrelation" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p><strong>Detail distribution of Morans’I under the null.</strong></p>
</div>
</div>
<div id="clustering-on-a-network" class="section level2 hasAnchor" number="9.4">
<h2><span class="header-section-number">9.4</span> Clustering on a network<a href="cluster.html#clustering-on-a-network" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>A lot of datasets have a network flavor.
A network is simply a set of observations with their accompanying links.
A friendship network is the list of people and the list of their connections (who is friends with whom).
In the case of a directed network (we also talk about directed graph), connections are unidirectionnal (I can be friends with you without you being friends with me).
In an undirected network, connections are bidirectionnal (if I’m friends with you, you are friends with me).
A network can also be a network of firms or countries that are trading with each other.
A network can also be simply linked to geographic distance, or belonging to the same clusters (a firm or a village, for example).
We are going to focus in undirected networks, because, for the purposes of autocorrelation and estimating standard errors, the nature of the network does not matter, all networks are considered undirected.</p>
<p>A key problem that might happen when you assign a treatment on a network is that the probability of receiving the treatment on some parts of the network is higher than in some others.
If error terms are correlated among neighbors in the network, then we again have a problem that is akin to clustering.
Since the units in the network are not i.i.d., we have less free variation than we think and thus the basic CLT fails.
Something similar to the design effect is going to emerge, with the design effect increasing in the amount of auto-correlation in outcomes and in treatment.</p>
<p>Amazingly, the same solution as for clustering and spatial correlation works here.
The <a href="https://doi.org/10.1162/rest_a_00818">Leung (2020)</a> estimator for the covariance matrix of the parameters, which I have already partially introduced above in the context of clustering and spatial autocorrelation, is also going to be valid for estimating sampling noise on a network.
In that case, the <span class="math inline">\(G\)</span> matrix is such that <span class="math inline">\(G_{i,j}=1\)</span> when <span class="math inline">\(i=j\)</span>, or when <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> are neighbors or when <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> share a neighbor, and zero otherwise.
I am not going to study this approach in further detail since I will dedicate a whole chapter to Leung’s estimator when we study diffusion effects in Chapter <a href="Diffusion.html#Diffusion">11</a>.</p>
</div>
<div id="multi-way-clustering" class="section level2 hasAnchor" number="9.5">
<h2><span class="header-section-number">9.5</span> Multi-way clustering<a href="cluster.html#multi-way-clustering" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>What if we go back to panel data, allow for temporal autocorrelation, but also accept that there will be some degree of cross-sectional autocorrelation, like clusters of observations who receive the same level of treatment?
This would happen for example when treatment is clustered at a village, county or state level, for example, and the outcomes are also clustered in that way, while also being autocorrelated over time.
Wages, for example, or employment, but also consumption, are outcomes that are autocorrelated both over space and over time.
If we study the impact of minimum wage laws by using changes at the state-level in these laws, then we have exactly this problem, as has been argued by <a href="https://doi.org/10.1162/003355304772839588">Bertrand et al. (2004)</a> and <a href="https://doi.org/10.1080/01621459.2012.682524">Barrios et al. (2012)</a>.
We are going to explore a few aspects of this issue in what follows, starting with the level at which we should cluster, the type of traditional estimators we can use and a finally a novel approach based on randomization inference.</p>
<div id="at-which-level-should-we-cluster" class="section level3 hasAnchor" number="9.5.1">
<h3><span class="header-section-number">9.5.1</span> At which level should we cluster?<a href="cluster.html#at-which-level-should-we-cluster" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>A first key question is the level at which we should cluster our standard errors.
It all sounds pretty arbitrary.
And in a sense it still is, except in some cases, and we are going to see why and try to find ways to solve this issue.</p>
<div id="appropriate-level-of-clustering-in-randomized-controlled-trials" class="section level4 hasAnchor" number="9.5.1.1">
<h4><span class="header-section-number">9.5.1.1</span> Appropriate level of clustering in Randomized Controlled Trials<a href="cluster.html#appropriate-level-of-clustering-in-randomized-controlled-trials" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>A first way to think about the issue of clustering is in the simplified environment of Randomized Controlled Trials.
<a href="https://doi.org/10.1080/01621459.2012.682524">Barrios et al. (2012)</a> shows that, under some not so restrictive assumptions, the proper level at which to account for clustering is the level at which the treatment is randomly assigned (or as good as randomly assigned).
So if your treatment is randomized at the individual level, you do not need to cluster <strong>at all</strong> if you have cross sectional data, and you need to cluster at the individual level when you have panel data.</p>
</div>
<div id="appropriate-level-of-clustering-in-natural-experiments-and-observational-methods" class="section level4 hasAnchor" number="9.5.1.2">
<h4><span class="header-section-number">9.5.1.2</span> Appropriate level of clustering in natural experiments and observational methods<a href="cluster.html#appropriate-level-of-clustering-in-natural-experiments-and-observational-methods" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>With natural experiments, things become murkier.
Indeed, the treatment has not really been randomly assigned, but only as good as randomly (in the case of natural experiments) and not at all (or conditionnally on covariates) in observational methods.
How the treatment is correlated spatially then matters and is not obvious.
One way around this problem is to investigate spatial correlation in the treatment formally.
One way to do just that, as suggested by <a href="https://doi.org/10.1080/01621459.2012.682524">Barrios et al. (2012)</a>, is to compute Mantel statistics for both treatment and outcomes (in first difference or as residuals of a regression ro reflect the estimation method).
You should cluster at the maximum level where you detect autocorrelation for the treatment variable, or rather at the minimum between the maximum autocorrelation level of the outcome and the treatment.
This approach is not applied in general in empirical research in economics, which therefore leaves a lot to the arbitrary judgement of authors and referees.</p>
<p>In panel data, in general, we tend to cluster at the state level for example, which means we also consider that all observations of the same state for different years are autocorrelated.
This is easy to implement with either the Leung approach (which is actually super adaptable: just use the contigguity matrix that makes sense for your application) or using <code>fixest</code> <code>cluster</code> option.</p>
<p>One tradition that seems to make sense is to try different levels of clustering and test the sensitivity of standard errors to those.
Unfortunately, you then run into another problem: when the number of clusters gets small, CLT-based estimators (including block bootstrap) are biased and generally underestimate sampling noise.
We will look at this issue in more detail in the next section.</p>
<p>Another approach is to leverage the exogenous source of variation and how it drives treatment allocation, and specifically at which spatial and temporal level.
A cutting edge way of doing just that is to use <a href="http://www.nber.org/papers/w27845">Borusyak and Hull (2020)</a>’s approach.
Their approach is reserved for cases when one can express treatment exposure as a known combination of several influences, and only some of these influences are exogenous.</p>
</div>
</div>
</div>
<div id="what-to-do-when-there-are-few-clusters" class="section level2 hasAnchor" number="9.6">
<h2><span class="header-section-number">9.6</span> What to do when there are few clusters?<a href="cluster.html#what-to-do-when-there-are-few-clusters" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>When the number of clusters becomes small (small is hard to define but anything below 42 seems small, and below 10 definitely is very small), the CLT-based approximations to the distribution of the treatment effect estimate are biased.
This is because the residual variance is underestimated, as when sample size is small, because regression is overfitting and thus underestimating the residual variance.
Simulations summarized in Tables VI and VIII of <a href="https://doi.org/10.1162/003355304772839588">Bertrand et al. (2004)</a> show that the rejection rate for a placebo law (so Type I error) moves from around the nominal 5% rate with 50 clusters, to 44% with 6 clusters for block bootstrap and to 11.5% with cluster robust standard errors, which is better but still more than double the nominal rate.</p>
<div id="aggregation" class="section level3 hasAnchor" number="9.6.1">
<h3><span class="header-section-number">9.6.1</span> Aggregation<a href="cluster.html#aggregation" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>One extreme solution is to aggregate all the data at the cluster level, as suggested by <a href="https://doi.org/10.1162/003355304772839588">Bertrand et al. (2004)</a>.
With a treatment clustered at the state level, one could agrgegate outcomes in each state, for two periods: one before and one after the treatment.
With a small number of covariates, one has to use a t-statistic correcting for the actual number of degrees of freedom, as suggested by <a href="https://doi.org/10.1162/rest.89.2.221">Donald and Lang (2007)</a>.
This approach works well in the simulations of <a href="https://doi.org/10.1162/003355304772839588">Bertrand et al. (2004)</a>.</p>
</div>
<div id="permutation-tests" class="section level3 hasAnchor" number="9.6.2">
<h3><span class="header-section-number">9.6.2</span> Permutation tests<a href="cluster.html#permutation-tests" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Recently, <a href="https://doi.org/10.1016/j.jeconom.2019.04.011">Hagemann (2019)</a> has proposed a randomization inference based approach to test for the existence of treatment effects with very few clusters (as low as 6, with 3 treated and 3 untreated).
The test works as follows:</p>
<ol style="list-style-type: decimal">
<li>Randomly select <span class="math inline">\(N_1\)</span> clusters to be treated and <span class="math inline">\(N_0\)</span> to be non treated among the existing clusters (where <span class="math inline">\(N_1\)</span> and <span class="math inline">\(N_0\)</span> are the actual numbers of treated and untreated clusters in your original sample).</li>
<li>Estimate one regression per cluster and recover a critical parameter.
For RCTs, the critical parameter is the intercept of the regression of the outcomes on the control variables.
For DID, the critical parameter is the coefficient on the <span class="math inline">\(post\)</span> dummy, that takes value one when the treatment is on, and zero otherwise.</li>
<li>Compute the difference in means of the critical parameter in the treatment and control group.</li>
<li>If <span class="math inline">\(N_1\neq N_0\)</span>, adjust this difference by a correction factor (a ratio of variance estimates)</li>
<li>Compare the value of the resulting test statistic in the original sample to the distribution of the statistics with randomization inference, which is correct under the null.
permutation (hagemann).</li>
</ol>
<div class="remark">
<p><span id="unlabeled-div-230" class="remark"><em>Remark</em>. </span>You can obtain confidence intervals using the usual method of computing test statistics for various values of the treatment effect.</p>
</div>
<div class="remark">
<p><span id="unlabeled-div-231" class="remark"><em>Remark</em>. </span><a href="https://doi.org/10.1016/j.jeconom.2019.04.011">Hagemann (2019)</a> shows that this procedure is consistent (has correct size when the number of observations grows large), even if the number of clusters stays small.
<a href="https://doi.org/10.1162/rest_a_01300">Hagemann (2023)</a> proposes a similar test allowing for heteroskedasticity across clusters.</p>
</div>
</div>
<div id="wild-bootstrap" class="section level3 hasAnchor" number="9.6.3">
<h3><span class="header-section-number">9.6.3</span> Wild bootstrap<a href="cluster.html#wild-bootstrap" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Although the bootstrap does not work very well with a limited number of clusters, the wild cluster bootstrap seems to work better.
As <a href="https://doi.org/10.3368/jhr.50.2.317">Cameron and Miller (2015)</a> explain, the wild cluster bootstrap works as follows:</p>
<ol style="list-style-type: decimal">
<li>Estimate the main model forcing the null assumption on the data.
That is, for treatment effects models, run the regression without the main treatment indicator (the interaction between <span class="math inline">\(post\)</span> and the treatment group in DID, for example).</li>
<li>Recover the residuals <span class="math inline">\(\tilde{U}_{ic}\)</span>, with <span class="math inline">\(c\)</span> the cluster index, and <span class="math inline">\(i\)</span> the individual index.</li>
<li>Randomly assign each cluster <span class="math inline">\(c\)</span> a weight <span class="math inline">\(d_c=-1\)</span> with probability <span class="math inline">\(0.5\)</span> and <span class="math inline">\(d_c=1\)</span> with probability <span class="math inline">\(0.5\)</span>.</li>
<li>Generate new observations using your main model (either a constant in a simple RCT regression, or a constant, a time dummy and a treatment group dummy in a repeated cross section DID model, or a set of individual fixed effects and time fixed effects in a DID model in panel data) plus <span class="math inline">\(d_c\tilde{U}_{ic}\)</span>.</li>
<li>Estimate the effect of the treatment using your preferred method on this new sample.</li>
<li>Compare the original value of the treatment effect (or rather of the t-statistic) to its bootstrapped distribution (or rather to the bootstrapped distribution of the t-statistic).</li>
</ol>
<div class="remark">
<p><span id="unlabeled-div-232" class="remark"><em>Remark</em>. </span>This approach might have to be adapted somehow to work well with DID models à la Sun and Abraham.
The extension is left as an exercise.</p>
</div>
</div>
<div id="ibragimov-and-muller-2010-group-based-inference" class="section level3 hasAnchor" number="9.6.4">
<h3><span class="header-section-number">9.6.4</span> Ibragimov and Muller (2010) group-based inference<a href="cluster.html#ibragimov-and-muller-2010-group-based-inference" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p><a href="https://doi.org/10.1198/jbes.2009.08046">Ibragimov and Muller (2010)</a> propose to estimate the parameter of interest in <span class="math inline">\(q\)</span> groups that are approximately independent of each other, and to use the resulting distribution to build a test statistic on the mean of the parameter of interest, which will follow a <span class="math inline">\(t(q-1)\)</span> distribution.
For this approach to be consistent, you only need the size of each <span class="math inline">\(q\)</span> group to increase to infinity, not <span class="math inline">\(q\)</span> itself.</p>
<p>For DID applications, Ibragimov and Muller (2010) suggest to define the <span class="math inline">\(q\)</span> groups as encompassing the level at which treatment varies (for example groups of contiguous states) and to compute the DID estimator for each group and then build the <span class="math inline">\(t\)</span>-statistic for the null that the mean effect is zero.
Confidence intervals will be valid.</p>
<p>For clustered RCTs, it all depends on whether <em>(i)</em> treatment is constant within clusters or not, <em>(ii)</em> we are willing to assume that each cluster is independent from its neighbors.
If both assertions are true, then we can compute one treatment effect estimate in each cluster and then derive the distribution of the <span class="math inline">\(t\)</span>-statistic.</p>
<p>For spatially clustered data, Ibragimov and Muller (2010) suggest to define groups as being block of observations located close to each other.
With sufficiently large groups, inference will be based on mostly observations that are independent of each other.</p>
</div>
</div>
<div id="CLTDD" class="section level2 hasAnchor" number="9.7">
<h2><span class="header-section-number">9.7</span> Central Limit Theorems for Dependent Data<a href="cluster.html#CLTDD" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Show a CLT for dependent data (Leung, Conley, etc).</p>
</div>
<div id="DesignBasedClusters" class="section level2 hasAnchor" number="9.8">
<h2><span class="header-section-number">9.8</span> Sampling-based and design-based approaches to clustering<a href="cluster.html#DesignBasedClusters" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Put that in a separate chapter, with similar issues for heteroskedasticity and stratification.</p>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="sec:placebo.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="LaLonde.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/chabefer/STCI/blob/master/08_Cluster.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["STCI.pdf"],
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
},
"toc_depth": 1
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
